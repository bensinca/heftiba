{"id":"UVys","dependencies":[{"name":"/home/beni/Documents/web/andu/package.json","includedInParent":true,"mtime":1606237519381}],"generated":{"js":"var global = arguments[3];\nvar define;\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*!\n// ███   █    ████▄    ▄▄▄▄▀ ▄▄▄▄▀ ▄███▄   █▄▄▄▄\n// █  █  █    █   █ ▀▀▀ █ ▀▀▀ █    █▀   ▀  █  ▄▀\n// █ ▀ ▄ █    █   █     █     █    ██▄▄    █▀▀▌\n// █  ▄▀ ███▄ ▀████    █     █     █▄   ▄▀ █  █\n// ███       ▀        ▀     ▀      ▀███▀     █\n//                                          ▀\n// The MIT License\n//\n// Copyright © 1986 - ∞, Blotter / Bradley Griffith / http://bradley.computer\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n*/\n!function () {\n  var a = \"object\" == (typeof self === \"undefined\" ? \"undefined\" : _typeof(self)) && self.self === self && self || \"object\" == (typeof global === \"undefined\" ? \"undefined\" : _typeof(global)) && global.global === global && global || this,\n      b = a._,\n      c = Array.prototype,\n      d = Object.prototype,\n      e = \"undefined\" != typeof Symbol ? Symbol.prototype : null,\n      f = c.push,\n      g = c.slice,\n      h = d.toString,\n      i = d.hasOwnProperty,\n      j = Array.isArray,\n      k = Object.keys,\n      l = Object.create,\n      m = function m() {},\n      n = function n(a) {\n    return a instanceof n ? a : this instanceof n ? void (this._wrapped = a) : new n(a);\n  };\n\n  \"undefined\" == typeof exports || exports.nodeType ? a._ = n : (\"undefined\" != typeof module && !module.nodeType && module.exports && (exports = module.exports = n), exports._ = n), n.VERSION = \"1.8.3\";\n\n  var o,\n      p = function p(a, b, c) {\n    if (void 0 === b) return a;\n\n    switch (null == c ? 3 : c) {\n      case 1:\n        return function (c) {\n          return a.call(b, c);\n        };\n\n      case 3:\n        return function (c, d, e) {\n          return a.call(b, c, d, e);\n        };\n\n      case 4:\n        return function (c, d, e, f) {\n          return a.call(b, c, d, e, f);\n        };\n    }\n\n    return function () {\n      return a.apply(b, arguments);\n    };\n  },\n      q = function q(a, b, c) {\n    return n.iteratee !== o ? n.iteratee(a, b) : null == a ? n.identity : n.isFunction(a) ? p(a, b, c) : n.isObject(a) ? n.matcher(a) : n.property(a);\n  };\n\n  n.iteratee = o = function o(a, b) {\n    return q(a, b, 1 / 0);\n  };\n\n  var r = function r(a, b) {\n    return b = null == b ? a.length - 1 : +b, function () {\n      for (var c = Math.max(arguments.length - b, 0), d = Array(c), e = 0; e < c; e++) {\n        d[e] = arguments[e + b];\n      }\n\n      switch (b) {\n        case 0:\n          return a.call(this, d);\n\n        case 1:\n          return a.call(this, arguments[0], d);\n\n        case 2:\n          return a.call(this, arguments[0], arguments[1], d);\n      }\n\n      var f = Array(b + 1);\n\n      for (e = 0; e < b; e++) {\n        f[e] = arguments[e];\n      }\n\n      return f[b] = d, a.apply(this, f);\n    };\n  },\n      s = function s(a) {\n    if (!n.isObject(a)) return {};\n    if (l) return l(a);\n    m.prototype = a;\n    var b = new m();\n    return m.prototype = null, b;\n  },\n      t = function t(a) {\n    return function (b) {\n      return null == b ? void 0 : b[a];\n    };\n  },\n      u = Math.pow(2, 53) - 1,\n      v = t(\"length\"),\n      w = function w(a) {\n    var b = v(a);\n    return \"number\" == typeof b && b >= 0 && b <= u;\n  };\n\n  n.each = n.forEach = function (a, b, c) {\n    b = p(b, c);\n    var d, e;\n    if (w(a)) for (d = 0, e = a.length; d < e; d++) {\n      b(a[d], d, a);\n    } else {\n      var f = n.keys(a);\n\n      for (d = 0, e = f.length; d < e; d++) {\n        b(a[f[d]], f[d], a);\n      }\n    }\n    return a;\n  }, n.map = n.collect = function (a, b, c) {\n    b = q(b, c);\n\n    for (var d = !w(a) && n.keys(a), e = (d || a).length, f = Array(e), g = 0; g < e; g++) {\n      var h = d ? d[g] : g;\n      f[g] = b(a[h], h, a);\n    }\n\n    return f;\n  };\n\n  var x = function x(a) {\n    var b = function b(_b2, c, d, e) {\n      var f = !w(_b2) && n.keys(_b2),\n          g = (f || _b2).length,\n          h = a > 0 ? 0 : g - 1;\n\n      for (e || (d = _b2[f ? f[h] : h], h += a); h >= 0 && h < g; h += a) {\n        var i = f ? f[h] : h;\n        d = c(d, _b2[i], i, _b2);\n      }\n\n      return d;\n    };\n\n    return function (a, c, d, e) {\n      var f = arguments.length >= 3;\n      return b(a, p(c, e, 4), d, f);\n    };\n  };\n\n  n.reduce = n.foldl = n.inject = x(1), n.reduceRight = n.foldr = x(-1), n.find = n.detect = function (a, b, c) {\n    var d = w(a) ? n.findIndex : n.findKey,\n        e = d(a, b, c);\n    if (void 0 !== e && -1 !== e) return a[e];\n  }, n.filter = n.select = function (a, b, c) {\n    var d = [];\n    return b = q(b, c), n.each(a, function (a, c, e) {\n      b(a, c, e) && d.push(a);\n    }), d;\n  }, n.reject = function (a, b, c) {\n    return n.filter(a, n.negate(q(b)), c);\n  }, n.every = n.all = function (a, b, c) {\n    b = q(b, c);\n\n    for (var d = !w(a) && n.keys(a), e = (d || a).length, f = 0; f < e; f++) {\n      var g = d ? d[f] : f;\n      if (!b(a[g], g, a)) return !1;\n    }\n\n    return !0;\n  }, n.some = n.any = function (a, b, c) {\n    b = q(b, c);\n\n    for (var d = !w(a) && n.keys(a), e = (d || a).length, f = 0; f < e; f++) {\n      var g = d ? d[f] : f;\n      if (b(a[g], g, a)) return !0;\n    }\n\n    return !1;\n  }, n.contains = n.includes = n.include = function (a, b, c, d) {\n    return w(a) || (a = n.values(a)), (\"number\" != typeof c || d) && (c = 0), n.indexOf(a, b, c) >= 0;\n  }, n.invoke = r(function (a, b, c) {\n    var d = n.isFunction(b);\n    return n.map(a, function (a) {\n      var e = d ? b : a[b];\n      return null == e ? e : e.apply(a, c);\n    });\n  }), n.pluck = function (a, b) {\n    return n.map(a, n.property(b));\n  }, n.where = function (a, b) {\n    return n.filter(a, n.matcher(b));\n  }, n.findWhere = function (a, b) {\n    return n.find(a, n.matcher(b));\n  }, n.max = function (a, b, c) {\n    var d,\n        e,\n        f = -1 / 0,\n        g = -1 / 0;\n\n    if (null == b || \"number\" == typeof b && \"object\" != _typeof(a[0]) && null != a) {\n      a = w(a) ? a : n.values(a);\n\n      for (var h = 0, i = a.length; h < i; h++) {\n        null != (d = a[h]) && d > f && (f = d);\n      }\n    } else b = q(b, c), n.each(a, function (a, c, d) {\n      ((e = b(a, c, d)) > g || e === -1 / 0 && f === -1 / 0) && (f = a, g = e);\n    });\n\n    return f;\n  }, n.min = function (a, b, c) {\n    var d,\n        e,\n        f = 1 / 0,\n        g = 1 / 0;\n\n    if (null == b || \"number\" == typeof b && \"object\" != _typeof(a[0]) && null != a) {\n      a = w(a) ? a : n.values(a);\n\n      for (var h = 0, i = a.length; h < i; h++) {\n        null != (d = a[h]) && d < f && (f = d);\n      }\n    } else b = q(b, c), n.each(a, function (a, c, d) {\n      ((e = b(a, c, d)) < g || e === 1 / 0 && f === 1 / 0) && (f = a, g = e);\n    });\n\n    return f;\n  }, n.shuffle = function (a) {\n    return n.sample(a, 1 / 0);\n  }, n.sample = function (a, b, c) {\n    if (null == b || c) return w(a) || (a = n.values(a)), a[n.random(a.length - 1)];\n    var d = w(a) ? n.clone(a) : n.values(a),\n        e = v(d);\n    b = Math.max(Math.min(b, e), 0);\n\n    for (var f = e - 1, g = 0; g < b; g++) {\n      var h = n.random(g, f),\n          i = d[g];\n      d[g] = d[h], d[h] = i;\n    }\n\n    return d.slice(0, b);\n  }, n.sortBy = function (a, b, c) {\n    var d = 0;\n    return b = q(b, c), n.pluck(n.map(a, function (a, c, e) {\n      return {\n        value: a,\n        index: d++,\n        criteria: b(a, c, e)\n      };\n    }).sort(function (a, b) {\n      var c = a.criteria,\n          d = b.criteria;\n\n      if (c !== d) {\n        if (c > d || void 0 === c) return 1;\n        if (c < d || void 0 === d) return -1;\n      }\n\n      return a.index - b.index;\n    }), \"value\");\n  };\n\n  var y = function y(a, b) {\n    return function (c, d, e) {\n      var f = b ? [[], []] : {};\n      return d = q(d, e), n.each(c, function (b, e) {\n        var g = d(b, e, c);\n        a(f, b, g);\n      }), f;\n    };\n  };\n\n  n.groupBy = y(function (a, b, c) {\n    n.has(a, c) ? a[c].push(b) : a[c] = [b];\n  }), n.indexBy = y(function (a, b, c) {\n    a[c] = b;\n  }), n.countBy = y(function (a, b, c) {\n    n.has(a, c) ? a[c]++ : a[c] = 1;\n  });\n  var z = /[^\\ud800-\\udfff]|[\\ud800-\\udbff][\\udc00-\\udfff]|[\\ud800-\\udfff]/g;\n  n.toArray = function (a) {\n    return a ? n.isArray(a) ? g.call(a) : n.isString(a) ? a.match(z) : w(a) ? n.map(a, n.identity) : n.values(a) : [];\n  }, n.size = function (a) {\n    return null == a ? 0 : w(a) ? a.length : n.keys(a).length;\n  }, n.partition = y(function (a, b, c) {\n    a[c ? 0 : 1].push(b);\n  }, !0), n.first = n.head = n.take = function (a, b, c) {\n    if (null != a) return null == b || c ? a[0] : n.initial(a, a.length - b);\n  }, n.initial = function (a, b, c) {\n    return g.call(a, 0, Math.max(0, a.length - (null == b || c ? 1 : b)));\n  }, n.last = function (a, b, c) {\n    if (null != a) return null == b || c ? a[a.length - 1] : n.rest(a, Math.max(0, a.length - b));\n  }, n.rest = n.tail = n.drop = function (a, b, c) {\n    return g.call(a, null == b || c ? 1 : b);\n  }, n.compact = function (a) {\n    return n.filter(a, Boolean);\n  };\n\n  var A = function A(a, b, c, d) {\n    d = d || [];\n\n    for (var e = d.length, f = 0, g = v(a); f < g; f++) {\n      var h = a[f];\n      if (w(h) && (n.isArray(h) || n.isArguments(h))) {\n        if (b) for (var i = 0, j = h.length; i < j;) {\n          d[e++] = h[i++];\n        } else A(h, b, c, d), e = d.length;\n      } else c || (d[e++] = h);\n    }\n\n    return d;\n  };\n\n  n.flatten = function (a, b) {\n    return A(a, b, !1);\n  }, n.without = r(function (a, b) {\n    return n.difference(a, b);\n  }), n.uniq = n.unique = function (a, b, c, d) {\n    n.isBoolean(b) || (d = c, c = b, b = !1), null != c && (c = q(c, d));\n\n    for (var e = [], f = [], g = 0, h = v(a); g < h; g++) {\n      var i = a[g],\n          j = c ? c(i, g, a) : i;\n      b ? (g && f === j || e.push(i), f = j) : c ? n.contains(f, j) || (f.push(j), e.push(i)) : n.contains(e, i) || e.push(i);\n    }\n\n    return e;\n  }, n.union = r(function (a) {\n    return n.uniq(A(a, !0, !0));\n  }), n.intersection = function (a) {\n    for (var b = [], c = arguments.length, d = 0, e = v(a); d < e; d++) {\n      var f = a[d];\n\n      if (!n.contains(b, f)) {\n        var g;\n\n        for (g = 1; g < c && n.contains(arguments[g], f); g++) {\n          ;\n        }\n\n        g === c && b.push(f);\n      }\n    }\n\n    return b;\n  }, n.difference = r(function (a, b) {\n    return b = A(b, !0, !0), n.filter(a, function (a) {\n      return !n.contains(b, a);\n    });\n  }), n.unzip = function (a) {\n    for (var b = a && n.max(a, v).length || 0, c = Array(b), d = 0; d < b; d++) {\n      c[d] = n.pluck(a, d);\n    }\n\n    return c;\n  }, n.zip = r(n.unzip), n.object = function (a, b) {\n    for (var c = {}, d = 0, e = v(a); d < e; d++) {\n      b ? c[a[d]] = b[d] : c[a[d][0]] = a[d][1];\n    }\n\n    return c;\n  };\n\n  var B = function B(a) {\n    return function (b, c, d) {\n      c = q(c, d);\n\n      for (var e = v(b), f = a > 0 ? 0 : e - 1; f >= 0 && f < e; f += a) {\n        if (c(b[f], f, b)) return f;\n      }\n\n      return -1;\n    };\n  };\n\n  n.findIndex = B(1), n.findLastIndex = B(-1), n.sortedIndex = function (a, b, c, d) {\n    c = q(c, d, 1);\n\n    for (var e = c(b), f = 0, g = v(a); f < g;) {\n      var h = Math.floor((f + g) / 2);\n      c(a[h]) < e ? f = h + 1 : g = h;\n    }\n\n    return f;\n  };\n\n  var C = function C(a, b, c) {\n    return function (d, e, f) {\n      var h = 0,\n          i = v(d);\n      if (\"number\" == typeof f) a > 0 ? h = f >= 0 ? f : Math.max(f + i, h) : i = f >= 0 ? Math.min(f + 1, i) : f + i + 1;else if (c && f && i) return f = c(d, e), d[f] === e ? f : -1;\n      if (e !== e) return f = b(g.call(d, h, i), n.isNaN), f >= 0 ? f + h : -1;\n\n      for (f = a > 0 ? h : i - 1; f >= 0 && f < i; f += a) {\n        if (d[f] === e) return f;\n      }\n\n      return -1;\n    };\n  };\n\n  n.indexOf = C(1, n.findIndex, n.sortedIndex), n.lastIndexOf = C(-1, n.findLastIndex), n.range = function (a, b, c) {\n    null == b && (b = a || 0, a = 0), c || (c = b < a ? -1 : 1);\n\n    for (var d = Math.max(Math.ceil((b - a) / c), 0), e = Array(d), f = 0; f < d; f++, a += c) {\n      e[f] = a;\n    }\n\n    return e;\n  }, n.chunk = function (a, b) {\n    if (null == b || b < 1) return [];\n\n    for (var c = [], d = 0, e = a.length; d < e;) {\n      c.push(g.call(a, d, d += b));\n    }\n\n    return c;\n  };\n\n  var D = function D(a, b, c, d, e) {\n    if (!(d instanceof b)) return a.apply(c, e);\n    var f = s(a.prototype),\n        g = a.apply(f, e);\n    return n.isObject(g) ? g : f;\n  };\n\n  n.bind = r(function (a, b, c) {\n    if (!n.isFunction(a)) throw new TypeError(\"Bind must be called on a function\");\n    var d = r(function (e) {\n      return D(a, d, b, this, c.concat(e));\n    });\n    return d;\n  }), n.partial = r(function (a, b) {\n    var c = n.partial.placeholder,\n        d = function d() {\n      for (var e = 0, f = b.length, g = Array(f), h = 0; h < f; h++) {\n        g[h] = b[h] === c ? arguments[e++] : b[h];\n      }\n\n      for (; e < arguments.length;) {\n        g.push(arguments[e++]);\n      }\n\n      return D(a, d, this, this, g);\n    };\n\n    return d;\n  }), n.partial.placeholder = n, n.bindAll = r(function (a, b) {\n    b = A(b, !1, !1);\n    var c = b.length;\n    if (c < 1) throw new Error(\"bindAll must be passed function names\");\n\n    for (; c--;) {\n      var d = b[c];\n      a[d] = n.bind(a[d], a);\n    }\n  }), n.memoize = function (a, b) {\n    var c = function c(d) {\n      var e = c.cache,\n          f = \"\" + (b ? b.apply(this, arguments) : d);\n      return n.has(e, f) || (e[f] = a.apply(this, arguments)), e[f];\n    };\n\n    return c.cache = {}, c;\n  }, n.delay = r(function (a, b, c) {\n    return setTimeout(function () {\n      return a.apply(null, c);\n    }, b);\n  }), n.defer = n.partial(n.delay, n, 1), n.throttle = function (a, b, c) {\n    var d,\n        e,\n        f,\n        g,\n        h = 0;\n    c || (c = {});\n\n    var i = function i() {\n      h = !1 === c.leading ? 0 : n.now(), d = null, g = a.apply(e, f), d || (e = f = null);\n    },\n        j = function j() {\n      var j = n.now();\n      h || !1 !== c.leading || (h = j);\n      var k = b - (j - h);\n      return e = this, f = arguments, k <= 0 || k > b ? (d && (clearTimeout(d), d = null), h = j, g = a.apply(e, f), d || (e = f = null)) : d || !1 === c.trailing || (d = setTimeout(i, k)), g;\n    };\n\n    return j.cancel = function () {\n      clearTimeout(d), h = 0, d = e = f = null;\n    }, j;\n  }, n.debounce = function (a, b, c) {\n    var d,\n        e,\n        f = function f(b, c) {\n      d = null, c && (e = a.apply(b, c));\n    },\n        g = r(function (g) {\n      if (d && clearTimeout(d), c) {\n        var h = !d;\n        d = setTimeout(f, b), h && (e = a.apply(this, g));\n      } else d = n.delay(f, b, this, g);\n\n      return e;\n    });\n\n    return g.cancel = function () {\n      clearTimeout(d), d = null;\n    }, g;\n  }, n.wrap = function (a, b) {\n    return n.partial(b, a);\n  }, n.negate = function (a) {\n    return function () {\n      return !a.apply(this, arguments);\n    };\n  }, n.compose = function () {\n    var a = arguments,\n        b = a.length - 1;\n    return function () {\n      for (var c = b, d = a[b].apply(this, arguments); c--;) {\n        d = a[c].call(this, d);\n      }\n\n      return d;\n    };\n  }, n.after = function (a, b) {\n    return function () {\n      if (--a < 1) return b.apply(this, arguments);\n    };\n  }, n.before = function (a, b) {\n    var c;\n    return function () {\n      return --a > 0 && (c = b.apply(this, arguments)), a <= 1 && (b = null), c;\n    };\n  }, n.once = n.partial(n.before, 2), n.restArgs = r;\n\n  var E = !{\n    toString: null\n  }.propertyIsEnumerable(\"toString\"),\n      F = [\"valueOf\", \"isPrototypeOf\", \"toString\", \"propertyIsEnumerable\", \"hasOwnProperty\", \"toLocaleString\"],\n      G = function G(a, b) {\n    var c = F.length,\n        e = a.constructor,\n        f = n.isFunction(e) && e.prototype || d,\n        g = \"constructor\";\n\n    for (n.has(a, g) && !n.contains(b, g) && b.push(g); c--;) {\n      (g = F[c]) in a && a[g] !== f[g] && !n.contains(b, g) && b.push(g);\n    }\n  };\n\n  n.keys = function (a) {\n    if (!n.isObject(a)) return [];\n    if (k) return k(a);\n    var b = [];\n\n    for (var c in a) {\n      n.has(a, c) && b.push(c);\n    }\n\n    return E && G(a, b), b;\n  }, n.allKeys = function (a) {\n    if (!n.isObject(a)) return [];\n    var b = [];\n\n    for (var c in a) {\n      b.push(c);\n    }\n\n    return E && G(a, b), b;\n  }, n.values = function (a) {\n    for (var b = n.keys(a), c = b.length, d = Array(c), e = 0; e < c; e++) {\n      d[e] = a[b[e]];\n    }\n\n    return d;\n  }, n.mapObject = function (a, b, c) {\n    b = q(b, c);\n\n    for (var d = n.keys(a), e = d.length, f = {}, g = 0; g < e; g++) {\n      var h = d[g];\n      f[h] = b(a[h], h, a);\n    }\n\n    return f;\n  }, n.pairs = function (a) {\n    for (var b = n.keys(a), c = b.length, d = Array(c), e = 0; e < c; e++) {\n      d[e] = [b[e], a[b[e]]];\n    }\n\n    return d;\n  }, n.invert = function (a) {\n    for (var b = {}, c = n.keys(a), d = 0, e = c.length; d < e; d++) {\n      b[a[c[d]]] = c[d];\n    }\n\n    return b;\n  }, n.functions = n.methods = function (a) {\n    var b = [];\n\n    for (var c in a) {\n      n.isFunction(a[c]) && b.push(c);\n    }\n\n    return b.sort();\n  };\n\n  var H = function H(a, b) {\n    return function (c) {\n      var d = arguments.length;\n      if (b && (c = Object(c)), d < 2 || null == c) return c;\n\n      for (var e = 1; e < d; e++) {\n        for (var f = arguments[e], g = a(f), h = g.length, i = 0; i < h; i++) {\n          var j = g[i];\n          b && void 0 !== c[j] || (c[j] = f[j]);\n        }\n      }\n\n      return c;\n    };\n  };\n\n  n.extend = H(n.allKeys), n.extendOwn = n.assign = H(n.keys), n.findKey = function (a, b, c) {\n    b = q(b, c);\n\n    for (var d, e = n.keys(a), f = 0, g = e.length; f < g; f++) {\n      if (d = e[f], b(a[d], d, a)) return d;\n    }\n  };\n\n  var I = function I(a, b, c) {\n    return b in c;\n  };\n\n  n.pick = r(function (a, b) {\n    var c = {},\n        d = b[0];\n    if (null == a) return c;\n    n.isFunction(d) ? (b.length > 1 && (d = p(d, b[1])), b = n.allKeys(a)) : (d = I, b = A(b, !1, !1), a = Object(a));\n\n    for (var e = 0, f = b.length; e < f; e++) {\n      var g = b[e],\n          h = a[g];\n      d(h, g, a) && (c[g] = h);\n    }\n\n    return c;\n  }), n.omit = r(function (a, b) {\n    var c,\n        d = b[0];\n    return n.isFunction(d) ? (d = n.negate(d), b.length > 1 && (c = b[1])) : (b = n.map(A(b, !1, !1), String), d = function d(a, c) {\n      return !n.contains(b, c);\n    }), n.pick(a, d, c);\n  }), n.defaults = H(n.allKeys, !0), n.create = function (a, b) {\n    var c = s(a);\n    return b && n.extendOwn(c, b), c;\n  }, n.clone = function (a) {\n    return n.isObject(a) ? n.isArray(a) ? a.slice() : n.extend({}, a) : a;\n  }, n.tap = function (a, b) {\n    return b(a), a;\n  }, n.isMatch = function (a, b) {\n    var c = n.keys(b),\n        d = c.length;\n    if (null == a) return !d;\n\n    for (var e = Object(a), f = 0; f < d; f++) {\n      var g = c[f];\n      if (b[g] !== e[g] || !(g in e)) return !1;\n    }\n\n    return !0;\n  };\n  var J, K;\n  J = function J(a, b, c, d) {\n    if (a === b) return 0 !== a || 1 / a == 1 / b;\n    if (null == a || null == b) return a === b;\n    if (a !== a) return b !== b;\n\n    var e = _typeof(a);\n\n    return (\"function\" === e || \"object\" === e || \"object\" == _typeof(b)) && K(a, b, c, d);\n  }, K = function K(a, b, c, d) {\n    a instanceof n && (a = a._wrapped), b instanceof n && (b = b._wrapped);\n    var f = h.call(a);\n    if (f !== h.call(b)) return !1;\n\n    switch (f) {\n      case \"[object RegExp]\":\n      case \"[object String]\":\n        return \"\" + a == \"\" + b;\n\n      case \"[object Number]\":\n        return +a != +a ? +b != +b : 0 == +a ? 1 / +a == 1 / b : +a == +b;\n\n      case \"[object Date]\":\n      case \"[object Boolean]\":\n        return +a == +b;\n\n      case \"[object Symbol]\":\n        return e.valueOf.call(a) === e.valueOf.call(b);\n    }\n\n    var g = \"[object Array]\" === f;\n\n    if (!g) {\n      if (\"object\" != _typeof(a) || \"object\" != _typeof(b)) return !1;\n      var i = a.constructor,\n          j = b.constructor;\n      if (i !== j && !(n.isFunction(i) && i instanceof i && n.isFunction(j) && j instanceof j) && \"constructor\" in a && \"constructor\" in b) return !1;\n    }\n\n    c = c || [], d = d || [];\n\n    for (var k = c.length; k--;) {\n      if (c[k] === a) return d[k] === b;\n    }\n\n    if (c.push(a), d.push(b), g) {\n      if ((k = a.length) !== b.length) return !1;\n\n      for (; k--;) {\n        if (!J(a[k], b[k], c, d)) return !1;\n      }\n    } else {\n      var l,\n          m = n.keys(a);\n      if (k = m.length, n.keys(b).length !== k) return !1;\n\n      for (; k--;) {\n        if (l = m[k], !n.has(b, l) || !J(a[l], b[l], c, d)) return !1;\n      }\n    }\n\n    return c.pop(), d.pop(), !0;\n  }, n.isEqual = function (a, b) {\n    return J(a, b);\n  }, n.isEmpty = function (a) {\n    return null == a || (w(a) && (n.isArray(a) || n.isString(a) || n.isArguments(a)) ? 0 === a.length : 0 === n.keys(a).length);\n  }, n.isElement = function (a) {\n    return !(!a || 1 !== a.nodeType);\n  }, n.isArray = j || function (a) {\n    return \"[object Array]\" === h.call(a);\n  }, n.isObject = function (a) {\n    var b = _typeof(a);\n\n    return \"function\" === b || \"object\" === b && !!a;\n  }, n.each([\"Arguments\", \"Function\", \"String\", \"Number\", \"Date\", \"RegExp\", \"Error\", \"Symbol\", \"Map\", \"WeakMap\", \"Set\", \"WeakSet\"], function (a) {\n    n[\"is\" + a] = function (b) {\n      return h.call(b) === \"[object \" + a + \"]\";\n    };\n  }), n.isArguments(arguments) || (n.isArguments = function (a) {\n    return n.has(a, \"callee\");\n  });\n  var L = a.document && a.document.childNodes;\n  \"function\" != typeof /./ && \"object\" != (typeof Int8Array === \"undefined\" ? \"undefined\" : _typeof(Int8Array)) && \"function\" != typeof L && (n.isFunction = function (a) {\n    return \"function\" == typeof a || !1;\n  }), n.isFinite = function (a) {\n    return !n.isSymbol(a) && isFinite(a) && !isNaN(parseFloat(a));\n  }, n.isNaN = function (a) {\n    return isNaN(a) && n.isNumber(a);\n  }, n.isBoolean = function (a) {\n    return !0 === a || !1 === a || \"[object Boolean]\" === h.call(a);\n  }, n.isNull = function (a) {\n    return null === a;\n  }, n.isUndefined = function (a) {\n    return void 0 === a;\n  }, n.has = function (a, b) {\n    return null != a && i.call(a, b);\n  }, n.noConflict = function () {\n    return a._ = b, this;\n  }, n.identity = function (a) {\n    return a;\n  }, n.constant = function (a) {\n    return function () {\n      return a;\n    };\n  }, n.noop = function () {}, n.property = t, n.propertyOf = function (a) {\n    return null == a ? function () {} : function (b) {\n      return a[b];\n    };\n  }, n.matcher = n.matches = function (a) {\n    return a = n.extendOwn({}, a), function (b) {\n      return n.isMatch(b, a);\n    };\n  }, n.times = function (a, b, c) {\n    var d = Array(Math.max(0, a));\n    b = p(b, c, 1);\n\n    for (var e = 0; e < a; e++) {\n      d[e] = b(e);\n    }\n\n    return d;\n  }, n.random = function (a, b) {\n    return null == b && (b = a, a = 0), a + Math.floor(Math.random() * (b - a + 1));\n  }, n.now = Date.now || function () {\n    return new Date().getTime();\n  };\n\n  var M = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#x27;\",\n    \"`\": \"&#x60;\"\n  },\n      N = n.invert(M),\n      O = function O(a) {\n    var b = function b(_b3) {\n      return a[_b3];\n    },\n        c = \"(?:\" + n.keys(a).join(\"|\") + \")\",\n        d = RegExp(c),\n        e = RegExp(c, \"g\");\n\n    return function (a) {\n      return a = null == a ? \"\" : \"\" + a, d.test(a) ? a.replace(e, b) : a;\n    };\n  };\n\n  n.escape = O(M), n.unescape = O(N), n.result = function (a, b, c) {\n    var d = null == a ? void 0 : a[b];\n    return void 0 === d && (d = c), n.isFunction(d) ? d.call(a) : d;\n  };\n  var P = 0;\n  n.uniqueId = function (a) {\n    var b = ++P + \"\";\n    return a ? a + b : b;\n  }, n.templateSettings = {\n    evaluate: /<%([\\s\\S]+?)%>/g,\n    interpolate: /<%=([\\s\\S]+?)%>/g,\n    escape: /<%-([\\s\\S]+?)%>/g\n  };\n\n  var Q = /(.)^/,\n      R = {\n    \"'\": \"'\",\n    \"\\\\\": \"\\\\\",\n    \"\\r\": \"r\",\n    \"\\n\": \"n\",\n    \"\\u2028\": \"u2028\",\n    \"\\u2029\": \"u2029\"\n  },\n      S = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g,\n      T = function T(a) {\n    return \"\\\\\" + R[a];\n  };\n\n  n.template = function (a, b, c) {\n    !b && c && (b = c), b = n.defaults({}, b, n.templateSettings);\n    var d = RegExp([(b.escape || Q).source, (b.interpolate || Q).source, (b.evaluate || Q).source].join(\"|\") + \"|$\", \"g\"),\n        e = 0,\n        f = \"__p+='\";\n    a.replace(d, function (b, c, d, g, h) {\n      return f += a.slice(e, h).replace(S, T), e = h + b.length, c ? f += \"'+\\n((__t=(\" + c + \"))==null?'':_.escape(__t))+\\n'\" : d ? f += \"'+\\n((__t=(\" + d + \"))==null?'':__t)+\\n'\" : g && (f += \"';\\n\" + g + \"\\n__p+='\"), b;\n    }), f += \"';\\n\", b.variable || (f = \"with(obj||{}){\\n\" + f + \"}\\n\"), f = \"var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\\n\" + f + \"return __p;\\n\";\n    var g;\n\n    try {\n      g = new Function(b.variable || \"obj\", \"_\", f);\n    } catch (a) {\n      throw a.source = f, a;\n    }\n\n    var h = function h(a) {\n      return g.call(this, a, n);\n    },\n        i = b.variable || \"obj\";\n\n    return h.source = \"function(\" + i + \"){\\n\" + f + \"}\", h;\n  }, n.chain = function (a) {\n    var b = n(a);\n    return b._chain = !0, b;\n  };\n\n  var U = function U(a, b) {\n    return a._chain ? n(b).chain() : b;\n  };\n\n  n.mixin = function (a) {\n    return n.each(n.functions(a), function (b) {\n      var c = n[b] = a[b];\n\n      n.prototype[b] = function () {\n        var a = [this._wrapped];\n        return f.apply(a, arguments), U(this, c.apply(n, a));\n      };\n    }), n;\n  }, n.mixin(n), n.each([\"pop\", \"push\", \"reverse\", \"shift\", \"sort\", \"splice\", \"unshift\"], function (a) {\n    var b = c[a];\n\n    n.prototype[a] = function () {\n      var c = this._wrapped;\n      return b.apply(c, arguments), \"shift\" !== a && \"splice\" !== a || 0 !== c.length || delete c[0], U(this, c);\n    };\n  }), n.each([\"concat\", \"join\", \"slice\"], function (a) {\n    var b = c[a];\n\n    n.prototype[a] = function () {\n      return U(this, b.apply(this._wrapped, arguments));\n    };\n  }), n.prototype.value = function () {\n    return this._wrapped;\n  }, n.prototype.valueOf = n.prototype.toJSON = n.prototype.value, n.prototype.toString = function () {\n    return \"\" + this._wrapped;\n  }, \"function\" == typeof define && define.amd && define(\"underscore\", [], function () {\n    return n;\n  });\n}(), function (a, b) {\n  \"object\" == (typeof exports === \"undefined\" ? \"undefined\" : _typeof(exports)) && \"undefined\" != typeof module ? b(exports) : \"function\" == typeof define && define.amd ? define([\"exports\"], b) : b(a.THREE = {});\n}(this, function (a) {\n  \"use strict\";\n\n  function b() {}\n\n  function c(a, b) {\n    this.x = a || 0, this.y = b || 0;\n  }\n\n  function d() {\n    this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error(\"THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.\");\n  }\n\n  function e(a, b, c, d) {\n    this._x = a || 0, this._y = b || 0, this._z = c || 0, this._w = void 0 !== d ? d : 1;\n  }\n\n  function f(a, b, c) {\n    this.x = a || 0, this.y = b || 0, this.z = c || 0;\n  }\n\n  function g() {\n    this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error(\"THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.\");\n  }\n\n  function h(a, b, d, e, f, i, j, k, l, m) {\n    Object.defineProperty(this, \"id\", {\n      value: zd++\n    }), this.uuid = yd.generateUUID(), this.name = \"\", this.image = void 0 !== a ? a : h.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== b ? b : h.DEFAULT_MAPPING, this.wrapS = void 0 !== d ? d : Ec, this.wrapT = void 0 !== e ? e : Ec, this.magFilter = void 0 !== f ? f : Jc, this.minFilter = void 0 !== i ? i : Lc, this.anisotropy = void 0 !== l ? l : 1, this.format = void 0 !== j ? j : $c, this.type = void 0 !== k ? k : Mc, this.offset = new c(0, 0), this.repeat = new c(1, 1), this.center = new c(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new g(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== m ? m : pd, this.version = 0, this.onUpdate = null;\n  }\n\n  function i(a, b, c, d) {\n    this.x = a || 0, this.y = b || 0, this.z = c || 0, this.w = void 0 !== d ? d : 1;\n  }\n\n  function j(a, b, c) {\n    this.uuid = yd.generateUUID(), this.width = a, this.height = b, this.scissor = new i(0, 0, a, b), this.scissorTest = !1, this.viewport = new i(0, 0, a, b), c = c || {}, void 0 === c.minFilter && (c.minFilter = Jc), this.texture = new h(void 0, void 0, c.wrapS, c.wrapT, c.magFilter, c.minFilter, c.format, c.type, c.anisotropy, c.encoding), this.depthBuffer = void 0 === c.depthBuffer || c.depthBuffer, this.stencilBuffer = void 0 === c.stencilBuffer || c.stencilBuffer, this.depthTexture = void 0 !== c.depthTexture ? c.depthTexture : null;\n  }\n\n  function k(a, b, c, d, e, f, g, i, j, k, l, m) {\n    h.call(this, null, f, g, i, j, k, d, e, l, m), this.image = {\n      data: a,\n      width: b,\n      height: c\n    }, this.magFilter = void 0 !== j ? j : Gc, this.minFilter = void 0 !== k ? k : Gc, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;\n  }\n\n  function l(a, b, c, d, e, f, g, i, j, k) {\n    a = void 0 !== a ? a : [], b = void 0 !== b ? b : wc, h.call(this, a, b, c, d, e, f, g, i, j, k), this.flipY = !1;\n  }\n\n  function m() {\n    this.seq = [], this.map = {};\n  }\n\n  function n(a, b, c) {\n    var d = a[0];\n    if (d <= 0 || d > 0) return a;\n    var e = b * c,\n        f = Cd[e];\n\n    if (void 0 === f && (f = new Float32Array(e), Cd[e] = f), 0 !== b) {\n      d.toArray(f, 0);\n\n      for (var g = 1, h = 0; g !== b; ++g) {\n        h += c, a[g].toArray(f, h);\n      }\n    }\n\n    return f;\n  }\n\n  function o(a, b) {\n    var c = Dd[b];\n    void 0 === c && (c = new Int32Array(b), Dd[b] = c);\n\n    for (var d = 0; d !== b; ++d) {\n      c[d] = a.allocTextureUnit();\n    }\n\n    return c;\n  }\n\n  function p(a, b) {\n    a.uniform1f(this.addr, b);\n  }\n\n  function q(a, b) {\n    a.uniform1i(this.addr, b);\n  }\n\n  function r(a, b) {\n    void 0 === b.x ? a.uniform2fv(this.addr, b) : a.uniform2f(this.addr, b.x, b.y);\n  }\n\n  function s(a, b) {\n    void 0 !== b.x ? a.uniform3f(this.addr, b.x, b.y, b.z) : void 0 !== b.r ? a.uniform3f(this.addr, b.r, b.g, b.b) : a.uniform3fv(this.addr, b);\n  }\n\n  function t(a, b) {\n    void 0 === b.x ? a.uniform4fv(this.addr, b) : a.uniform4f(this.addr, b.x, b.y, b.z, b.w);\n  }\n\n  function u(a, b) {\n    a.uniformMatrix2fv(this.addr, !1, b.elements || b);\n  }\n\n  function v(a, b) {\n    void 0 === b.elements ? a.uniformMatrix3fv(this.addr, !1, b) : (Fd.set(b.elements), a.uniformMatrix3fv(this.addr, !1, Fd));\n  }\n\n  function w(a, b) {\n    void 0 === b.elements ? a.uniformMatrix4fv(this.addr, !1, b) : (Ed.set(b.elements), a.uniformMatrix4fv(this.addr, !1, Ed));\n  }\n\n  function x(a, b, c) {\n    var d = c.allocTextureUnit();\n    a.uniform1i(this.addr, d), c.setTexture2D(b || Ad, d);\n  }\n\n  function y(a, b, c) {\n    var d = c.allocTextureUnit();\n    a.uniform1i(this.addr, d), c.setTextureCube(b || Bd, d);\n  }\n\n  function z(a, b) {\n    a.uniform2iv(this.addr, b);\n  }\n\n  function A(a, b) {\n    a.uniform3iv(this.addr, b);\n  }\n\n  function B(a, b) {\n    a.uniform4iv(this.addr, b);\n  }\n\n  function C(a) {\n    switch (a) {\n      case 5126:\n        return p;\n\n      case 35664:\n        return r;\n\n      case 35665:\n        return s;\n\n      case 35666:\n        return t;\n\n      case 35674:\n        return u;\n\n      case 35675:\n        return v;\n\n      case 35676:\n        return w;\n\n      case 35678:\n      case 36198:\n        return x;\n\n      case 35680:\n        return y;\n\n      case 5124:\n      case 35670:\n        return q;\n\n      case 35667:\n      case 35671:\n        return z;\n\n      case 35668:\n      case 35672:\n        return A;\n\n      case 35669:\n      case 35673:\n        return B;\n    }\n  }\n\n  function D(a, b) {\n    a.uniform1fv(this.addr, b);\n  }\n\n  function E(a, b) {\n    a.uniform1iv(this.addr, b);\n  }\n\n  function F(a, b) {\n    a.uniform2fv(this.addr, n(b, this.size, 2));\n  }\n\n  function G(a, b) {\n    a.uniform3fv(this.addr, n(b, this.size, 3));\n  }\n\n  function H(a, b) {\n    a.uniform4fv(this.addr, n(b, this.size, 4));\n  }\n\n  function I(a, b) {\n    a.uniformMatrix2fv(this.addr, !1, n(b, this.size, 4));\n  }\n\n  function J(a, b) {\n    a.uniformMatrix3fv(this.addr, !1, n(b, this.size, 9));\n  }\n\n  function K(a, b) {\n    a.uniformMatrix4fv(this.addr, !1, n(b, this.size, 16));\n  }\n\n  function L(a, b, c) {\n    var d = b.length,\n        e = o(c, d);\n    a.uniform1iv(this.addr, e);\n\n    for (var f = 0; f !== d; ++f) {\n      c.setTexture2D(b[f] || Ad, e[f]);\n    }\n  }\n\n  function M(a, b, c) {\n    var d = b.length,\n        e = o(c, d);\n    a.uniform1iv(this.addr, e);\n\n    for (var f = 0; f !== d; ++f) {\n      c.setTextureCube(b[f] || Bd, e[f]);\n    }\n  }\n\n  function N(a) {\n    switch (a) {\n      case 5126:\n        return D;\n\n      case 35664:\n        return F;\n\n      case 35665:\n        return G;\n\n      case 35666:\n        return H;\n\n      case 35674:\n        return I;\n\n      case 35675:\n        return J;\n\n      case 35676:\n        return K;\n\n      case 35678:\n        return L;\n\n      case 35680:\n        return M;\n\n      case 5124:\n      case 35670:\n        return E;\n\n      case 35667:\n      case 35671:\n        return z;\n\n      case 35668:\n      case 35672:\n        return A;\n\n      case 35669:\n      case 35673:\n        return B;\n    }\n  }\n\n  function O(a, b, c) {\n    this.id = a, this.addr = c, this.setValue = C(b.type);\n  }\n\n  function P(a, b, c) {\n    this.id = a, this.addr = c, this.size = b.size, this.setValue = N(b.type);\n  }\n\n  function Q(a) {\n    this.id = a, m.call(this);\n  }\n\n  function R(a, b) {\n    a.seq.push(b), a.map[b.id] = b;\n  }\n\n  function S(a, b, c) {\n    var d = a.name,\n        e = d.length;\n\n    for (Gd.lastIndex = 0;;) {\n      var f = Gd.exec(d),\n          g = Gd.lastIndex,\n          h = f[1],\n          i = \"]\" === f[2],\n          j = f[3];\n\n      if (i && (h |= 0), void 0 === j || \"[\" === j && g + 2 === e) {\n        R(c, void 0 === j ? new O(h, a, b) : new P(h, a, b));\n        break;\n      }\n\n      var k = c.map,\n          l = k[h];\n      void 0 === l && (l = new Q(h), R(c, l)), c = l;\n    }\n  }\n\n  function T(a, b, c) {\n    m.call(this), this.renderer = c;\n\n    for (var d = a.getProgramParameter(b, a.ACTIVE_UNIFORMS), e = 0; e < d; ++e) {\n      var f = a.getActiveUniform(b, e),\n          g = f.name;\n      S(f, a.getUniformLocation(b, g), this);\n    }\n  }\n\n  function U(a, b, c) {\n    return void 0 === b && void 0 === c ? this.set(a) : this.setRGB(a, b, c);\n  }\n\n  function V(a, b) {\n    this.min = void 0 !== a ? a : new c(1 / 0, 1 / 0), this.max = void 0 !== b ? b : new c(-1 / 0, -1 / 0);\n  }\n\n  function W(a, b, d, e, g) {\n    function h() {\n      var a = new Float32Array([-1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1]),\n          c = new Uint16Array([0, 1, 2, 0, 2, 3]);\n      j = b.createBuffer(), k = b.createBuffer(), b.bindBuffer(b.ARRAY_BUFFER, j), b.bufferData(b.ARRAY_BUFFER, a, b.STATIC_DRAW), b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, k), b.bufferData(b.ELEMENT_ARRAY_BUFFER, c, b.STATIC_DRAW), p = b.createTexture(), q = b.createTexture(), d.bindTexture(b.TEXTURE_2D, p), b.texImage2D(b.TEXTURE_2D, 0, b.RGB, 16, 16, 0, b.RGB, b.UNSIGNED_BYTE, null), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, b.CLAMP_TO_EDGE), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, b.CLAMP_TO_EDGE), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MAG_FILTER, b.NEAREST), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, b.NEAREST), d.bindTexture(b.TEXTURE_2D, q), b.texImage2D(b.TEXTURE_2D, 0, b.RGBA, 16, 16, 0, b.RGBA, b.UNSIGNED_BYTE, null), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, b.CLAMP_TO_EDGE), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, b.CLAMP_TO_EDGE), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MAG_FILTER, b.NEAREST), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, b.NEAREST), l = {\n        vertexShader: [\"uniform lowp int renderType;\", \"uniform vec3 screenPosition;\", \"uniform vec2 scale;\", \"uniform float rotation;\", \"uniform sampler2D occlusionMap;\", \"attribute vec2 position;\", \"attribute vec2 uv;\", \"varying vec2 vUV;\", \"varying float vVisibility;\", \"void main() {\", \"\\tvUV = uv;\", \"\\tvec2 pos = position;\", \"\\tif ( renderType == 2 ) {\", \"\\t\\tvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\", \"\\t\\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\", \"\\t\\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\", \"\\t\\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\", \"\\t\\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\", \"\\t\\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\", \"\\t\\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\", \"\\t\\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\", \"\\t\\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\", \"\\t\\tvVisibility =        visibility.r / 9.0;\", \"\\t\\tvVisibility *= 1.0 - visibility.g / 9.0;\", \"\\t\\tvVisibility *=       visibility.b / 9.0;\", \"\\t\\tvVisibility *= 1.0 - visibility.a / 9.0;\", \"\\t\\tpos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\", \"\\t\\tpos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\", \"\\t}\", \"\\tgl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\", \"}\"].join(\"\\n\"),\n        fragmentShader: [\"uniform lowp int renderType;\", \"uniform sampler2D map;\", \"uniform float opacity;\", \"uniform vec3 color;\", \"varying vec2 vUV;\", \"varying float vVisibility;\", \"void main() {\", \"\\tif ( renderType == 0 ) {\", \"\\t\\tgl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\", \"\\t} else if ( renderType == 1 ) {\", \"\\t\\tgl_FragColor = texture2D( map, vUV );\", \"\\t} else {\", \"\\t\\tvec4 texture = texture2D( map, vUV );\", \"\\t\\ttexture.a *= opacity * vVisibility;\", \"\\t\\tgl_FragColor = texture;\", \"\\t\\tgl_FragColor.rgb *= color;\", \"\\t}\", \"}\"].join(\"\\n\")\n      }, m = i(l), n = {\n        vertex: b.getAttribLocation(m, \"position\"),\n        uv: b.getAttribLocation(m, \"uv\")\n      }, o = {\n        renderType: b.getUniformLocation(m, \"renderType\"),\n        map: b.getUniformLocation(m, \"map\"),\n        occlusionMap: b.getUniformLocation(m, \"occlusionMap\"),\n        opacity: b.getUniformLocation(m, \"opacity\"),\n        color: b.getUniformLocation(m, \"color\"),\n        scale: b.getUniformLocation(m, \"scale\"),\n        rotation: b.getUniformLocation(m, \"rotation\"),\n        screenPosition: b.getUniformLocation(m, \"screenPosition\")\n      };\n    }\n\n    function i(a) {\n      var c = b.createProgram(),\n          d = b.createShader(b.FRAGMENT_SHADER),\n          e = b.createShader(b.VERTEX_SHADER),\n          f = \"precision \" + g.precision + \" float;\\n\";\n      return b.shaderSource(d, f + a.fragmentShader), b.shaderSource(e, f + a.vertexShader), b.compileShader(d), b.compileShader(e), b.attachShader(c, d), b.attachShader(c, e), b.linkProgram(c), c;\n    }\n\n    var j, k, l, m, n, o, p, q;\n\n    this.render = function (a, g, i, l) {\n      if (0 !== a.length) {\n        var r = new f(),\n            s = l.w / l.z,\n            t = .5 * l.z,\n            u = .5 * l.w,\n            v = 16 / l.w,\n            w = new c(v * s, v),\n            x = new f(1, 1, 0),\n            y = new c(1, 1),\n            z = new V();\n        z.min.set(l.x, l.y), z.max.set(l.x + (l.z - 16), l.y + (l.w - 16)), void 0 === m && h(), d.useProgram(m), d.initAttributes(), d.enableAttribute(n.vertex), d.enableAttribute(n.uv), d.disableUnusedAttributes(), b.uniform1i(o.occlusionMap, 0), b.uniform1i(o.map, 1), b.bindBuffer(b.ARRAY_BUFFER, j), b.vertexAttribPointer(n.vertex, 2, b.FLOAT, !1, 16, 0), b.vertexAttribPointer(n.uv, 2, b.FLOAT, !1, 16, 8), b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, k), d.disable(b.CULL_FACE), d.buffers.depth.setMask(!1);\n\n        for (var A = 0, B = a.length; A < B; A++) {\n          v = 16 / l.w, w.set(v * s, v);\n          var C = a[A];\n\n          if (r.set(C.matrixWorld.elements[12], C.matrixWorld.elements[13], C.matrixWorld.elements[14]), r.applyMatrix4(i.matrixWorldInverse), r.applyMatrix4(i.projectionMatrix), x.copy(r), y.x = l.x + x.x * t + t - 8, y.y = l.y + x.y * u + u - 8, !0 === z.containsPoint(y)) {\n            d.activeTexture(b.TEXTURE0), d.bindTexture(b.TEXTURE_2D, null), d.activeTexture(b.TEXTURE1), d.bindTexture(b.TEXTURE_2D, p), b.copyTexImage2D(b.TEXTURE_2D, 0, b.RGB, y.x, y.y, 16, 16, 0), b.uniform1i(o.renderType, 0), b.uniform2f(o.scale, w.x, w.y), b.uniform3f(o.screenPosition, x.x, x.y, x.z), d.disable(b.BLEND), d.enable(b.DEPTH_TEST), b.drawElements(b.TRIANGLES, 6, b.UNSIGNED_SHORT, 0), d.activeTexture(b.TEXTURE0), d.bindTexture(b.TEXTURE_2D, q), b.copyTexImage2D(b.TEXTURE_2D, 0, b.RGBA, y.x, y.y, 16, 16, 0), b.uniform1i(o.renderType, 1), d.disable(b.DEPTH_TEST), d.activeTexture(b.TEXTURE1), d.bindTexture(b.TEXTURE_2D, p), b.drawElements(b.TRIANGLES, 6, b.UNSIGNED_SHORT, 0), C.positionScreen.copy(x), C.customUpdateCallback ? C.customUpdateCallback(C) : C.updateLensFlares(), b.uniform1i(o.renderType, 2), d.enable(b.BLEND);\n\n            for (var D = 0, E = C.lensFlares.length; D < E; D++) {\n              var F = C.lensFlares[D];\n              F.opacity > .001 && F.scale > .001 && (x.x = F.x, x.y = F.y, x.z = F.z, v = F.size * F.scale / l.w, w.x = v * s, w.y = v, b.uniform3f(o.screenPosition, x.x, x.y, x.z), b.uniform2f(o.scale, w.x, w.y), b.uniform1f(o.rotation, F.rotation), b.uniform1f(o.opacity, F.opacity), b.uniform3f(o.color, F.color.r, F.color.g, F.color.b), d.setBlending(F.blending, F.blendEquation, F.blendSrc, F.blendDst), e.setTexture2D(F.texture, 1), b.drawElements(b.TRIANGLES, 6, b.UNSIGNED_SHORT, 0));\n            }\n          }\n        }\n\n        d.enable(b.CULL_FACE), d.enable(b.DEPTH_TEST), d.buffers.depth.setMask(!0), d.reset();\n      }\n    };\n  }\n\n  function X(a, b, c, d, e, f, g, i, j) {\n    h.call(this, a, b, c, d, e, f, g, i, j), this.needsUpdate = !0;\n  }\n\n  function Y(a, b, c, d, g) {\n    function h() {\n      var a = new Float32Array([-.5, -.5, 0, 0, .5, -.5, 1, 0, .5, .5, 1, 1, -.5, .5, 0, 1]),\n          c = new Uint16Array([0, 1, 2, 0, 2, 3]);\n      k = b.createBuffer(), l = b.createBuffer(), b.bindBuffer(b.ARRAY_BUFFER, k), b.bufferData(b.ARRAY_BUFFER, a, b.STATIC_DRAW), b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, l), b.bufferData(b.ELEMENT_ARRAY_BUFFER, c, b.STATIC_DRAW), m = i(), n = {\n        position: b.getAttribLocation(m, \"position\"),\n        uv: b.getAttribLocation(m, \"uv\")\n      }, o = {\n        uvOffset: b.getUniformLocation(m, \"uvOffset\"),\n        uvScale: b.getUniformLocation(m, \"uvScale\"),\n        rotation: b.getUniformLocation(m, \"rotation\"),\n        scale: b.getUniformLocation(m, \"scale\"),\n        color: b.getUniformLocation(m, \"color\"),\n        map: b.getUniformLocation(m, \"map\"),\n        opacity: b.getUniformLocation(m, \"opacity\"),\n        modelViewMatrix: b.getUniformLocation(m, \"modelViewMatrix\"),\n        projectionMatrix: b.getUniformLocation(m, \"projectionMatrix\"),\n        fogType: b.getUniformLocation(m, \"fogType\"),\n        fogDensity: b.getUniformLocation(m, \"fogDensity\"),\n        fogNear: b.getUniformLocation(m, \"fogNear\"),\n        fogFar: b.getUniformLocation(m, \"fogFar\"),\n        fogColor: b.getUniformLocation(m, \"fogColor\"),\n        fogDepth: b.getUniformLocation(m, \"fogDepth\"),\n        alphaTest: b.getUniformLocation(m, \"alphaTest\")\n      };\n      var d = document.createElementNS(\"http://www.w3.org/1999/xhtml\", \"canvas\");\n      d.width = 8, d.height = 8;\n      var e = d.getContext(\"2d\");\n      e.fillStyle = \"white\", e.fillRect(0, 0, 8, 8), p = new X(d);\n    }\n\n    function i() {\n      var a = b.createProgram(),\n          c = b.createShader(b.VERTEX_SHADER),\n          d = b.createShader(b.FRAGMENT_SHADER);\n      return b.shaderSource(c, [\"precision \" + g.precision + \" float;\", \"#define SHADER_NAME SpriteMaterial\", \"uniform mat4 modelViewMatrix;\", \"uniform mat4 projectionMatrix;\", \"uniform float rotation;\", \"uniform vec2 scale;\", \"uniform vec2 uvOffset;\", \"uniform vec2 uvScale;\", \"attribute vec2 position;\", \"attribute vec2 uv;\", \"varying vec2 vUV;\", \"varying float fogDepth;\", \"void main() {\", \"\\tvUV = uvOffset + uv * uvScale;\", \"\\tvec2 alignedPosition = position * scale;\", \"\\tvec2 rotatedPosition;\", \"\\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\", \"\\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\", \"\\tvec4 mvPosition;\", \"\\tmvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\", \"\\tmvPosition.xy += rotatedPosition;\", \"\\tgl_Position = projectionMatrix * mvPosition;\", \"\\tfogDepth = - mvPosition.z;\", \"}\"].join(\"\\n\")), b.shaderSource(d, [\"precision \" + g.precision + \" float;\", \"#define SHADER_NAME SpriteMaterial\", \"uniform vec3 color;\", \"uniform sampler2D map;\", \"uniform float opacity;\", \"uniform int fogType;\", \"uniform vec3 fogColor;\", \"uniform float fogDensity;\", \"uniform float fogNear;\", \"uniform float fogFar;\", \"uniform float alphaTest;\", \"varying vec2 vUV;\", \"varying float fogDepth;\", \"void main() {\", \"\\tvec4 texture = texture2D( map, vUV );\", \"\\tgl_FragColor = vec4( color * texture.xyz, texture.a * opacity );\", \"\\tif ( gl_FragColor.a < alphaTest ) discard;\", \"\\tif ( fogType > 0 ) {\", \"\\t\\tfloat fogFactor = 0.0;\", \"\\t\\tif ( fogType == 1 ) {\", \"\\t\\t\\tfogFactor = smoothstep( fogNear, fogFar, fogDepth );\", \"\\t\\t} else {\", \"\\t\\t\\tconst float LOG2 = 1.442695;\", \"\\t\\t\\tfogFactor = exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 );\", \"\\t\\t\\tfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\", \"\\t\\t}\", \"\\t\\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\", \"\\t}\", \"}\"].join(\"\\n\")), b.compileShader(c), b.compileShader(d), b.attachShader(a, c), b.attachShader(a, d), b.linkProgram(a), a;\n    }\n\n    function j(a, b) {\n      return a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.z !== b.z ? b.z - a.z : b.id - a.id;\n    }\n\n    var k,\n        l,\n        m,\n        n,\n        o,\n        p,\n        q = new f(),\n        r = new e(),\n        s = new f();\n\n    this.render = function (e, f, g) {\n      if (0 !== e.length) {\n        void 0 === m && h(), c.useProgram(m), c.initAttributes(), c.enableAttribute(n.position), c.enableAttribute(n.uv), c.disableUnusedAttributes(), c.disable(b.CULL_FACE), c.enable(b.BLEND), b.bindBuffer(b.ARRAY_BUFFER, k), b.vertexAttribPointer(n.position, 2, b.FLOAT, !1, 16, 0), b.vertexAttribPointer(n.uv, 2, b.FLOAT, !1, 16, 8), b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, l), b.uniformMatrix4fv(o.projectionMatrix, !1, g.projectionMatrix.elements), c.activeTexture(b.TEXTURE0), b.uniform1i(o.map, 0);\n        var i = 0,\n            t = 0,\n            u = f.fog;\n        u ? (b.uniform3f(o.fogColor, u.color.r, u.color.g, u.color.b), u.isFog ? (b.uniform1f(o.fogNear, u.near), b.uniform1f(o.fogFar, u.far), b.uniform1i(o.fogType, 1), i = 1, t = 1) : u.isFogExp2 && (b.uniform1f(o.fogDensity, u.density), b.uniform1i(o.fogType, 2), i = 2, t = 2)) : (b.uniform1i(o.fogType, 0), i = 0, t = 0);\n\n        for (var v = 0, w = e.length; v < w; v++) {\n          var x = e[v];\n          x.modelViewMatrix.multiplyMatrices(g.matrixWorldInverse, x.matrixWorld), x.z = -x.modelViewMatrix.elements[14];\n        }\n\n        e.sort(j);\n\n        for (var y = [], v = 0, w = e.length; v < w; v++) {\n          var x = e[v],\n              z = x.material;\n\n          if (!1 !== z.visible) {\n            x.onBeforeRender(a, f, g, void 0, z, void 0), b.uniform1f(o.alphaTest, z.alphaTest), b.uniformMatrix4fv(o.modelViewMatrix, !1, x.modelViewMatrix.elements), x.matrixWorld.decompose(q, r, s), y[0] = s.x, y[1] = s.y;\n            var A = 0;\n            f.fog && z.fog && (A = t), i !== A && (b.uniform1i(o.fogType, A), i = A), null !== z.map ? (b.uniform2f(o.uvOffset, z.map.offset.x, z.map.offset.y), b.uniform2f(o.uvScale, z.map.repeat.x, z.map.repeat.y)) : (b.uniform2f(o.uvOffset, 0, 0), b.uniform2f(o.uvScale, 1, 1)), b.uniform1f(o.opacity, z.opacity), b.uniform3f(o.color, z.color.r, z.color.g, z.color.b), b.uniform1f(o.rotation, z.rotation), b.uniform2fv(o.scale, y), c.setBlending(z.blending, z.blendEquation, z.blendSrc, z.blendDst, z.blendEquationAlpha, z.blendSrcAlpha, z.blendDstAlpha, z.premultipliedAlpha), c.buffers.depth.setTest(z.depthTest), c.buffers.depth.setMask(z.depthWrite), c.buffers.color.setMask(z.colorWrite), d.setTexture2D(z.map || p, 0), b.drawElements(b.TRIANGLES, 6, b.UNSIGNED_SHORT, 0), x.onAfterRender(a, f, g, void 0, z, void 0);\n          }\n        }\n\n        c.enable(b.CULL_FACE), c.reset();\n      }\n    };\n  }\n\n  function Z() {\n    Object.defineProperty(this, \"id\", {\n      value: Of++\n    }), this.uuid = yd.generateUUID(), this.name = \"\", this.type = \"Material\", this.fog = !0, this.lights = !0, this.blending = Mb, this.side = Gb, this.flatShading = !1, this.vertexColors = Kb, this.opacity = 1, this.transparent = !1, this.blendSrc = $b, this.blendDst = _b, this.blendEquation = Rb, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = ic, this.depthTest = !0, this.depthWrite = !0, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.overdraw = 0, this.visible = !0, this.userData = {}, this.needsUpdate = !0;\n  }\n\n  function $(a) {\n    Z.call(this), this.type = \"MeshDepthMaterial\", this.depthPacking = wd, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.setValues(a);\n  }\n\n  function _(a) {\n    Z.call(this), this.type = \"MeshDistanceMaterial\", this.referencePosition = new f(), this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.lights = !1, this.setValues(a);\n  }\n\n  function aa(a, b) {\n    this.min = void 0 !== a ? a : new f(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== b ? b : new f(-1 / 0, -1 / 0, -1 / 0);\n  }\n\n  function ba(a, b) {\n    this.center = void 0 !== a ? a : new f(), this.radius = void 0 !== b ? b : 0;\n  }\n\n  function ca(a, b) {\n    this.normal = void 0 !== a ? a : new f(1, 0, 0), this.constant = void 0 !== b ? b : 0;\n  }\n\n  function da(a, b, c, d, e, f) {\n    this.planes = [void 0 !== a ? a : new ca(), void 0 !== b ? b : new ca(), void 0 !== c ? c : new ca(), void 0 !== d ? d : new ca(), void 0 !== e ? e : new ca(), void 0 !== f ? f : new ca()];\n  }\n\n  function ea(a, b, e) {\n    function g(b, c, d, e, f, g) {\n      var h = b.geometry,\n          i = null,\n          j = t,\n          k = b.customDepthMaterial;\n      if (d && (j = u, k = b.customDistanceMaterial), k) i = k;else {\n        var l = !1;\n        c.morphTargets && (h && h.isBufferGeometry ? l = h.morphAttributes && h.morphAttributes.position && h.morphAttributes.position.length > 0 : h && h.isGeometry && (l = h.morphTargets && h.morphTargets.length > 0)), b.isSkinnedMesh && !1 === c.skinning && console.warn(\"THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:\", b);\n        var m = b.isSkinnedMesh && c.skinning,\n            n = 0;\n        l && (n |= q), m && (n |= r), i = j[n];\n      }\n\n      if (a.localClippingEnabled && !0 === c.clipShadows && 0 !== c.clippingPlanes.length) {\n        var o = i.uuid,\n            p = c.uuid,\n            s = v[o];\n        void 0 === s && (s = {}, v[o] = s);\n        var w = s[p];\n        void 0 === w && (w = i.clone(), s[p] = w), i = w;\n      }\n\n      i.visible = c.visible, i.wireframe = c.wireframe;\n      var x = c.side;\n      return E.renderSingleSided && x == Ib && (x = Gb), E.renderReverseSided && (x === Gb ? x = Hb : x === Hb && (x = Gb)), i.side = x, i.clipShadows = c.clipShadows, i.clippingPlanes = c.clippingPlanes, i.clipIntersection = c.clipIntersection, i.wireframeLinewidth = c.wireframeLinewidth, i.linewidth = c.linewidth, d && i.isMeshDistanceMaterial && (i.referencePosition.copy(e), i.nearDistance = f, i.farDistance = g), i;\n    }\n\n    function h(c, d, e, f) {\n      if (!1 !== c.visible) {\n        if (c.layers.test(d.layers) && (c.isMesh || c.isLine || c.isPoints) && c.castShadow && (!c.frustumCulled || k.intersectsObject(c))) {\n          c.modelViewMatrix.multiplyMatrices(e.matrixWorldInverse, c.matrixWorld);\n          var i = b.update(c),\n              j = c.material;\n          if (Array.isArray(j)) for (var l = i.groups, m = 0, n = l.length; m < n; m++) {\n            var o = l[m],\n                q = j[o.materialIndex];\n\n            if (q && q.visible) {\n              var r = g(c, q, f, p, e.near, e.far);\n              a.renderBufferDirect(e, null, i, r, c, o);\n            }\n          } else if (j.visible) {\n            var r = g(c, j, f, p, e.near, e.far);\n            a.renderBufferDirect(e, null, i, r, c, null);\n          }\n        }\n\n        for (var s = c.children, t = 0, u = s.length; t < u; t++) {\n          h(s[t], d, e, f);\n        }\n      }\n    }\n\n    for (var k = new da(), l = new d(), m = new c(), n = new c(e, e), o = new f(), p = new f(), q = 1, r = 2, s = 1 + (q | r), t = new Array(s), u = new Array(s), v = {}, w = [new f(1, 0, 0), new f(-1, 0, 0), new f(0, 0, 1), new f(0, 0, -1), new f(0, 1, 0), new f(0, -1, 0)], x = [new f(0, 1, 0), new f(0, 1, 0), new f(0, 1, 0), new f(0, 1, 0), new f(0, 0, 1), new f(0, 0, -1)], y = [new i(), new i(), new i(), new i(), new i(), new i()], z = 0; z !== s; ++z) {\n      var A = 0 != (z & q),\n          B = 0 != (z & r),\n          C = new $({\n        depthPacking: xd,\n        morphTargets: A,\n        skinning: B\n      });\n      t[z] = C;\n      var D = new _({\n        morphTargets: A,\n        skinning: B\n      });\n      u[z] = D;\n    }\n\n    var E = this;\n    this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = Eb, this.renderReverseSided = !0, this.renderSingleSided = !0, this.render = function (b, c, d) {\n      if (!1 !== E.enabled && (!1 !== E.autoUpdate || !1 !== E.needsUpdate) && 0 !== b.length) {\n        var e = a.context,\n            f = a.state;\n        f.disable(e.BLEND), f.buffers.color.setClear(1, 1, 1, 1), f.buffers.depth.setTest(!0), f.setScissorTest(!1);\n\n        for (var g, i = 0, q = b.length; i < q; i++) {\n          var r = b[i],\n              s = r.shadow,\n              t = r && r.isPointLight;\n\n          if (void 0 !== s) {\n            var u = s.camera;\n\n            if (m.copy(s.mapSize), m.min(n), t) {\n              var v = m.x,\n                  z = m.y;\n              y[0].set(2 * v, z, v, z), y[1].set(0, z, v, z), y[2].set(3 * v, z, v, z), y[3].set(v, z, v, z), y[4].set(3 * v, 0, v, z), y[5].set(v, 0, v, z), m.x *= 4, m.y *= 2;\n            }\n\n            if (null === s.map) {\n              var A = {\n                minFilter: Gc,\n                magFilter: Gc,\n                format: $c\n              };\n              s.map = new j(m.x, m.y, A), s.map.texture.name = r.name + \".shadowMap\", u.updateProjectionMatrix();\n            }\n\n            s.isSpotLightShadow && s.update(r);\n            var B = s.map,\n                C = s.matrix;\n            p.setFromMatrixPosition(r.matrixWorld), u.position.copy(p), t ? (g = 6, C.makeTranslation(-p.x, -p.y, -p.z)) : (g = 1, o.setFromMatrixPosition(r.target.matrixWorld), u.lookAt(o), u.updateMatrixWorld(), C.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), C.multiply(u.projectionMatrix), C.multiply(u.matrixWorldInverse)), a.setRenderTarget(B), a.clear();\n\n            for (var D = 0; D < g; D++) {\n              if (t) {\n                o.copy(u.position), o.add(w[D]), u.up.copy(x[D]), u.lookAt(o), u.updateMatrixWorld();\n                var F = y[D];\n                f.viewport(F);\n              }\n\n              l.multiplyMatrices(u.projectionMatrix, u.matrixWorldInverse), k.setFromMatrix(l), h(c, d, u, t);\n            }\n          } else console.warn(\"THREE.WebGLShadowMap:\", r, \"has no shadow.\");\n        }\n\n        E.needsUpdate = !1;\n      }\n    };\n  }\n\n  function fa(a) {\n    function b(b, c) {\n      var d = b.array,\n          e = b.dynamic ? a.DYNAMIC_DRAW : a.STATIC_DRAW,\n          f = a.createBuffer();\n      a.bindBuffer(c, f), a.bufferData(c, d, e), b.onUploadCallback();\n      var g = a.FLOAT;\n      return d instanceof Float32Array ? g = a.FLOAT : d instanceof Float64Array ? console.warn(\"THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.\") : d instanceof Uint16Array ? g = a.UNSIGNED_SHORT : d instanceof Int16Array ? g = a.SHORT : d instanceof Uint32Array ? g = a.UNSIGNED_INT : d instanceof Int32Array ? g = a.INT : d instanceof Int8Array ? g = a.BYTE : d instanceof Uint8Array && (g = a.UNSIGNED_BYTE), {\n        buffer: f,\n        type: g,\n        bytesPerElement: d.BYTES_PER_ELEMENT,\n        version: b.version\n      };\n    }\n\n    function c(b, c, d) {\n      var e = c.array,\n          f = c.updateRange;\n      a.bindBuffer(d, b), !1 === c.dynamic ? a.bufferData(d, e, a.STATIC_DRAW) : -1 === f.count ? a.bufferSubData(d, 0, e) : 0 === f.count ? console.error(\"THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.\") : (a.bufferSubData(d, f.offset * e.BYTES_PER_ELEMENT, e.subarray(f.offset, f.offset + f.count)), f.count = -1);\n    }\n\n    function d(a) {\n      return a.isInterleavedBufferAttribute && (a = a.data), g[a.uuid];\n    }\n\n    function e(b) {\n      b.isInterleavedBufferAttribute && (b = b.data);\n      var c = g[b.uuid];\n      c && (a.deleteBuffer(c.buffer), delete g[b.uuid]);\n    }\n\n    function f(a, d) {\n      a.isInterleavedBufferAttribute && (a = a.data);\n      var e = g[a.uuid];\n      void 0 === e ? g[a.uuid] = b(a, d) : e.version < a.version && (c(e.buffer, a, d), e.version = a.version);\n    }\n\n    var g = {};\n    return {\n      get: d,\n      remove: e,\n      update: f\n    };\n  }\n\n  function ga(a, b, c, d) {\n    this._x = a || 0, this._y = b || 0, this._z = c || 0, this._order = d || ga.DefaultOrder;\n  }\n\n  function ha() {\n    this.mask = 1;\n  }\n\n  function ia() {\n    function a() {\n      i.setFromEuler(h, !1);\n    }\n\n    function b() {\n      h.setFromQuaternion(i, void 0, !1);\n    }\n\n    Object.defineProperty(this, \"id\", {\n      value: Pf++\n    }), this.uuid = yd.generateUUID(), this.name = \"\", this.type = \"Object3D\", this.parent = null, this.children = [], this.up = ia.DefaultUp.clone();\n    var c = new f(),\n        h = new ga(),\n        i = new e(),\n        j = new f(1, 1, 1);\n    h.onChange(a), i.onChange(b), Object.defineProperties(this, {\n      position: {\n        enumerable: !0,\n        value: c\n      },\n      rotation: {\n        enumerable: !0,\n        value: h\n      },\n      quaternion: {\n        enumerable: !0,\n        value: i\n      },\n      scale: {\n        enumerable: !0,\n        value: j\n      },\n      modelViewMatrix: {\n        value: new d()\n      },\n      normalMatrix: {\n        value: new g()\n      }\n    }), this.matrix = new d(), this.matrixWorld = new d(), this.matrixAutoUpdate = ia.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new ha(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {};\n  }\n\n  function ja() {\n    ia.call(this), this.type = \"Camera\", this.matrixWorldInverse = new d(), this.projectionMatrix = new d();\n  }\n\n  function ka(a, b, c, d, e, f) {\n    ja.call(this), this.type = \"OrthographicCamera\", this.zoom = 1, this.view = null, this.left = a, this.right = b, this.top = c, this.bottom = d, this.near = void 0 !== e ? e : .1, this.far = void 0 !== f ? f : 2e3, this.updateProjectionMatrix();\n  }\n\n  function la(a, b, c, d, e, g) {\n    this.a = a, this.b = b, this.c = c, this.normal = d && d.isVector3 ? d : new f(), this.vertexNormals = Array.isArray(d) ? d : [], this.color = e && e.isColor ? e : new U(), this.vertexColors = Array.isArray(e) ? e : [], this.materialIndex = void 0 !== g ? g : 0;\n  }\n\n  function ma() {\n    Object.defineProperty(this, \"id\", {\n      value: Qf += 2\n    }), this.uuid = yd.generateUUID(), this.name = \"\", this.type = \"Geometry\", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1;\n  }\n\n  function na(a, b, c) {\n    if (Array.isArray(a)) throw new TypeError(\"THREE.BufferAttribute: array should be a Typed Array.\");\n    this.uuid = yd.generateUUID(), this.name = \"\", this.array = a, this.itemSize = b, this.count = void 0 !== a ? a.length / b : 0, this.normalized = !0 === c, this.dynamic = !1, this.updateRange = {\n      offset: 0,\n      count: -1\n    }, this.onUploadCallback = function () {}, this.version = 0;\n  }\n\n  function oa(a, b, c) {\n    na.call(this, new Int8Array(a), b, c);\n  }\n\n  function pa(a, b, c) {\n    na.call(this, new Uint8Array(a), b, c);\n  }\n\n  function qa(a, b, c) {\n    na.call(this, new Uint8ClampedArray(a), b, c);\n  }\n\n  function ra(a, b, c) {\n    na.call(this, new Int16Array(a), b, c);\n  }\n\n  function sa(a, b, c) {\n    na.call(this, new Uint16Array(a), b, c);\n  }\n\n  function ta(a, b, c) {\n    na.call(this, new Int32Array(a), b, c);\n  }\n\n  function ua(a, b, c) {\n    na.call(this, new Uint32Array(a), b, c);\n  }\n\n  function va(a, b, c) {\n    na.call(this, new Float32Array(a), b, c);\n  }\n\n  function wa(a, b, c) {\n    na.call(this, new Float64Array(a), b, c);\n  }\n\n  function xa() {\n    this.indices = [], this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1;\n  }\n\n  function ya(a) {\n    if (0 === a.length) return -1 / 0;\n\n    for (var b = a[0], c = 1, d = a.length; c < d; ++c) {\n      a[c] > b && (b = a[c]);\n    }\n\n    return b;\n  }\n\n  function za() {\n    Object.defineProperty(this, \"id\", {\n      value: Rf += 2\n    }), this.uuid = yd.generateUUID(), this.name = \"\", this.type = \"BufferGeometry\", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {\n      start: 0,\n      count: 1 / 0\n    };\n  }\n\n  function Aa(a, b, c, d, e, f) {\n    ma.call(this), this.type = \"BoxGeometry\", this.parameters = {\n      width: a,\n      height: b,\n      depth: c,\n      widthSegments: d,\n      heightSegments: e,\n      depthSegments: f\n    }, this.fromBufferGeometry(new Ba(a, b, c, d, e, f)), this.mergeVertices();\n  }\n\n  function Ba(a, b, c, d, e, g) {\n    function h(a, b, c, d, e, g, h, p, q, r, s) {\n      var t,\n          u,\n          v = g / q,\n          w = h / r,\n          x = g / 2,\n          y = h / 2,\n          z = p / 2,\n          A = q + 1,\n          B = r + 1,\n          C = 0,\n          D = 0,\n          E = new f();\n\n      for (u = 0; u < B; u++) {\n        var F = u * w - y;\n\n        for (t = 0; t < A; t++) {\n          var G = t * v - x;\n          E[a] = G * d, E[b] = F * e, E[c] = z, k.push(E.x, E.y, E.z), E[a] = 0, E[b] = 0, E[c] = p > 0 ? 1 : -1, l.push(E.x, E.y, E.z), m.push(t / q), m.push(1 - u / r), C += 1;\n        }\n      }\n\n      for (u = 0; u < r; u++) {\n        for (t = 0; t < q; t++) {\n          var H = n + t + A * u,\n              I = n + t + A * (u + 1),\n              J = n + (t + 1) + A * (u + 1),\n              K = n + (t + 1) + A * u;\n          j.push(H, I, K), j.push(I, J, K), D += 6;\n        }\n      }\n\n      i.addGroup(o, D, s), o += D, n += C;\n    }\n\n    za.call(this), this.type = \"BoxBufferGeometry\", this.parameters = {\n      width: a,\n      height: b,\n      depth: c,\n      widthSegments: d,\n      heightSegments: e,\n      depthSegments: g\n    };\n    var i = this;\n    a = a || 1, b = b || 1, c = c || 1, d = Math.floor(d) || 1, e = Math.floor(e) || 1, g = Math.floor(g) || 1;\n    var j = [],\n        k = [],\n        l = [],\n        m = [],\n        n = 0,\n        o = 0;\n    h(\"z\", \"y\", \"x\", -1, -1, c, b, a, g, e, 0), h(\"z\", \"y\", \"x\", 1, -1, c, b, -a, g, e, 1), h(\"x\", \"z\", \"y\", 1, 1, a, c, b, d, g, 2), h(\"x\", \"z\", \"y\", 1, -1, a, c, -b, d, g, 3), h(\"x\", \"y\", \"z\", 1, -1, a, b, c, d, e, 4), h(\"x\", \"y\", \"z\", -1, -1, a, b, -c, d, e, 5), this.setIndex(j), this.addAttribute(\"position\", new va(k, 3)), this.addAttribute(\"normal\", new va(l, 3)), this.addAttribute(\"uv\", new va(m, 2));\n  }\n\n  function Ca(a, b, c, d) {\n    ma.call(this), this.type = \"PlaneGeometry\", this.parameters = {\n      width: a,\n      height: b,\n      widthSegments: c,\n      heightSegments: d\n    }, this.fromBufferGeometry(new Da(a, b, c, d)), this.mergeVertices();\n  }\n\n  function Da(a, b, c, d) {\n    za.call(this), this.type = \"PlaneBufferGeometry\", this.parameters = {\n      width: a,\n      height: b,\n      widthSegments: c,\n      heightSegments: d\n    }, a = a || 1, b = b || 1;\n    var e,\n        f,\n        g = a / 2,\n        h = b / 2,\n        i = Math.floor(c) || 1,\n        j = Math.floor(d) || 1,\n        k = i + 1,\n        l = j + 1,\n        m = a / i,\n        n = b / j,\n        o = [],\n        p = [],\n        q = [],\n        r = [];\n\n    for (f = 0; f < l; f++) {\n      var s = f * n - h;\n\n      for (e = 0; e < k; e++) {\n        var t = e * m - g;\n        p.push(t, -s, 0), q.push(0, 0, 1), r.push(e / i), r.push(1 - f / j);\n      }\n    }\n\n    for (f = 0; f < j; f++) {\n      for (e = 0; e < i; e++) {\n        var u = e + k * f,\n            v = e + k * (f + 1),\n            w = e + 1 + k * (f + 1),\n            x = e + 1 + k * f;\n        o.push(u, v, x), o.push(v, w, x);\n      }\n    }\n\n    this.setIndex(o), this.addAttribute(\"position\", new va(p, 3)), this.addAttribute(\"normal\", new va(q, 3)), this.addAttribute(\"uv\", new va(r, 2));\n  }\n\n  function Ea(a) {\n    Z.call(this), this.type = \"MeshBasicMaterial\", this.color = new U(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = nc, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = \"round\", this.wireframeLinejoin = \"round\", this.skinning = !1, this.morphTargets = !1, this.lights = !1, this.setValues(a);\n  }\n\n  function Fa(a) {\n    Z.call(this), this.type = \"ShaderMaterial\", this.defines = {}, this.uniforms = {}, this.vertexShader = \"void main() {\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}\", this.fragmentShader = \"void main() {\\n\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}\", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = {\n      derivatives: !1,\n      fragDepth: !1,\n      drawBuffers: !1,\n      shaderTextureLOD: !1\n    }, this.defaultAttributeValues = {\n      color: [1, 1, 1],\n      uv: [0, 0],\n      uv2: [0, 0]\n    }, this.index0AttributeName = void 0, void 0 !== a && (void 0 !== a.attributes && console.error(\"THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.\"), this.setValues(a));\n  }\n\n  function Ga(a, b) {\n    this.origin = void 0 !== a ? a : new f(), this.direction = void 0 !== b ? b : new f();\n  }\n\n  function Ha(a, b) {\n    this.start = void 0 !== a ? a : new f(), this.end = void 0 !== b ? b : new f();\n  }\n\n  function Ia(a, b, c) {\n    this.a = void 0 !== a ? a : new f(), this.b = void 0 !== b ? b : new f(), this.c = void 0 !== c ? c : new f();\n  }\n\n  function Ja(a, b) {\n    ia.call(this), this.type = \"Mesh\", this.geometry = void 0 !== a ? a : new za(), this.material = void 0 !== b ? b : new Ea({\n      color: 16777215 * Math.random()\n    }), this.drawMode = md, this.updateMorphTargets();\n  }\n\n  function Ka(a, b, c, d) {\n    function e(b, d, e, l) {\n      var m = d.background;\n      null === m ? f(j, k) : m && m.isColor && (f(m, 1), l = !0), (a.autoClear || l) && a.clear(a.autoClearColor, a.autoClearDepth, a.autoClearStencil), m && m.isCubeTexture ? (void 0 === i && (i = new Ja(new Ba(1, 1, 1), new Fa({\n        uniforms: Nf.cube.uniforms,\n        vertexShader: Nf.cube.vertexShader,\n        fragmentShader: Nf.cube.fragmentShader,\n        side: Hb,\n        depthTest: !0,\n        depthWrite: !1,\n        fog: !1\n      })), i.geometry.removeAttribute(\"normal\"), i.geometry.removeAttribute(\"uv\"), i.onBeforeRender = function (a, b, c) {\n        this.matrixWorld.copyPosition(c.matrixWorld);\n      }, c.update(i.geometry)), i.material.uniforms.tCube.value = m, b.push(i, i.geometry, i.material, 0, null)) : m && m.isTexture && (void 0 === g && (g = new ka(-1, 1, 1, -1, 0, 1), h = new Ja(new Da(2, 2), new Ea({\n        depthTest: !1,\n        depthWrite: !1,\n        fog: !1\n      })), c.update(h.geometry)), h.material.map = m, a.renderBufferDirect(g, null, h.geometry, h.material, h, null));\n    }\n\n    function f(a, c) {\n      b.buffers.color.setClear(a.r, a.g, a.b, c, d);\n    }\n\n    var g,\n        h,\n        i,\n        j = new U(0),\n        k = 0;\n    return {\n      getClearColor: function getClearColor() {\n        return j;\n      },\n      setClearColor: function setClearColor(a, b) {\n        j.set(a), k = void 0 !== b ? b : 1, f(j, k);\n      },\n      getClearAlpha: function getClearAlpha() {\n        return k;\n      },\n      setClearAlpha: function setClearAlpha(a) {\n        k = a, f(j, k);\n      },\n      render: e\n    };\n  }\n\n  function La(a, b) {\n    return a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.program && b.program && a.program !== b.program ? a.program.id - b.program.id : a.material.id !== b.material.id ? a.material.id - b.material.id : a.z !== b.z ? a.z - b.z : a.id - b.id;\n  }\n\n  function Ma(a, b) {\n    return a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.z !== b.z ? b.z - a.z : a.id - b.id;\n  }\n\n  function Na() {\n    function a() {\n      e = 0, f.length = 0, g.length = 0;\n    }\n\n    function b(a, b, c, h, i) {\n      var j = d[e];\n      void 0 === j ? (j = {\n        id: a.id,\n        object: a,\n        geometry: b,\n        material: c,\n        program: c.program,\n        renderOrder: a.renderOrder,\n        z: h,\n        group: i\n      }, d[e] = j) : (j.id = a.id, j.object = a, j.geometry = b, j.material = c, j.program = c.program, j.renderOrder = a.renderOrder, j.z = h, j.group = i), (!0 === c.transparent ? g : f).push(j), e++;\n    }\n\n    function c() {\n      f.length > 1 && f.sort(La), g.length > 1 && g.sort(Ma);\n    }\n\n    var d = [],\n        e = 0,\n        f = [],\n        g = [];\n    return {\n      opaque: f,\n      transparent: g,\n      init: a,\n      push: b,\n      sort: c\n    };\n  }\n\n  function Oa() {\n    function a(a, b) {\n      var d = a.id + \",\" + b.id,\n          e = c[d];\n      return void 0 === e && (e = new Na(), c[d] = e), e;\n    }\n\n    function b() {\n      c = {};\n    }\n\n    var c = {};\n    return {\n      get: a,\n      dispose: b\n    };\n  }\n\n  function Pa(a, b) {\n    return Math.abs(b[1]) - Math.abs(a[1]);\n  }\n\n  function Qa(a) {\n    function b(b, e, f, g) {\n      var h = b.morphTargetInfluences,\n          i = h.length,\n          j = c[e.id];\n\n      if (void 0 === j) {\n        j = [];\n\n        for (var k = 0; k < i; k++) {\n          j[k] = [k, 0];\n        }\n\n        c[e.id] = j;\n      }\n\n      for (var l = f.morphTargets && e.morphAttributes.position, m = f.morphNormals && e.morphAttributes.normal, k = 0; k < i; k++) {\n        var n = j[k];\n        0 !== n[1] && (l && e.removeAttribute(\"morphTarget\" + k), m && e.removeAttribute(\"morphNormal\" + k));\n      }\n\n      for (var k = 0; k < i; k++) {\n        var n = j[k];\n        n[0] = k, n[1] = h[k];\n      }\n\n      j.sort(Pa);\n\n      for (var k = 0; k < 8; k++) {\n        var n = j[k];\n\n        if (n) {\n          var o = n[0],\n              p = n[1];\n\n          if (p) {\n            l && e.addAttribute(\"morphTarget\" + k, l[o]), m && e.addAttribute(\"morphNormal\" + k, m[o]), d[k] = p;\n            continue;\n          }\n        }\n\n        d[k] = 0;\n      }\n\n      g.getUniforms().setValue(a, \"morphTargetInfluences\", d);\n    }\n\n    var c = {},\n        d = new Float32Array(8);\n    return {\n      update: b\n    };\n  }\n\n  function Ra(a, b, c) {\n    function d(a) {\n      h = a;\n    }\n\n    function e(a) {\n      i = a.type, j = a.bytesPerElement;\n    }\n\n    function f(b, d) {\n      a.drawElements(h, d, i, b * j), c.calls++, c.vertices += d, h === a.TRIANGLES ? c.faces += d / 3 : h === a.POINTS && (c.points += d);\n    }\n\n    function g(d, e, f) {\n      var g = b.get(\"ANGLE_instanced_arrays\");\n      if (null === g) return void console.error(\"THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.\");\n      g.drawElementsInstancedANGLE(h, f, i, e * j, d.maxInstancedCount), c.calls++, c.vertices += f * d.maxInstancedCount, h === a.TRIANGLES ? c.faces += d.maxInstancedCount * f / 3 : h === a.POINTS && (c.points += d.maxInstancedCount * f);\n    }\n\n    var h, i, j;\n    this.setMode = d, this.setIndex = e, this.render = f, this.renderInstances = g;\n  }\n\n  function Sa(a, b, c) {\n    function d(a) {\n      g = a;\n    }\n\n    function e(b, d) {\n      a.drawArrays(g, b, d), c.calls++, c.vertices += d, g === a.TRIANGLES ? c.faces += d / 3 : g === a.POINTS && (c.points += d);\n    }\n\n    function f(d, e, f) {\n      var h = b.get(\"ANGLE_instanced_arrays\");\n      if (null === h) return void console.error(\"THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.\");\n      var i = d.attributes.position;\n      i.isInterleavedBufferAttribute ? (f = i.data.count, h.drawArraysInstancedANGLE(g, 0, f, d.maxInstancedCount)) : h.drawArraysInstancedANGLE(g, e, f, d.maxInstancedCount), c.calls++, c.vertices += f * d.maxInstancedCount, g === a.TRIANGLES ? c.faces += d.maxInstancedCount * f / 3 : g === a.POINTS && (c.points += d.maxInstancedCount * f);\n    }\n\n    var g;\n    this.setMode = d, this.render = e, this.renderInstances = f;\n  }\n\n  function Ta(a, b, c) {\n    function d(a) {\n      var e = a.target,\n          f = h[e.id];\n      null !== f.index && b.remove(f.index);\n\n      for (var g in f.attributes) {\n        b.remove(f.attributes[g]);\n      }\n\n      e.removeEventListener(\"dispose\", d), delete h[e.id];\n      var j = i[e.id];\n      j && (b.remove(j), delete i[e.id]), j = i[f.id], j && (b.remove(j), delete i[f.id]), c.geometries--;\n    }\n\n    function e(a, b) {\n      var e = h[b.id];\n      return e || (b.addEventListener(\"dispose\", d), b.isBufferGeometry ? e = b : b.isGeometry && (void 0 === b._bufferGeometry && (b._bufferGeometry = new za().setFromObject(a)), e = b._bufferGeometry), h[b.id] = e, c.geometries++, e);\n    }\n\n    function f(c) {\n      var d = c.index,\n          e = c.attributes;\n      null !== d && b.update(d, a.ELEMENT_ARRAY_BUFFER);\n\n      for (var f in e) {\n        b.update(e[f], a.ARRAY_BUFFER);\n      }\n\n      var g = c.morphAttributes;\n\n      for (var f in g) {\n        for (var h = g[f], i = 0, j = h.length; i < j; i++) {\n          b.update(h[i], a.ARRAY_BUFFER);\n        }\n      }\n    }\n\n    function g(c) {\n      var d = i[c.id];\n      if (d) return d;\n      var e = [],\n          f = c.index,\n          g = c.attributes;\n      if (null !== f) for (var h = f.array, j = 0, k = h.length; j < k; j += 3) {\n        var l = h[j + 0],\n            m = h[j + 1],\n            n = h[j + 2];\n        e.push(l, m, m, n, n, l);\n      } else for (var h = g.position.array, j = 0, k = h.length / 3 - 1; j < k; j += 3) {\n        var l = j + 0,\n            m = j + 1,\n            n = j + 2;\n        e.push(l, m, m, n, n, l);\n      }\n      return d = new (ya(e) > 65535 ? ua : sa)(e, 1), b.update(d, a.ELEMENT_ARRAY_BUFFER), i[c.id] = d, d;\n    }\n\n    var h = {},\n        i = {};\n    return {\n      get: e,\n      update: f,\n      getWireframeAttribute: g\n    };\n  }\n\n  function Ua() {\n    var a = {};\n    return {\n      get: function get(b) {\n        if (void 0 !== a[b.id]) return a[b.id];\n        var d;\n\n        switch (b.type) {\n          case \"DirectionalLight\":\n            d = {\n              direction: new f(),\n              color: new U(),\n              shadow: !1,\n              shadowBias: 0,\n              shadowRadius: 1,\n              shadowMapSize: new c()\n            };\n            break;\n\n          case \"SpotLight\":\n            d = {\n              position: new f(),\n              direction: new f(),\n              color: new U(),\n              distance: 0,\n              coneCos: 0,\n              penumbraCos: 0,\n              decay: 0,\n              shadow: !1,\n              shadowBias: 0,\n              shadowRadius: 1,\n              shadowMapSize: new c()\n            };\n            break;\n\n          case \"PointLight\":\n            d = {\n              position: new f(),\n              color: new U(),\n              distance: 0,\n              decay: 0,\n              shadow: !1,\n              shadowBias: 0,\n              shadowRadius: 1,\n              shadowMapSize: new c(),\n              shadowCameraNear: 1,\n              shadowCameraFar: 1e3\n            };\n            break;\n\n          case \"HemisphereLight\":\n            d = {\n              direction: new f(),\n              skyColor: new U(),\n              groundColor: new U()\n            };\n            break;\n\n          case \"RectAreaLight\":\n            d = {\n              color: new U(),\n              position: new f(),\n              halfWidth: new f(),\n              halfHeight: new f()\n            };\n        }\n\n        return a[b.id] = d, d;\n      }\n    };\n  }\n\n  function Va() {\n    function a(a, d, f) {\n      for (var i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = f.matrixWorldInverse, r = 0, s = a.length; r < s; r++) {\n        var t = a[r],\n            u = t.color,\n            v = t.intensity,\n            w = t.distance,\n            x = t.shadow && t.shadow.map ? t.shadow.map.texture : null;\n        if (t.isAmbientLight) i += u.r * v, j += u.g * v, k += u.b * v;else if (t.isDirectionalLight) {\n          var y = b.get(t);\n\n          if (y.color.copy(t.color).multiplyScalar(t.intensity), y.direction.setFromMatrixPosition(t.matrixWorld), e.setFromMatrixPosition(t.target.matrixWorld), y.direction.sub(e), y.direction.transformDirection(q), y.shadow = t.castShadow, t.castShadow) {\n            var z = t.shadow;\n            y.shadowBias = z.bias, y.shadowRadius = z.radius, y.shadowMapSize = z.mapSize;\n          }\n\n          c.directionalShadowMap[l] = x, c.directionalShadowMatrix[l] = t.shadow.matrix, c.directional[l] = y, l++;\n        } else if (t.isSpotLight) {\n          var y = b.get(t);\n\n          if (y.position.setFromMatrixPosition(t.matrixWorld), y.position.applyMatrix4(q), y.color.copy(u).multiplyScalar(v), y.distance = w, y.direction.setFromMatrixPosition(t.matrixWorld), e.setFromMatrixPosition(t.target.matrixWorld), y.direction.sub(e), y.direction.transformDirection(q), y.coneCos = Math.cos(t.angle), y.penumbraCos = Math.cos(t.angle * (1 - t.penumbra)), y.decay = 0 === t.distance ? 0 : t.decay, y.shadow = t.castShadow, t.castShadow) {\n            var z = t.shadow;\n            y.shadowBias = z.bias, y.shadowRadius = z.radius, y.shadowMapSize = z.mapSize;\n          }\n\n          c.spotShadowMap[n] = x, c.spotShadowMatrix[n] = t.shadow.matrix, c.spot[n] = y, n++;\n        } else if (t.isRectAreaLight) {\n          var y = b.get(t);\n          y.color.copy(u).multiplyScalar(v / (t.width * t.height)), y.position.setFromMatrixPosition(t.matrixWorld), y.position.applyMatrix4(q), h.identity(), g.copy(t.matrixWorld), g.premultiply(q), h.extractRotation(g), y.halfWidth.set(.5 * t.width, 0, 0), y.halfHeight.set(0, .5 * t.height, 0), y.halfWidth.applyMatrix4(h), y.halfHeight.applyMatrix4(h), c.rectArea[o] = y, o++;\n        } else if (t.isPointLight) {\n          var y = b.get(t);\n\n          if (y.position.setFromMatrixPosition(t.matrixWorld), y.position.applyMatrix4(q), y.color.copy(t.color).multiplyScalar(t.intensity), y.distance = t.distance, y.decay = 0 === t.distance ? 0 : t.decay, y.shadow = t.castShadow, t.castShadow) {\n            var z = t.shadow;\n            y.shadowBias = z.bias, y.shadowRadius = z.radius, y.shadowMapSize = z.mapSize, y.shadowCameraNear = z.camera.near, y.shadowCameraFar = z.camera.far;\n          }\n\n          c.pointShadowMap[m] = x, c.pointShadowMatrix[m] = t.shadow.matrix, c.point[m] = y, m++;\n        } else if (t.isHemisphereLight) {\n          var y = b.get(t);\n          y.direction.setFromMatrixPosition(t.matrixWorld), y.direction.transformDirection(q), y.direction.normalize(), y.skyColor.copy(t.color).multiplyScalar(v), y.groundColor.copy(t.groundColor).multiplyScalar(v), c.hemi[p] = y, p++;\n        }\n      }\n\n      c.ambient[0] = i, c.ambient[1] = j, c.ambient[2] = k, c.directional.length = l, c.spot.length = n, c.rectArea.length = o, c.point.length = m, c.hemi.length = p, c.hash = l + \",\" + m + \",\" + n + \",\" + o + \",\" + p + \",\" + d.length;\n    }\n\n    var b = new Ua(),\n        c = {\n      hash: \"\",\n      ambient: [0, 0, 0],\n      directional: [],\n      directionalShadowMap: [],\n      directionalShadowMatrix: [],\n      spot: [],\n      spotShadowMap: [],\n      spotShadowMatrix: [],\n      rectArea: [],\n      point: [],\n      pointShadowMap: [],\n      pointShadowMatrix: [],\n      hemi: []\n    },\n        e = new f(),\n        g = new d(),\n        h = new d();\n    return {\n      setup: a,\n      state: c\n    };\n  }\n\n  function Wa(a, b) {\n    function c(c) {\n      var d = b.frame,\n          f = c.geometry,\n          g = a.get(c, f);\n      return e[g.id] !== d && (f.isGeometry && g.updateFromObject(c), a.update(g), e[g.id] = d), g;\n    }\n\n    function d() {\n      e = {};\n    }\n\n    var e = {};\n    return {\n      update: c,\n      clear: d\n    };\n  }\n\n  function Xa(a) {\n    for (var b = a.split(\"\\n\"), c = 0; c < b.length; c++) {\n      b[c] = c + 1 + \": \" + b[c];\n    }\n\n    return b.join(\"\\n\");\n  }\n\n  function Ya(a, b, c) {\n    var d = a.createShader(b);\n    return a.shaderSource(d, c), a.compileShader(d), !1 === a.getShaderParameter(d, a.COMPILE_STATUS) && console.error(\"THREE.WebGLShader: Shader couldn't compile.\"), \"\" !== a.getShaderInfoLog(d) && console.warn(\"THREE.WebGLShader: gl.getShaderInfoLog()\", b === a.VERTEX_SHADER ? \"vertex\" : \"fragment\", a.getShaderInfoLog(d), Xa(c)), d;\n  }\n\n  function Za(a) {\n    switch (a) {\n      case pd:\n        return [\"Linear\", \"( value )\"];\n\n      case qd:\n        return [\"sRGB\", \"( value )\"];\n\n      case sd:\n        return [\"RGBE\", \"( value )\"];\n\n      case td:\n        return [\"RGBM\", \"( value, 7.0 )\"];\n\n      case ud:\n        return [\"RGBM\", \"( value, 16.0 )\"];\n\n      case vd:\n        return [\"RGBD\", \"( value, 256.0 )\"];\n\n      case rd:\n        return [\"Gamma\", \"( value, float( GAMMA_FACTOR ) )\"];\n\n      default:\n        throw new Error(\"unsupported encoding: \" + a);\n    }\n  }\n\n  function $a(a, b) {\n    var c = Za(b);\n    return \"vec4 \" + a + \"( vec4 value ) { return \" + c[0] + \"ToLinear\" + c[1] + \"; }\";\n  }\n\n  function _a(a, b) {\n    var c = Za(b);\n    return \"vec4 \" + a + \"( vec4 value ) { return LinearTo\" + c[0] + c[1] + \"; }\";\n  }\n\n  function ab(a, b) {\n    var c;\n\n    switch (b) {\n      case rc:\n        c = \"Linear\";\n        break;\n\n      case sc:\n        c = \"Reinhard\";\n        break;\n\n      case tc:\n        c = \"Uncharted2\";\n        break;\n\n      case uc:\n        c = \"OptimizedCineon\";\n        break;\n\n      default:\n        throw new Error(\"unsupported toneMapping: \" + b);\n    }\n\n    return \"vec3 \" + a + \"( vec3 color ) { return \" + c + \"ToneMapping( color ); }\";\n  }\n\n  function bb(a, b, c) {\n    return a = a || {}, [a.derivatives || b.envMapCubeUV || b.bumpMap || b.normalMap || b.flatShading ? \"#extension GL_OES_standard_derivatives : enable\" : \"\", (a.fragDepth || b.logarithmicDepthBuffer) && c.get(\"EXT_frag_depth\") ? \"#extension GL_EXT_frag_depth : enable\" : \"\", a.drawBuffers && c.get(\"WEBGL_draw_buffers\") ? \"#extension GL_EXT_draw_buffers : require\" : \"\", (a.shaderTextureLOD || b.envMap) && c.get(\"EXT_shader_texture_lod\") ? \"#extension GL_EXT_shader_texture_lod : enable\" : \"\"].filter(eb).join(\"\\n\");\n  }\n\n  function cb(a) {\n    var b = [];\n\n    for (var c in a) {\n      var d = a[c];\n      !1 !== d && b.push(\"#define \" + c + \" \" + d);\n    }\n\n    return b.join(\"\\n\");\n  }\n\n  function db(a, b) {\n    for (var c = {}, d = a.getProgramParameter(b, a.ACTIVE_ATTRIBUTES), e = 0; e < d; e++) {\n      var f = a.getActiveAttrib(b, e),\n          g = f.name;\n      c[g] = a.getAttribLocation(b, g);\n    }\n\n    return c;\n  }\n\n  function eb(a) {\n    return \"\" !== a;\n  }\n\n  function fb(a, b) {\n    return a.replace(/NUM_DIR_LIGHTS/g, b.numDirLights).replace(/NUM_SPOT_LIGHTS/g, b.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, b.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, b.numPointLights).replace(/NUM_HEMI_LIGHTS/g, b.numHemiLights);\n  }\n\n  function gb(a) {\n    function b(a, b) {\n      var c = Mf[b];\n      if (void 0 === c) throw new Error(\"Can not resolve #include <\" + b + \">\");\n      return gb(c);\n    }\n\n    var c = /^[ \\t]*#include +<([\\w\\d.]+)>/gm;\n    return a.replace(c, b);\n  }\n\n  function hb(a) {\n    function b(a, b, c, d) {\n      for (var e = \"\", f = parseInt(b); f < parseInt(c); f++) {\n        e += d.replace(/\\[ i \\]/g, \"[ \" + f + \" ]\");\n      }\n\n      return e;\n    }\n\n    var c = /for \\( int i \\= (\\d+)\\; i < (\\d+)\\; i \\+\\+ \\) \\{([\\s\\S]+?)(?=\\})\\}/g;\n    return a.replace(c, b);\n  }\n\n  function ib(a, b, c, d, e, f) {\n    var g = a.context,\n        h = d.defines,\n        i = e.vertexShader,\n        j = e.fragmentShader,\n        k = \"SHADOWMAP_TYPE_BASIC\";\n    f.shadowMapType === Eb ? k = \"SHADOWMAP_TYPE_PCF\" : f.shadowMapType === Fb && (k = \"SHADOWMAP_TYPE_PCF_SOFT\");\n    var l = \"ENVMAP_TYPE_CUBE\",\n        m = \"ENVMAP_MODE_REFLECTION\",\n        n = \"ENVMAP_BLENDING_MULTIPLY\";\n\n    if (f.envMap) {\n      switch (d.envMap.mapping) {\n        case wc:\n        case xc:\n          l = \"ENVMAP_TYPE_CUBE\";\n          break;\n\n        case Bc:\n        case Cc:\n          l = \"ENVMAP_TYPE_CUBE_UV\";\n          break;\n\n        case yc:\n        case zc:\n          l = \"ENVMAP_TYPE_EQUIREC\";\n          break;\n\n        case Ac:\n          l = \"ENVMAP_TYPE_SPHERE\";\n      }\n\n      switch (d.envMap.mapping) {\n        case xc:\n        case zc:\n          m = \"ENVMAP_MODE_REFRACTION\";\n      }\n\n      switch (d.combine) {\n        case nc:\n          n = \"ENVMAP_BLENDING_MULTIPLY\";\n          break;\n\n        case oc:\n          n = \"ENVMAP_BLENDING_MIX\";\n          break;\n\n        case pc:\n          n = \"ENVMAP_BLENDING_ADD\";\n      }\n    }\n\n    var o,\n        p,\n        q = a.gammaFactor > 0 ? a.gammaFactor : 1,\n        r = bb(d.extensions, f, b),\n        s = cb(h),\n        t = g.createProgram();\n    d.isRawShaderMaterial ? (o = [s].filter(eb).join(\"\\n\"), o.length > 0 && (o += \"\\n\"), p = [r, s].filter(eb).join(\"\\n\"), p.length > 0 && (p += \"\\n\")) : (o = [\"precision \" + f.precision + \" float;\", \"precision \" + f.precision + \" int;\", \"#define SHADER_NAME \" + e.name, s, f.supportsVertexTextures ? \"#define VERTEX_TEXTURES\" : \"\", \"#define GAMMA_FACTOR \" + q, \"#define MAX_BONES \" + f.maxBones, f.useFog && f.fog ? \"#define USE_FOG\" : \"\", f.useFog && f.fogExp ? \"#define FOG_EXP2\" : \"\", f.map ? \"#define USE_MAP\" : \"\", f.envMap ? \"#define USE_ENVMAP\" : \"\", f.envMap ? \"#define \" + m : \"\", f.lightMap ? \"#define USE_LIGHTMAP\" : \"\", f.aoMap ? \"#define USE_AOMAP\" : \"\", f.emissiveMap ? \"#define USE_EMISSIVEMAP\" : \"\", f.bumpMap ? \"#define USE_BUMPMAP\" : \"\", f.normalMap ? \"#define USE_NORMALMAP\" : \"\", f.displacementMap && f.supportsVertexTextures ? \"#define USE_DISPLACEMENTMAP\" : \"\", f.specularMap ? \"#define USE_SPECULARMAP\" : \"\", f.roughnessMap ? \"#define USE_ROUGHNESSMAP\" : \"\", f.metalnessMap ? \"#define USE_METALNESSMAP\" : \"\", f.alphaMap ? \"#define USE_ALPHAMAP\" : \"\", f.vertexColors ? \"#define USE_COLOR\" : \"\", f.flatShading ? \"#define FLAT_SHADED\" : \"\", f.skinning ? \"#define USE_SKINNING\" : \"\", f.useVertexTexture ? \"#define BONE_TEXTURE\" : \"\", f.morphTargets ? \"#define USE_MORPHTARGETS\" : \"\", f.morphNormals && !1 === f.flatShading ? \"#define USE_MORPHNORMALS\" : \"\", f.doubleSided ? \"#define DOUBLE_SIDED\" : \"\", f.flipSided ? \"#define FLIP_SIDED\" : \"\", \"#define NUM_CLIPPING_PLANES \" + f.numClippingPlanes, f.shadowMapEnabled ? \"#define USE_SHADOWMAP\" : \"\", f.shadowMapEnabled ? \"#define \" + k : \"\", f.sizeAttenuation ? \"#define USE_SIZEATTENUATION\" : \"\", f.logarithmicDepthBuffer ? \"#define USE_LOGDEPTHBUF\" : \"\", f.logarithmicDepthBuffer && b.get(\"EXT_frag_depth\") ? \"#define USE_LOGDEPTHBUF_EXT\" : \"\", \"uniform mat4 modelMatrix;\", \"uniform mat4 modelViewMatrix;\", \"uniform mat4 projectionMatrix;\", \"uniform mat4 viewMatrix;\", \"uniform mat3 normalMatrix;\", \"uniform vec3 cameraPosition;\", \"attribute vec3 position;\", \"attribute vec3 normal;\", \"attribute vec2 uv;\", \"#ifdef USE_COLOR\", \"\\tattribute vec3 color;\", \"#endif\", \"#ifdef USE_MORPHTARGETS\", \"\\tattribute vec3 morphTarget0;\", \"\\tattribute vec3 morphTarget1;\", \"\\tattribute vec3 morphTarget2;\", \"\\tattribute vec3 morphTarget3;\", \"\\t#ifdef USE_MORPHNORMALS\", \"\\t\\tattribute vec3 morphNormal0;\", \"\\t\\tattribute vec3 morphNormal1;\", \"\\t\\tattribute vec3 morphNormal2;\", \"\\t\\tattribute vec3 morphNormal3;\", \"\\t#else\", \"\\t\\tattribute vec3 morphTarget4;\", \"\\t\\tattribute vec3 morphTarget5;\", \"\\t\\tattribute vec3 morphTarget6;\", \"\\t\\tattribute vec3 morphTarget7;\", \"\\t#endif\", \"#endif\", \"#ifdef USE_SKINNING\", \"\\tattribute vec4 skinIndex;\", \"\\tattribute vec4 skinWeight;\", \"#endif\", \"\\n\"].filter(eb).join(\"\\n\"), p = [r, \"precision \" + f.precision + \" float;\", \"precision \" + f.precision + \" int;\", \"#define SHADER_NAME \" + e.name, s, f.alphaTest ? \"#define ALPHATEST \" + f.alphaTest : \"\", \"#define GAMMA_FACTOR \" + q, f.useFog && f.fog ? \"#define USE_FOG\" : \"\", f.useFog && f.fogExp ? \"#define FOG_EXP2\" : \"\", f.map ? \"#define USE_MAP\" : \"\", f.envMap ? \"#define USE_ENVMAP\" : \"\", f.envMap ? \"#define \" + l : \"\", f.envMap ? \"#define \" + m : \"\", f.envMap ? \"#define \" + n : \"\", f.lightMap ? \"#define USE_LIGHTMAP\" : \"\", f.aoMap ? \"#define USE_AOMAP\" : \"\", f.emissiveMap ? \"#define USE_EMISSIVEMAP\" : \"\", f.bumpMap ? \"#define USE_BUMPMAP\" : \"\", f.normalMap ? \"#define USE_NORMALMAP\" : \"\", f.specularMap ? \"#define USE_SPECULARMAP\" : \"\", f.roughnessMap ? \"#define USE_ROUGHNESSMAP\" : \"\", f.metalnessMap ? \"#define USE_METALNESSMAP\" : \"\", f.alphaMap ? \"#define USE_ALPHAMAP\" : \"\", f.vertexColors ? \"#define USE_COLOR\" : \"\", f.gradientMap ? \"#define USE_GRADIENTMAP\" : \"\", f.flatShading ? \"#define FLAT_SHADED\" : \"\", f.doubleSided ? \"#define DOUBLE_SIDED\" : \"\", f.flipSided ? \"#define FLIP_SIDED\" : \"\", \"#define NUM_CLIPPING_PLANES \" + f.numClippingPlanes, \"#define UNION_CLIPPING_PLANES \" + (f.numClippingPlanes - f.numClipIntersection), f.shadowMapEnabled ? \"#define USE_SHADOWMAP\" : \"\", f.shadowMapEnabled ? \"#define \" + k : \"\", f.premultipliedAlpha ? \"#define PREMULTIPLIED_ALPHA\" : \"\", f.physicallyCorrectLights ? \"#define PHYSICALLY_CORRECT_LIGHTS\" : \"\", f.logarithmicDepthBuffer ? \"#define USE_LOGDEPTHBUF\" : \"\", f.logarithmicDepthBuffer && b.get(\"EXT_frag_depth\") ? \"#define USE_LOGDEPTHBUF_EXT\" : \"\", f.envMap && b.get(\"EXT_shader_texture_lod\") ? \"#define TEXTURE_LOD_EXT\" : \"\", \"uniform mat4 viewMatrix;\", \"uniform vec3 cameraPosition;\", f.toneMapping !== qc ? \"#define TONE_MAPPING\" : \"\", f.toneMapping !== qc ? Mf.tonemapping_pars_fragment : \"\", f.toneMapping !== qc ? ab(\"toneMapping\", f.toneMapping) : \"\", f.dithering ? \"#define DITHERING\" : \"\", f.outputEncoding || f.mapEncoding || f.envMapEncoding || f.emissiveMapEncoding ? Mf.encodings_pars_fragment : \"\", f.mapEncoding ? $a(\"mapTexelToLinear\", f.mapEncoding) : \"\", f.envMapEncoding ? $a(\"envMapTexelToLinear\", f.envMapEncoding) : \"\", f.emissiveMapEncoding ? $a(\"emissiveMapTexelToLinear\", f.emissiveMapEncoding) : \"\", f.outputEncoding ? _a(\"linearToOutputTexel\", f.outputEncoding) : \"\", f.depthPacking ? \"#define DEPTH_PACKING \" + d.depthPacking : \"\", \"\\n\"].filter(eb).join(\"\\n\")), i = gb(i), i = fb(i, f), j = gb(j), j = fb(j, f), d.isShaderMaterial || (i = hb(i), j = hb(j));\n    var u = o + i,\n        v = p + j,\n        w = Ya(g, g.VERTEX_SHADER, u),\n        x = Ya(g, g.FRAGMENT_SHADER, v);\n    g.attachShader(t, w), g.attachShader(t, x), void 0 !== d.index0AttributeName ? g.bindAttribLocation(t, 0, d.index0AttributeName) : !0 === f.morphTargets && g.bindAttribLocation(t, 0, \"position\"), g.linkProgram(t);\n    var y = g.getProgramInfoLog(t),\n        z = g.getShaderInfoLog(w),\n        A = g.getShaderInfoLog(x),\n        B = !0,\n        C = !0;\n    !1 === g.getProgramParameter(t, g.LINK_STATUS) ? (B = !1, console.error(\"THREE.WebGLProgram: shader error: \", g.getError(), \"gl.VALIDATE_STATUS\", g.getProgramParameter(t, g.VALIDATE_STATUS), \"gl.getProgramInfoLog\", y, z, A)) : \"\" !== y ? console.warn(\"THREE.WebGLProgram: gl.getProgramInfoLog()\", y) : \"\" !== z && \"\" !== A || (C = !1), C && (this.diagnostics = {\n      runnable: B,\n      material: d,\n      programLog: y,\n      vertexShader: {\n        log: z,\n        prefix: o\n      },\n      fragmentShader: {\n        log: A,\n        prefix: p\n      }\n    }), g.deleteShader(w), g.deleteShader(x);\n    var D;\n\n    this.getUniforms = function () {\n      return void 0 === D && (D = new T(g, t, a)), D;\n    };\n\n    var E;\n    return this.getAttributes = function () {\n      return void 0 === E && (E = db(g, t)), E;\n    }, this.destroy = function () {\n      g.deleteProgram(t), this.program = void 0;\n    }, Object.defineProperties(this, {\n      uniforms: {\n        get: function get() {\n          return console.warn(\"THREE.WebGLProgram: .uniforms is now .getUniforms().\"), this.getUniforms();\n        }\n      },\n      attributes: {\n        get: function get() {\n          return console.warn(\"THREE.WebGLProgram: .attributes is now .getAttributes().\"), this.getAttributes();\n        }\n      }\n    }), this.id = Sf++, this.code = c, this.usedTimes = 1, this.program = t, this.vertexShader = w, this.fragmentShader = x, this;\n  }\n\n  function jb(a, b, c) {\n    function d(a) {\n      var b = a.skeleton,\n          d = b.bones;\n      if (c.floatVertexTextures) return 1024;\n      var e = c.maxVertexUniforms,\n          f = Math.floor((e - 20) / 4),\n          g = Math.min(f, d.length);\n      return g < d.length ? (console.warn(\"THREE.WebGLRenderer: Skeleton has \" + d.length + \" bones. This GPU supports \" + g + \".\"), 0) : g;\n    }\n\n    function e(a, b) {\n      var c;\n      return a ? a.isTexture ? c = a.encoding : a.isWebGLRenderTarget && (console.warn(\"THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.\"), c = a.texture.encoding) : c = pd, c === pd && b && (c = rd), c;\n    }\n\n    var f = [],\n        g = {\n      MeshDepthMaterial: \"depth\",\n      MeshDistanceMaterial: \"distanceRGBA\",\n      MeshNormalMaterial: \"normal\",\n      MeshBasicMaterial: \"basic\",\n      MeshLambertMaterial: \"lambert\",\n      MeshPhongMaterial: \"phong\",\n      MeshToonMaterial: \"phong\",\n      MeshStandardMaterial: \"physical\",\n      MeshPhysicalMaterial: \"physical\",\n      LineBasicMaterial: \"basic\",\n      LineDashedMaterial: \"dashed\",\n      PointsMaterial: \"points\",\n      ShadowMaterial: \"shadow\"\n    },\n        h = [\"precision\", \"supportsVertexTextures\", \"map\", \"mapEncoding\", \"envMap\", \"envMapMode\", \"envMapEncoding\", \"lightMap\", \"aoMap\", \"emissiveMap\", \"emissiveMapEncoding\", \"bumpMap\", \"normalMap\", \"displacementMap\", \"specularMap\", \"roughnessMap\", \"metalnessMap\", \"gradientMap\", \"alphaMap\", \"combine\", \"vertexColors\", \"fog\", \"useFog\", \"fogExp\", \"flatShading\", \"sizeAttenuation\", \"logarithmicDepthBuffer\", \"skinning\", \"maxBones\", \"useVertexTexture\", \"morphTargets\", \"morphNormals\", \"maxMorphTargets\", \"maxMorphNormals\", \"premultipliedAlpha\", \"numDirLights\", \"numPointLights\", \"numSpotLights\", \"numHemiLights\", \"numRectAreaLights\", \"shadowMapEnabled\", \"shadowMapType\", \"toneMapping\", \"physicallyCorrectLights\", \"alphaTest\", \"doubleSided\", \"flipSided\", \"numClippingPlanes\", \"numClipIntersection\", \"depthPacking\", \"dithering\"];\n    this.getParameters = function (b, f, h, i, j, k, l) {\n      var m = g[b.type],\n          n = l.isSkinnedMesh ? d(l) : 0,\n          o = c.precision;\n      null !== b.precision && (o = c.getMaxPrecision(b.precision)) !== b.precision && console.warn(\"THREE.WebGLProgram.getParameters:\", b.precision, \"not supported, using\", o, \"instead.\");\n      var p = a.getRenderTarget();\n      return {\n        shaderID: m,\n        precision: o,\n        supportsVertexTextures: c.vertexTextures,\n        outputEncoding: e(p ? p.texture : null, a.gammaOutput),\n        map: !!b.map,\n        mapEncoding: e(b.map, a.gammaInput),\n        envMap: !!b.envMap,\n        envMapMode: b.envMap && b.envMap.mapping,\n        envMapEncoding: e(b.envMap, a.gammaInput),\n        envMapCubeUV: !!b.envMap && (b.envMap.mapping === Bc || b.envMap.mapping === Cc),\n        lightMap: !!b.lightMap,\n        aoMap: !!b.aoMap,\n        emissiveMap: !!b.emissiveMap,\n        emissiveMapEncoding: e(b.emissiveMap, a.gammaInput),\n        bumpMap: !!b.bumpMap,\n        normalMap: !!b.normalMap,\n        displacementMap: !!b.displacementMap,\n        roughnessMap: !!b.roughnessMap,\n        metalnessMap: !!b.metalnessMap,\n        specularMap: !!b.specularMap,\n        alphaMap: !!b.alphaMap,\n        gradientMap: !!b.gradientMap,\n        combine: b.combine,\n        vertexColors: b.vertexColors,\n        fog: !!i,\n        useFog: b.fog,\n        fogExp: i && i.isFogExp2,\n        flatShading: b.flatShading,\n        sizeAttenuation: b.sizeAttenuation,\n        logarithmicDepthBuffer: c.logarithmicDepthBuffer,\n        skinning: b.skinning && n > 0,\n        maxBones: n,\n        useVertexTexture: c.floatVertexTextures,\n        morphTargets: b.morphTargets,\n        morphNormals: b.morphNormals,\n        maxMorphTargets: a.maxMorphTargets,\n        maxMorphNormals: a.maxMorphNormals,\n        numDirLights: f.directional.length,\n        numPointLights: f.point.length,\n        numSpotLights: f.spot.length,\n        numRectAreaLights: f.rectArea.length,\n        numHemiLights: f.hemi.length,\n        numClippingPlanes: j,\n        numClipIntersection: k,\n        dithering: b.dithering,\n        shadowMapEnabled: a.shadowMap.enabled && l.receiveShadow && h.length > 0,\n        shadowMapType: a.shadowMap.type,\n        toneMapping: a.toneMapping,\n        physicallyCorrectLights: a.physicallyCorrectLights,\n        premultipliedAlpha: b.premultipliedAlpha,\n        alphaTest: b.alphaTest,\n        doubleSided: b.side === Ib,\n        flipSided: b.side === Hb,\n        depthPacking: void 0 !== b.depthPacking && b.depthPacking\n      };\n    }, this.getProgramCode = function (b, c) {\n      var d = [];\n      if (c.shaderID ? d.push(c.shaderID) : (d.push(b.fragmentShader), d.push(b.vertexShader)), void 0 !== b.defines) for (var e in b.defines) {\n        d.push(e), d.push(b.defines[e]);\n      }\n\n      for (var f = 0; f < h.length; f++) {\n        d.push(c[h[f]]);\n      }\n\n      return d.push(b.onBeforeCompile.toString()), d.push(a.gammaOutput), d.join();\n    }, this.acquireProgram = function (c, d, e, g) {\n      for (var h, i = 0, j = f.length; i < j; i++) {\n        var k = f[i];\n\n        if (k.code === g) {\n          h = k, ++h.usedTimes;\n          break;\n        }\n      }\n\n      return void 0 === h && (h = new ib(a, b, g, c, d, e), f.push(h)), h;\n    }, this.releaseProgram = function (a) {\n      if (0 == --a.usedTimes) {\n        var b = f.indexOf(a);\n        f[b] = f[f.length - 1], f.pop(), a.destroy();\n      }\n    }, this.programs = f;\n  }\n\n  function kb(a, b, c, d, e, f, g) {\n    function h(a, b) {\n      if (a.width > b || a.height > b) {\n        var c = b / Math.max(a.width, a.height),\n            d = document.createElementNS(\"http://www.w3.org/1999/xhtml\", \"canvas\");\n        d.width = Math.floor(a.width * c), d.height = Math.floor(a.height * c);\n        return d.getContext(\"2d\").drawImage(a, 0, 0, a.width, a.height, 0, 0, d.width, d.height), console.warn(\"THREE.WebGLRenderer: image is too big (\" + a.width + \"x\" + a.height + \"). Resized to \" + d.width + \"x\" + d.height, a), d;\n      }\n\n      return a;\n    }\n\n    function i(a) {\n      return yd.isPowerOfTwo(a.width) && yd.isPowerOfTwo(a.height);\n    }\n\n    function j(a) {\n      if (a instanceof HTMLImageElement || a instanceof HTMLCanvasElement || a instanceof ImageBitmap) {\n        var b = document.createElementNS(\"http://www.w3.org/1999/xhtml\", \"canvas\");\n        b.width = yd.floorPowerOfTwo(a.width), b.height = yd.floorPowerOfTwo(a.height);\n        return b.getContext(\"2d\").drawImage(a, 0, 0, b.width, b.height), console.warn(\"THREE.WebGLRenderer: image is not power of two (\" + a.width + \"x\" + a.height + \"). Resized to \" + b.width + \"x\" + b.height, a), b;\n      }\n\n      return a;\n    }\n\n    function k(a) {\n      return a.wrapS !== Ec || a.wrapT !== Ec || a.minFilter !== Gc && a.minFilter !== Jc;\n    }\n\n    function l(a, b) {\n      return a.generateMipmaps && b && a.minFilter !== Gc && a.minFilter !== Jc;\n    }\n\n    function m(b) {\n      return b === Gc || b === Hc || b === Ic ? a.NEAREST : a.LINEAR;\n    }\n\n    function n(a) {\n      var b = a.target;\n      b.removeEventListener(\"dispose\", n), p(b), b.isVideoTexture && delete E[b.id], g.textures--;\n    }\n\n    function o(a) {\n      var b = a.target;\n      b.removeEventListener(\"dispose\", o), q(b), g.textures--;\n    }\n\n    function p(b) {\n      var c = d.get(b);\n      if (b.image && c.__image__webglTextureCube) a.deleteTexture(c.__image__webglTextureCube);else {\n        if (void 0 === c.__webglInit) return;\n        a.deleteTexture(c.__webglTexture);\n      }\n      d.remove(b);\n    }\n\n    function q(b) {\n      var c = d.get(b),\n          e = d.get(b.texture);\n\n      if (b) {\n        if (void 0 !== e.__webglTexture && a.deleteTexture(e.__webglTexture), b.depthTexture && b.depthTexture.dispose(), b.isWebGLRenderTargetCube) for (var f = 0; f < 6; f++) {\n          a.deleteFramebuffer(c.__webglFramebuffer[f]), c.__webglDepthbuffer && a.deleteRenderbuffer(c.__webglDepthbuffer[f]);\n        } else a.deleteFramebuffer(c.__webglFramebuffer), c.__webglDepthbuffer && a.deleteRenderbuffer(c.__webglDepthbuffer);\n        d.remove(b.texture), d.remove(b);\n      }\n    }\n\n    function r(b, e) {\n      var f = d.get(b);\n\n      if (b.version > 0 && f.__version !== b.version) {\n        var g = b.image;\n        if (void 0 === g) console.warn(\"THREE.WebGLRenderer: Texture marked for update but image is undefined\", b);else {\n          if (!1 !== g.complete) return void v(f, b, e);\n          console.warn(\"THREE.WebGLRenderer: Texture marked for update but image is incomplete\", b);\n        }\n      }\n\n      c.activeTexture(a.TEXTURE0 + e), c.bindTexture(a.TEXTURE_2D, f.__webglTexture);\n    }\n\n    function s(b, j) {\n      var k = d.get(b);\n      if (6 === b.image.length) if (b.version > 0 && k.__version !== b.version) {\n        k.__image__webglTextureCube || (b.addEventListener(\"dispose\", n), k.__image__webglTextureCube = a.createTexture(), g.textures++), c.activeTexture(a.TEXTURE0 + j), c.bindTexture(a.TEXTURE_CUBE_MAP, k.__image__webglTextureCube), a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL, b.flipY);\n\n        for (var m = b && b.isCompressedTexture, o = b.image[0] && b.image[0].isDataTexture, p = [], q = 0; q < 6; q++) {\n          p[q] = m || o ? o ? b.image[q].image : b.image[q] : h(b.image[q], e.maxCubemapSize);\n        }\n\n        var r = p[0],\n            s = i(r),\n            t = f.convert(b.format),\n            v = f.convert(b.type);\n        u(a.TEXTURE_CUBE_MAP, b, s);\n\n        for (var q = 0; q < 6; q++) {\n          if (m) for (var w, x = p[q].mipmaps, y = 0, z = x.length; y < z; y++) {\n            w = x[y], b.format !== $c && b.format !== Zc ? c.getCompressedTextureFormats().indexOf(t) > -1 ? c.compressedTexImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + q, y, t, w.width, w.height, 0, w.data) : console.warn(\"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()\") : c.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + q, y, t, w.width, w.height, 0, t, v, w.data);\n          } else o ? c.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + q, 0, t, p[q].width, p[q].height, 0, t, v, p[q].data) : c.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + q, 0, t, t, v, p[q]);\n        }\n\n        l(b, s) && a.generateMipmap(a.TEXTURE_CUBE_MAP), k.__version = b.version, b.onUpdate && b.onUpdate(b);\n      } else c.activeTexture(a.TEXTURE0 + j), c.bindTexture(a.TEXTURE_CUBE_MAP, k.__image__webglTextureCube);\n    }\n\n    function t(b, e) {\n      c.activeTexture(a.TEXTURE0 + e), c.bindTexture(a.TEXTURE_CUBE_MAP, d.get(b).__webglTexture);\n    }\n\n    function u(c, g, h) {\n      var i;\n\n      if (h ? (a.texParameteri(c, a.TEXTURE_WRAP_S, f.convert(g.wrapS)), a.texParameteri(c, a.TEXTURE_WRAP_T, f.convert(g.wrapT)), a.texParameteri(c, a.TEXTURE_MAG_FILTER, f.convert(g.magFilter)), a.texParameteri(c, a.TEXTURE_MIN_FILTER, f.convert(g.minFilter))) : (a.texParameteri(c, a.TEXTURE_WRAP_S, a.CLAMP_TO_EDGE), a.texParameteri(c, a.TEXTURE_WRAP_T, a.CLAMP_TO_EDGE), g.wrapS === Ec && g.wrapT === Ec || console.warn(\"THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.\", g), a.texParameteri(c, a.TEXTURE_MAG_FILTER, m(g.magFilter)), a.texParameteri(c, a.TEXTURE_MIN_FILTER, m(g.minFilter)), g.minFilter !== Gc && g.minFilter !== Jc && console.warn(\"THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.\", g)), i = b.get(\"EXT_texture_filter_anisotropic\")) {\n        if (g.type === Sc && null === b.get(\"OES_texture_float_linear\")) return;\n        if (g.type === Tc && null === b.get(\"OES_texture_half_float_linear\")) return;\n        (g.anisotropy > 1 || d.get(g).__currentAnisotropy) && (a.texParameterf(c, i.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(g.anisotropy, e.getMaxAnisotropy())), d.get(g).__currentAnisotropy = g.anisotropy);\n      }\n    }\n\n    function v(b, d, m) {\n      void 0 === b.__webglInit && (b.__webglInit = !0, d.addEventListener(\"dispose\", n), b.__webglTexture = a.createTexture(), d.isVideoTexture && (E[d.id] = d), g.textures++), c.activeTexture(a.TEXTURE0 + m), c.bindTexture(a.TEXTURE_2D, b.__webglTexture), a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL, d.flipY), a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL, d.premultiplyAlpha), a.pixelStorei(a.UNPACK_ALIGNMENT, d.unpackAlignment);\n      var o = h(d.image, e.maxTextureSize);\n      k(d) && !1 === i(o) && (o = j(o));\n      var p = i(o),\n          q = f.convert(d.format),\n          r = f.convert(d.type);\n      u(a.TEXTURE_2D, d, p);\n      var s,\n          t = d.mipmaps;\n\n      if (d.isDepthTexture) {\n        var v = a.DEPTH_COMPONENT;\n\n        if (d.type === Sc) {\n          if (!D) throw new Error(\"Float Depth Texture only supported in WebGL2.0\");\n          v = a.DEPTH_COMPONENT32F;\n        } else D && (v = a.DEPTH_COMPONENT16);\n\n        d.format === bd && v === a.DEPTH_COMPONENT && d.type !== Pc && d.type !== Rc && (console.warn(\"THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.\"), d.type = Pc, r = f.convert(d.type)), d.format === cd && (v = a.DEPTH_STENCIL, d.type !== Xc && (console.warn(\"THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.\"), d.type = Xc, r = f.convert(d.type))), c.texImage2D(a.TEXTURE_2D, 0, v, o.width, o.height, 0, q, r, null);\n      } else if (d.isDataTexture) {\n        if (t.length > 0 && p) {\n          for (var w = 0, x = t.length; w < x; w++) {\n            s = t[w], c.texImage2D(a.TEXTURE_2D, w, q, s.width, s.height, 0, q, r, s.data);\n          }\n\n          d.generateMipmaps = !1;\n        } else c.texImage2D(a.TEXTURE_2D, 0, q, o.width, o.height, 0, q, r, o.data);\n      } else if (d.isCompressedTexture) for (var w = 0, x = t.length; w < x; w++) {\n        s = t[w], d.format !== $c && d.format !== Zc ? c.getCompressedTextureFormats().indexOf(q) > -1 ? c.compressedTexImage2D(a.TEXTURE_2D, w, q, s.width, s.height, 0, s.data) : console.warn(\"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()\") : c.texImage2D(a.TEXTURE_2D, w, q, s.width, s.height, 0, q, r, s.data);\n      } else if (t.length > 0 && p) {\n        for (var w = 0, x = t.length; w < x; w++) {\n          s = t[w], c.texImage2D(a.TEXTURE_2D, w, q, q, r, s);\n        }\n\n        d.generateMipmaps = !1;\n      } else c.texImage2D(a.TEXTURE_2D, 0, q, q, r, o);\n\n      l(d, p) && a.generateMipmap(a.TEXTURE_2D), b.__version = d.version, d.onUpdate && d.onUpdate(d);\n    }\n\n    function w(b, e, g, h) {\n      var i = f.convert(e.texture.format),\n          j = f.convert(e.texture.type);\n      c.texImage2D(h, 0, i, e.width, e.height, 0, i, j, null), a.bindFramebuffer(a.FRAMEBUFFER, b), a.framebufferTexture2D(a.FRAMEBUFFER, g, h, d.get(e.texture).__webglTexture, 0), a.bindFramebuffer(a.FRAMEBUFFER, null);\n    }\n\n    function x(b, c) {\n      a.bindRenderbuffer(a.RENDERBUFFER, b), c.depthBuffer && !c.stencilBuffer ? (a.renderbufferStorage(a.RENDERBUFFER, a.DEPTH_COMPONENT16, c.width, c.height), a.framebufferRenderbuffer(a.FRAMEBUFFER, a.DEPTH_ATTACHMENT, a.RENDERBUFFER, b)) : c.depthBuffer && c.stencilBuffer ? (a.renderbufferStorage(a.RENDERBUFFER, a.DEPTH_STENCIL, c.width, c.height), a.framebufferRenderbuffer(a.FRAMEBUFFER, a.DEPTH_STENCIL_ATTACHMENT, a.RENDERBUFFER, b)) : a.renderbufferStorage(a.RENDERBUFFER, a.RGBA4, c.width, c.height), a.bindRenderbuffer(a.RENDERBUFFER, null);\n    }\n\n    function y(b, c) {\n      if (c && c.isWebGLRenderTargetCube) throw new Error(\"Depth Texture with cube render targets is not supported\");\n      if (a.bindFramebuffer(a.FRAMEBUFFER, b), !c.depthTexture || !c.depthTexture.isDepthTexture) throw new Error(\"renderTarget.depthTexture must be an instance of THREE.DepthTexture\");\n      d.get(c.depthTexture).__webglTexture && c.depthTexture.image.width === c.width && c.depthTexture.image.height === c.height || (c.depthTexture.image.width = c.width, c.depthTexture.image.height = c.height, c.depthTexture.needsUpdate = !0), r(c.depthTexture, 0);\n\n      var e = d.get(c.depthTexture).__webglTexture;\n\n      if (c.depthTexture.format === bd) a.framebufferTexture2D(a.FRAMEBUFFER, a.DEPTH_ATTACHMENT, a.TEXTURE_2D, e, 0);else {\n        if (c.depthTexture.format !== cd) throw new Error(\"Unknown depthTexture format\");\n        a.framebufferTexture2D(a.FRAMEBUFFER, a.DEPTH_STENCIL_ATTACHMENT, a.TEXTURE_2D, e, 0);\n      }\n    }\n\n    function z(b) {\n      var c = d.get(b),\n          e = !0 === b.isWebGLRenderTargetCube;\n\n      if (b.depthTexture) {\n        if (e) throw new Error(\"target.depthTexture not supported in Cube render targets\");\n        y(c.__webglFramebuffer, b);\n      } else if (e) {\n        c.__webglDepthbuffer = [];\n\n        for (var f = 0; f < 6; f++) {\n          a.bindFramebuffer(a.FRAMEBUFFER, c.__webglFramebuffer[f]), c.__webglDepthbuffer[f] = a.createRenderbuffer(), x(c.__webglDepthbuffer[f], b);\n        }\n      } else a.bindFramebuffer(a.FRAMEBUFFER, c.__webglFramebuffer), c.__webglDepthbuffer = a.createRenderbuffer(), x(c.__webglDepthbuffer, b);\n\n      a.bindFramebuffer(a.FRAMEBUFFER, null);\n    }\n\n    function A(b) {\n      var e = d.get(b),\n          f = d.get(b.texture);\n      b.addEventListener(\"dispose\", o), f.__webglTexture = a.createTexture(), g.textures++;\n      var h = !0 === b.isWebGLRenderTargetCube,\n          j = i(b);\n\n      if (h) {\n        e.__webglFramebuffer = [];\n\n        for (var k = 0; k < 6; k++) {\n          e.__webglFramebuffer[k] = a.createFramebuffer();\n        }\n      } else e.__webglFramebuffer = a.createFramebuffer();\n\n      if (h) {\n        c.bindTexture(a.TEXTURE_CUBE_MAP, f.__webglTexture), u(a.TEXTURE_CUBE_MAP, b.texture, j);\n\n        for (var k = 0; k < 6; k++) {\n          w(e.__webglFramebuffer[k], b, a.COLOR_ATTACHMENT0, a.TEXTURE_CUBE_MAP_POSITIVE_X + k);\n        }\n\n        l(b.texture, j) && a.generateMipmap(a.TEXTURE_CUBE_MAP), c.bindTexture(a.TEXTURE_CUBE_MAP, null);\n      } else c.bindTexture(a.TEXTURE_2D, f.__webglTexture), u(a.TEXTURE_2D, b.texture, j), w(e.__webglFramebuffer, b, a.COLOR_ATTACHMENT0, a.TEXTURE_2D), l(b.texture, j) && a.generateMipmap(a.TEXTURE_2D), c.bindTexture(a.TEXTURE_2D, null);\n\n      b.depthBuffer && z(b);\n    }\n\n    function B(b) {\n      var e = b.texture;\n\n      if (l(e, i(b))) {\n        var f = b.isWebGLRenderTargetCube ? a.TEXTURE_CUBE_MAP : a.TEXTURE_2D,\n            g = d.get(e).__webglTexture;\n\n        c.bindTexture(f, g), a.generateMipmap(f), c.bindTexture(f, null);\n      }\n    }\n\n    function C() {\n      for (var a in E) {\n        E[a].update();\n      }\n    }\n\n    var D = \"undefined\" != typeof WebGL2RenderingContext && a instanceof window.WebGL2RenderingContext,\n        E = {};\n    this.setTexture2D = r, this.setTextureCube = s, this.setTextureCubeDynamic = t, this.setupRenderTarget = A, this.updateRenderTargetMipmap = B, this.updateVideoTextures = C;\n  }\n\n  function lb() {\n    function a(a) {\n      var b = a.uuid,\n          c = d[b];\n      return void 0 === c && (c = {}, d[b] = c), c;\n    }\n\n    function b(a) {\n      delete d[a.uuid];\n    }\n\n    function c() {\n      d = {};\n    }\n\n    var d = {};\n    return {\n      get: a,\n      remove: b,\n      clear: c\n    };\n  }\n\n  function mb(a, b, c) {\n    function d() {\n      var b = !1,\n          c = new i(),\n          d = null,\n          e = new i(0, 0, 0, 0);\n      return {\n        setMask: function setMask(c) {\n          d === c || b || (a.colorMask(c, c, c, c), d = c);\n        },\n        setLocked: function setLocked(a) {\n          b = a;\n        },\n        setClear: function setClear(b, d, f, g, h) {\n          !0 === h && (b *= g, d *= g, f *= g), c.set(b, d, f, g), !1 === e.equals(c) && (a.clearColor(b, d, f, g), e.copy(c));\n        },\n        reset: function reset() {\n          b = !1, d = null, e.set(-1, 0, 0, 0);\n        }\n      };\n    }\n\n    function e() {\n      var b = !1,\n          c = null,\n          d = null,\n          e = null;\n      return {\n        setTest: function setTest(b) {\n          b ? m(a.DEPTH_TEST) : n(a.DEPTH_TEST);\n        },\n        setMask: function setMask(d) {\n          c === d || b || (a.depthMask(d), c = d);\n        },\n        setFunc: function setFunc(b) {\n          if (d !== b) {\n            if (b) switch (b) {\n              case fc:\n                a.depthFunc(a.NEVER);\n                break;\n\n              case gc:\n                a.depthFunc(a.ALWAYS);\n                break;\n\n              case hc:\n                a.depthFunc(a.LESS);\n                break;\n\n              case ic:\n                a.depthFunc(a.LEQUAL);\n                break;\n\n              case jc:\n                a.depthFunc(a.EQUAL);\n                break;\n\n              case kc:\n                a.depthFunc(a.GEQUAL);\n                break;\n\n              case lc:\n                a.depthFunc(a.GREATER);\n                break;\n\n              case mc:\n                a.depthFunc(a.NOTEQUAL);\n                break;\n\n              default:\n                a.depthFunc(a.LEQUAL);\n            } else a.depthFunc(a.LEQUAL);\n            d = b;\n          }\n        },\n        setLocked: function setLocked(a) {\n          b = a;\n        },\n        setClear: function setClear(b) {\n          e !== b && (a.clearDepth(b), e = b);\n        },\n        reset: function reset() {\n          b = !1, c = null, d = null, e = null;\n        }\n      };\n    }\n\n    function f() {\n      var b = !1,\n          c = null,\n          d = null,\n          e = null,\n          f = null,\n          g = null,\n          h = null,\n          i = null,\n          j = null;\n      return {\n        setTest: function setTest(b) {\n          b ? m(a.STENCIL_TEST) : n(a.STENCIL_TEST);\n        },\n        setMask: function setMask(d) {\n          c === d || b || (a.stencilMask(d), c = d);\n        },\n        setFunc: function setFunc(b, c, g) {\n          d === b && e === c && f === g || (a.stencilFunc(b, c, g), d = b, e = c, f = g);\n        },\n        setOp: function setOp(b, c, d) {\n          g === b && h === c && i === d || (a.stencilOp(b, c, d), g = b, h = c, i = d);\n        },\n        setLocked: function setLocked(a) {\n          b = a;\n        },\n        setClear: function setClear(b) {\n          j !== b && (a.clearStencil(b), j = b);\n        },\n        reset: function reset() {\n          b = !1, c = null, d = null, e = null, f = null, g = null, h = null, i = null, j = null;\n        }\n      };\n    }\n\n    function g(b, c, d) {\n      var e = new Uint8Array(4),\n          f = a.createTexture();\n      a.bindTexture(b, f), a.texParameteri(b, a.TEXTURE_MIN_FILTER, a.NEAREST), a.texParameteri(b, a.TEXTURE_MAG_FILTER, a.NEAREST);\n\n      for (var g = 0; g < d; g++) {\n        a.texImage2D(c + g, 0, a.RGBA, 1, 1, 0, a.RGBA, a.UNSIGNED_BYTE, e);\n      }\n\n      return f;\n    }\n\n    function h() {\n      for (var a = 0, b = I.length; a < b; a++) {\n        I[a] = 0;\n      }\n    }\n\n    function j(c) {\n      if (I[c] = 1, 0 === J[c] && (a.enableVertexAttribArray(c), J[c] = 1), 0 !== K[c]) {\n        b.get(\"ANGLE_instanced_arrays\").vertexAttribDivisorANGLE(c, 0), K[c] = 0;\n      }\n    }\n\n    function k(c, d) {\n      if (I[c] = 1, 0 === J[c] && (a.enableVertexAttribArray(c), J[c] = 1), K[c] !== d) {\n        b.get(\"ANGLE_instanced_arrays\").vertexAttribDivisorANGLE(c, d), K[c] = d;\n      }\n    }\n\n    function l() {\n      for (var b = 0, c = J.length; b !== c; ++b) {\n        J[b] !== I[b] && (a.disableVertexAttribArray(b), J[b] = 0);\n      }\n    }\n\n    function m(b) {\n      !0 !== L[b] && (a.enable(b), L[b] = !0);\n    }\n\n    function n(b) {\n      !1 !== L[b] && (a.disable(b), L[b] = !1);\n    }\n\n    function o() {\n      if (null === M && (M = [], b.get(\"WEBGL_compressed_texture_pvrtc\") || b.get(\"WEBGL_compressed_texture_s3tc\") || b.get(\"WEBGL_compressed_texture_etc1\"))) for (var c = a.getParameter(a.COMPRESSED_TEXTURE_FORMATS), d = 0; d < c.length; d++) {\n        M.push(c[d]);\n      }\n      return M;\n    }\n\n    function p(b) {\n      return N !== b && (a.useProgram(b), N = b, !0);\n    }\n\n    function q(b, d, e, f, g, h, i, j) {\n      if (b !== Lb ? m(a.BLEND) : n(a.BLEND), b !== Qb) {\n        if (b !== O || j !== V) switch (b) {\n          case Nb:\n            j ? (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), a.blendFuncSeparate(a.ONE, a.ONE, a.ONE, a.ONE)) : (a.blendEquation(a.FUNC_ADD), a.blendFunc(a.SRC_ALPHA, a.ONE));\n            break;\n\n          case Ob:\n            j ? (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), a.blendFuncSeparate(a.ZERO, a.ZERO, a.ONE_MINUS_SRC_COLOR, a.ONE_MINUS_SRC_ALPHA)) : (a.blendEquation(a.FUNC_ADD), a.blendFunc(a.ZERO, a.ONE_MINUS_SRC_COLOR));\n            break;\n\n          case Pb:\n            j ? (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), a.blendFuncSeparate(a.ZERO, a.SRC_COLOR, a.ZERO, a.SRC_ALPHA)) : (a.blendEquation(a.FUNC_ADD), a.blendFunc(a.ZERO, a.SRC_COLOR));\n            break;\n\n          default:\n            j ? (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), a.blendFuncSeparate(a.ONE, a.ONE_MINUS_SRC_ALPHA, a.ONE, a.ONE_MINUS_SRC_ALPHA)) : (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), a.blendFuncSeparate(a.SRC_ALPHA, a.ONE_MINUS_SRC_ALPHA, a.ONE, a.ONE_MINUS_SRC_ALPHA));\n        }\n        P = null, Q = null, R = null, S = null, T = null, U = null;\n      } else g = g || d, h = h || e, i = i || f, d === P && g === S || (a.blendEquationSeparate(c.convert(d), c.convert(g)), P = d, S = g), e === Q && f === R && h === T && i === U || (a.blendFuncSeparate(c.convert(e), c.convert(f), c.convert(h), c.convert(i)), Q = e, R = f, T = h, U = i);\n\n      O = b, V = j;\n    }\n\n    function r(b, c) {\n      b.side === Ib ? n(a.CULL_FACE) : m(a.CULL_FACE);\n      var d = b.side === Hb;\n      c && (d = !d), s(d), !0 === b.transparent ? q(b.blending, b.blendEquation, b.blendSrc, b.blendDst, b.blendEquationAlpha, b.blendSrcAlpha, b.blendDstAlpha, b.premultipliedAlpha) : q(Lb), F.setFunc(b.depthFunc), F.setTest(b.depthTest), F.setMask(b.depthWrite), E.setMask(b.colorWrite), v(b.polygonOffset, b.polygonOffsetFactor, b.polygonOffsetUnits);\n    }\n\n    function s(b) {\n      W !== b && (b ? a.frontFace(a.CW) : a.frontFace(a.CCW), W = b);\n    }\n\n    function t(b) {\n      b !== Ab ? (m(a.CULL_FACE), b !== X && (b === Bb ? a.cullFace(a.BACK) : b === Cb ? a.cullFace(a.FRONT) : a.cullFace(a.FRONT_AND_BACK))) : n(a.CULL_FACE), X = b;\n    }\n\n    function u(b) {\n      b !== Y && (ba && a.lineWidth(b), Y = b);\n    }\n\n    function v(b, c, d) {\n      b ? (m(a.POLYGON_OFFSET_FILL), Z === c && $ === d || (a.polygonOffset(c, d), Z = c, $ = d)) : n(a.POLYGON_OFFSET_FILL);\n    }\n\n    function w(b) {\n      b ? m(a.SCISSOR_TEST) : n(a.SCISSOR_TEST);\n    }\n\n    function x(b) {\n      void 0 === b && (b = a.TEXTURE0 + _ - 1), ca !== b && (a.activeTexture(b), ca = b);\n    }\n\n    function y(b, c) {\n      null === ca && x();\n      var d = da[ca];\n      void 0 === d && (d = {\n        type: void 0,\n        texture: void 0\n      }, da[ca] = d), d.type === b && d.texture === c || (a.bindTexture(b, c || ga[b]), d.type = b, d.texture = c);\n    }\n\n    function z() {\n      try {\n        a.compressedTexImage2D.apply(a, arguments);\n      } catch (a) {\n        console.error(\"THREE.WebGLState:\", a);\n      }\n    }\n\n    function A() {\n      try {\n        a.texImage2D.apply(a, arguments);\n      } catch (a) {\n        console.error(\"THREE.WebGLState:\", a);\n      }\n    }\n\n    function B(b) {\n      !1 === ea.equals(b) && (a.scissor(b.x, b.y, b.z, b.w), ea.copy(b));\n    }\n\n    function C(b) {\n      !1 === fa.equals(b) && (a.viewport(b.x, b.y, b.z, b.w), fa.copy(b));\n    }\n\n    function D() {\n      for (var b = 0; b < J.length; b++) {\n        1 === J[b] && (a.disableVertexAttribArray(b), J[b] = 0);\n      }\n\n      L = {}, M = null, ca = null, da = {}, N = null, O = null, W = null, X = null, E.reset(), F.reset(), G.reset();\n    }\n\n    var E = new d(),\n        F = new e(),\n        G = new f(),\n        H = a.getParameter(a.MAX_VERTEX_ATTRIBS),\n        I = new Uint8Array(H),\n        J = new Uint8Array(H),\n        K = new Uint8Array(H),\n        L = {},\n        M = null,\n        N = null,\n        O = null,\n        P = null,\n        Q = null,\n        R = null,\n        S = null,\n        T = null,\n        U = null,\n        V = !1,\n        W = null,\n        X = null,\n        Y = null,\n        Z = null,\n        $ = null,\n        _ = a.getParameter(a.MAX_COMBINED_TEXTURE_IMAGE_UNITS),\n        aa = parseFloat(/^WebGL\\ ([0-9])/.exec(a.getParameter(a.VERSION))[1]),\n        ba = parseFloat(aa) >= 1,\n        ca = null,\n        da = {},\n        ea = new i(),\n        fa = new i(),\n        ga = {};\n\n    return ga[a.TEXTURE_2D] = g(a.TEXTURE_2D, a.TEXTURE_2D, 1), ga[a.TEXTURE_CUBE_MAP] = g(a.TEXTURE_CUBE_MAP, a.TEXTURE_CUBE_MAP_POSITIVE_X, 6), E.setClear(0, 0, 0, 1), F.setClear(1), G.setClear(0), m(a.DEPTH_TEST), F.setFunc(ic), s(!1), t(Bb), m(a.CULL_FACE), m(a.BLEND), q(Mb), {\n      buffers: {\n        color: E,\n        depth: F,\n        stencil: G\n      },\n      initAttributes: h,\n      enableAttribute: j,\n      enableAttributeAndDivisor: k,\n      disableUnusedAttributes: l,\n      enable: m,\n      disable: n,\n      getCompressedTextureFormats: o,\n      useProgram: p,\n      setBlending: q,\n      setMaterial: r,\n      setFlipSided: s,\n      setCullFace: t,\n      setLineWidth: u,\n      setPolygonOffset: v,\n      setScissorTest: w,\n      activeTexture: x,\n      bindTexture: y,\n      compressedTexImage2D: z,\n      texImage2D: A,\n      scissor: B,\n      viewport: C,\n      reset: D\n    };\n  }\n\n  function nb(a, b, c) {\n    function d() {\n      if (void 0 !== f) return f;\n      var c = b.get(\"EXT_texture_filter_anisotropic\");\n      return f = null !== c ? a.getParameter(c.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;\n    }\n\n    function e(b) {\n      if (\"highp\" === b) {\n        if (a.getShaderPrecisionFormat(a.VERTEX_SHADER, a.HIGH_FLOAT).precision > 0 && a.getShaderPrecisionFormat(a.FRAGMENT_SHADER, a.HIGH_FLOAT).precision > 0) return \"highp\";\n        b = \"mediump\";\n      }\n\n      return \"mediump\" === b && a.getShaderPrecisionFormat(a.VERTEX_SHADER, a.MEDIUM_FLOAT).precision > 0 && a.getShaderPrecisionFormat(a.FRAGMENT_SHADER, a.MEDIUM_FLOAT).precision > 0 ? \"mediump\" : \"lowp\";\n    }\n\n    var f,\n        g = void 0 !== c.precision ? c.precision : \"highp\",\n        h = e(g);\n    h !== g && (console.warn(\"THREE.WebGLRenderer:\", g, \"not supported, using\", h, \"instead.\"), g = h);\n    var i = !0 === c.logarithmicDepthBuffer,\n        j = a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS),\n        k = a.getParameter(a.MAX_VERTEX_TEXTURE_IMAGE_UNITS),\n        l = a.getParameter(a.MAX_TEXTURE_SIZE),\n        m = a.getParameter(a.MAX_CUBE_MAP_TEXTURE_SIZE),\n        n = a.getParameter(a.MAX_VERTEX_ATTRIBS),\n        o = a.getParameter(a.MAX_VERTEX_UNIFORM_VECTORS),\n        p = a.getParameter(a.MAX_VARYING_VECTORS),\n        q = a.getParameter(a.MAX_FRAGMENT_UNIFORM_VECTORS),\n        r = k > 0,\n        s = !!b.get(\"OES_texture_float\");\n    return {\n      getMaxAnisotropy: d,\n      getMaxPrecision: e,\n      precision: g,\n      logarithmicDepthBuffer: i,\n      maxTextures: j,\n      maxVertexTextures: k,\n      maxTextureSize: l,\n      maxCubemapSize: m,\n      maxAttributes: n,\n      maxVertexUniforms: o,\n      maxVaryings: p,\n      maxFragmentUniforms: q,\n      vertexTextures: r,\n      floatFragmentTextures: s,\n      floatVertexTextures: r && s\n    };\n  }\n\n  function ob(a, b, c, d) {\n    ja.call(this), this.type = \"PerspectiveCamera\", this.fov = void 0 !== a ? a : 50, this.zoom = 1, this.near = void 0 !== c ? c : .1, this.far = void 0 !== d ? d : 2e3, this.focus = 10, this.aspect = void 0 !== b ? b : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();\n  }\n\n  function pb(a) {\n    ob.call(this), this.cameras = a || [];\n  }\n\n  function qb(a) {\n    function b() {\n      if (null !== e && e.isPresenting) {\n        var b = e.getEyeParameters(\"left\"),\n            d = b.renderWidth,\n            f = b.renderHeight;\n        n = a.getPixelRatio(), m = a.getSize(), a.setDrawingBufferSize(2 * d, f, 1);\n      } else c.enabled && a.setDrawingBufferSize(m.width, m.height, n);\n    }\n\n    var c = this,\n        e = null,\n        f = null,\n        g = null;\n    \"undefined\" != typeof window && \"VRFrameData\" in window && (f = new window.VRFrameData());\n    var h = new d(),\n        j = new ob();\n    j.bounds = new i(0, 0, .5, 1), j.layers.enable(1);\n    var k = new ob();\n    k.bounds = new i(.5, 0, .5, 1), k.layers.enable(2);\n    var l = new pb([j, k]);\n    l.layers.enable(1), l.layers.enable(2);\n    var m, n;\n    \"undefined\" != typeof window && window.addEventListener(\"vrdisplaypresentchange\", b, !1), this.enabled = !1, this.getDevice = function () {\n      return e;\n    }, this.setDevice = function (a) {\n      void 0 !== a && (e = a);\n    }, this.setPoseTarget = function (a) {\n      void 0 !== a && (g = a);\n    }, this.getCamera = function (a) {\n      if (null === e) return a;\n      e.depthNear = a.near, e.depthFar = a.far, e.getFrameData(f);\n      var b = f.pose,\n          c = null !== g ? g : a;\n      if (null !== b.position ? c.position.fromArray(b.position) : c.position.set(0, 0, 0), null !== b.orientation && c.quaternion.fromArray(b.orientation), c.updateMatrixWorld(), !1 === e.isPresenting) return a;\n      j.near = a.near, k.near = a.near, j.far = a.far, k.far = a.far, l.matrixWorld.copy(a.matrixWorld), l.matrixWorldInverse.copy(a.matrixWorldInverse), j.matrixWorldInverse.fromArray(f.leftViewMatrix), k.matrixWorldInverse.fromArray(f.rightViewMatrix);\n      var d = c.parent;\n      null !== d && (h.getInverse(d.matrixWorld), j.matrixWorldInverse.multiply(h), k.matrixWorldInverse.multiply(h)), j.matrixWorld.getInverse(j.matrixWorldInverse), k.matrixWorld.getInverse(k.matrixWorldInverse), j.projectionMatrix.fromArray(f.leftProjectionMatrix), k.projectionMatrix.fromArray(f.rightProjectionMatrix), l.projectionMatrix.copy(j.projectionMatrix);\n      var i = e.getLayers();\n\n      if (i.length) {\n        var m = i[0];\n        null !== m.leftBounds && 4 === m.leftBounds.length && j.bounds.fromArray(m.leftBounds), null !== m.rightBounds && 4 === m.rightBounds.length && k.bounds.fromArray(m.rightBounds);\n      }\n\n      return l;\n    }, this.submitFrame = function () {\n      e && e.isPresenting && e.submitFrame();\n    }, this.dispose = function () {\n      \"undefined\" != typeof window && window.removeEventListener(\"vrdisplaypresentchange\", b);\n    };\n  }\n\n  function rb(a) {\n    var b = {};\n    return {\n      get: function get(c) {\n        if (void 0 !== b[c]) return b[c];\n        var d;\n\n        switch (c) {\n          case \"WEBGL_depth_texture\":\n            d = a.getExtension(\"WEBGL_depth_texture\") || a.getExtension(\"MOZ_WEBGL_depth_texture\") || a.getExtension(\"WEBKIT_WEBGL_depth_texture\");\n            break;\n\n          case \"EXT_texture_filter_anisotropic\":\n            d = a.getExtension(\"EXT_texture_filter_anisotropic\") || a.getExtension(\"MOZ_EXT_texture_filter_anisotropic\") || a.getExtension(\"WEBKIT_EXT_texture_filter_anisotropic\");\n            break;\n\n          case \"WEBGL_compressed_texture_s3tc\":\n            d = a.getExtension(\"WEBGL_compressed_texture_s3tc\") || a.getExtension(\"MOZ_WEBGL_compressed_texture_s3tc\") || a.getExtension(\"WEBKIT_WEBGL_compressed_texture_s3tc\");\n            break;\n\n          case \"WEBGL_compressed_texture_pvrtc\":\n            d = a.getExtension(\"WEBGL_compressed_texture_pvrtc\") || a.getExtension(\"WEBKIT_WEBGL_compressed_texture_pvrtc\");\n            break;\n\n          case \"WEBGL_compressed_texture_etc1\":\n            d = a.getExtension(\"WEBGL_compressed_texture_etc1\");\n            break;\n\n          default:\n            d = a.getExtension(c);\n        }\n\n        return null === d && console.warn(\"THREE.WebGLRenderer: \" + c + \" extension not supported.\"), b[c] = d, d;\n      }\n    };\n  }\n\n  function sb() {\n    function a() {\n      k.value !== d && (k.value = d, k.needsUpdate = e > 0), c.numPlanes = e, c.numIntersection = 0;\n    }\n\n    function b(a, b, d, e) {\n      var f = null !== a ? a.length : 0,\n          g = null;\n\n      if (0 !== f) {\n        if (g = k.value, !0 !== e || null === g) {\n          var h = d + 4 * f,\n              l = b.matrixWorldInverse;\n          j.getNormalMatrix(l), (null === g || g.length < h) && (g = new Float32Array(h));\n\n          for (var m = 0, n = d; m !== f; ++m, n += 4) {\n            i.copy(a[m]).applyMatrix4(l, j), i.normal.toArray(g, n), g[n + 3] = i.constant;\n          }\n        }\n\n        k.value = g, k.needsUpdate = !0;\n      }\n\n      return c.numPlanes = f, g;\n    }\n\n    var c = this,\n        d = null,\n        e = 0,\n        f = !1,\n        h = !1,\n        i = new ca(),\n        j = new g(),\n        k = {\n      value: null,\n      needsUpdate: !1\n    };\n    this.uniform = k, this.numPlanes = 0, this.numIntersection = 0, this.init = function (a, c, g) {\n      var h = 0 !== a.length || c || 0 !== e || f;\n      return f = c, d = b(a, g, 0), e = a.length, h;\n    }, this.beginShadows = function () {\n      h = !0, b(null);\n    }, this.endShadows = function () {\n      h = !1, a();\n    }, this.setState = function (c, g, i, j, l, m) {\n      if (!f || null === c || 0 === c.length || h && !i) h ? b(null) : a();else {\n        var n = h ? 0 : e,\n            o = 4 * n,\n            p = l.clippingState || null;\n        k.value = p, p = b(c, j, o, m);\n\n        for (var q = 0; q !== o; ++q) {\n          p[q] = d[q];\n        }\n\n        l.clippingState = p, this.numIntersection = g ? this.numPlanes : 0, this.numPlanes += n;\n      }\n    };\n  }\n\n  function tb(a, b) {\n    function c(c) {\n      var d;\n      if (c === Dc) return a.REPEAT;\n      if (c === Ec) return a.CLAMP_TO_EDGE;\n      if (c === Fc) return a.MIRRORED_REPEAT;\n      if (c === Gc) return a.NEAREST;\n      if (c === Hc) return a.NEAREST_MIPMAP_NEAREST;\n      if (c === Ic) return a.NEAREST_MIPMAP_LINEAR;\n      if (c === Jc) return a.LINEAR;\n      if (c === Kc) return a.LINEAR_MIPMAP_NEAREST;\n      if (c === Lc) return a.LINEAR_MIPMAP_LINEAR;\n      if (c === Mc) return a.UNSIGNED_BYTE;\n      if (c === Uc) return a.UNSIGNED_SHORT_4_4_4_4;\n      if (c === Vc) return a.UNSIGNED_SHORT_5_5_5_1;\n      if (c === Wc) return a.UNSIGNED_SHORT_5_6_5;\n      if (c === Nc) return a.BYTE;\n      if (c === Oc) return a.SHORT;\n      if (c === Pc) return a.UNSIGNED_SHORT;\n      if (c === Qc) return a.INT;\n      if (c === Rc) return a.UNSIGNED_INT;\n      if (c === Sc) return a.FLOAT;\n      if (c === Tc && null !== (d = b.get(\"OES_texture_half_float\"))) return d.HALF_FLOAT_OES;\n      if (c === Yc) return a.ALPHA;\n      if (c === Zc) return a.RGB;\n      if (c === $c) return a.RGBA;\n      if (c === _c) return a.LUMINANCE;\n      if (c === ad) return a.LUMINANCE_ALPHA;\n      if (c === bd) return a.DEPTH_COMPONENT;\n      if (c === cd) return a.DEPTH_STENCIL;\n      if (c === Rb) return a.FUNC_ADD;\n      if (c === Sb) return a.FUNC_SUBTRACT;\n      if (c === Tb) return a.FUNC_REVERSE_SUBTRACT;\n      if (c === Wb) return a.ZERO;\n      if (c === Xb) return a.ONE;\n      if (c === Yb) return a.SRC_COLOR;\n      if (c === Zb) return a.ONE_MINUS_SRC_COLOR;\n      if (c === $b) return a.SRC_ALPHA;\n      if (c === _b) return a.ONE_MINUS_SRC_ALPHA;\n      if (c === ac) return a.DST_ALPHA;\n      if (c === bc) return a.ONE_MINUS_DST_ALPHA;\n      if (c === cc) return a.DST_COLOR;\n      if (c === dc) return a.ONE_MINUS_DST_COLOR;\n      if (c === ec) return a.SRC_ALPHA_SATURATE;\n\n      if ((c === dd || c === ed || c === fd || c === gd) && null !== (d = b.get(\"WEBGL_compressed_texture_s3tc\"))) {\n        if (c === dd) return d.COMPRESSED_RGB_S3TC_DXT1_EXT;\n        if (c === ed) return d.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n        if (c === fd) return d.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n        if (c === gd) return d.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n      }\n\n      if ((c === hd || c === id || c === jd || c === kd) && null !== (d = b.get(\"WEBGL_compressed_texture_pvrtc\"))) {\n        if (c === hd) return d.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\n        if (c === id) return d.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\n        if (c === jd) return d.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\n        if (c === kd) return d.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\n      }\n\n      if (c === ld && null !== (d = b.get(\"WEBGL_compressed_texture_etc1\"))) return d.COMPRESSED_RGB_ETC1_WEBGL;\n\n      if ((c === Ub || c === Vb) && null !== (d = b.get(\"EXT_blend_minmax\"))) {\n        if (c === Ub) return d.MIN_EXT;\n        if (c === Vb) return d.MAX_EXT;\n      }\n\n      return c === Xc && null !== (d = b.get(\"WEBGL_depth_texture\")) ? d.UNSIGNED_INT_24_8_WEBGL : 0;\n    }\n\n    return {\n      convert: c\n    };\n  }\n\n  function ub(a) {\n    function b() {\n      return null === ba ? qa : 1;\n    }\n\n    function c() {\n      Ea = new rb(Ca), Ea.get(\"WEBGL_depth_texture\"), Ea.get(\"OES_texture_float\"), Ea.get(\"OES_texture_float_linear\"), Ea.get(\"OES_texture_half_float\"), Ea.get(\"OES_texture_half_float_linear\"), Ea.get(\"OES_standard_derivatives\"), Ea.get(\"OES_element_index_uint\"), Ea.get(\"ANGLE_instanced_arrays\"), bb = new tb(Ca, Ea), Fa = new nb(Ca, Ea, a), Ga = new mb(Ca, Ea, bb), Ga.scissor(la.copy(sa).multiplyScalar(qa)), Ga.viewport(ka.copy(ra).multiplyScalar(qa)), Ha = new lb(), Ia = new kb(Ca, Ea, Ga, Ha, Fa, bb, Aa), Ja = new fa(Ca), La = new Ta(Ca, Ja, Aa), Ma = new Wa(La, Ba), Ya = new Qa(Ca), Pa = new jb(_, Ea, Fa), Na = new Va(), Ua = new Oa(), Xa = new Ka(_, Ga, La, Q), Za = new Sa(Ca, Ea, Ba), $a = new Ra(Ca, Ea, Ba), _a = new W(_, Ca, Ga, Ia, Fa), ab = new Y(_, Ca, Ga, Ia, Fa), _.info.programs = Pa.programs, _.context = Ca, _.capabilities = Fa, _.extensions = Ea, _.properties = Ha, _.renderLists = Ua, _.state = Ga;\n    }\n\n    function e(a) {\n      a.preventDefault(), console.log(\"THREE.WebGLRenderer: Context Lost.\"), aa = !0;\n    }\n\n    function g() {\n      console.log(\"THREE.WebGLRenderer: Context Restored.\"), aa = !1, c();\n    }\n\n    function h(a) {\n      var b = a.target;\n      b.removeEventListener(\"dispose\", h), j(b);\n    }\n\n    function j(a) {\n      l(a), Ha.remove(a);\n    }\n\n    function l(a) {\n      var b = Ha.get(a).program;\n      a.program = void 0, void 0 !== b && Pa.releaseProgram(b);\n    }\n\n    function m(a, b, c) {\n      a.render(function (a) {\n        _.renderBufferImmediate(a, b, c);\n      });\n    }\n\n    function n(a, b, c, d) {\n      if (c && c.isInstancedBufferGeometry && null === Ea.get(\"ANGLE_instanced_arrays\")) return void console.error(\"THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.\");\n      void 0 === d && (d = 0), Ga.initAttributes();\n      var e = c.attributes,\n          f = b.getAttributes(),\n          g = a.defaultAttributeValues;\n\n      for (var h in f) {\n        var i = f[h];\n\n        if (i >= 0) {\n          var j = e[h];\n\n          if (void 0 !== j) {\n            var k = j.normalized,\n                l = j.itemSize,\n                m = Ja.get(j);\n            if (void 0 === m) continue;\n            var n = m.buffer,\n                o = m.type,\n                p = m.bytesPerElement;\n\n            if (j.isInterleavedBufferAttribute) {\n              var q = j.data,\n                  r = q.stride,\n                  s = j.offset;\n              q && q.isInstancedInterleavedBuffer ? (Ga.enableAttributeAndDivisor(i, q.meshPerAttribute), void 0 === c.maxInstancedCount && (c.maxInstancedCount = q.meshPerAttribute * q.count)) : Ga.enableAttribute(i), Ca.bindBuffer(Ca.ARRAY_BUFFER, n), Ca.vertexAttribPointer(i, l, o, k, r * p, (d * r + s) * p);\n            } else j.isInstancedBufferAttribute ? (Ga.enableAttributeAndDivisor(i, j.meshPerAttribute), void 0 === c.maxInstancedCount && (c.maxInstancedCount = j.meshPerAttribute * j.count)) : Ga.enableAttribute(i), Ca.bindBuffer(Ca.ARRAY_BUFFER, n), Ca.vertexAttribPointer(i, l, o, k, 0, d * l * p);\n          } else if (void 0 !== g) {\n            var t = g[h];\n            if (void 0 !== t) switch (t.length) {\n              case 2:\n                Ca.vertexAttrib2fv(i, t);\n                break;\n\n              case 3:\n                Ca.vertexAttrib3fv(i, t);\n                break;\n\n              case 4:\n                Ca.vertexAttrib4fv(i, t);\n                break;\n\n              default:\n                Ca.vertexAttrib1fv(i, t);\n            }\n          }\n        }\n      }\n\n      Ga.disableUnusedAttributes();\n    }\n\n    function o() {\n      if (!eb) {\n        var a = cb.getDevice();\n        a && a.isPresenting ? a.requestAnimationFrame(p) : window.requestAnimationFrame(p), eb = !0;\n      }\n    }\n\n    function p(a) {\n      null !== fb && fb(a);\n      var b = cb.getDevice();\n      b && b.isPresenting ? b.requestAnimationFrame(p) : window.requestAnimationFrame(p);\n    }\n\n    function q(a, b, c) {\n      if (!1 !== a.visible) {\n        if (a.layers.test(b.layers)) if (a.isLight) U.push(a), a.castShadow && V.push(a);else if (a.isSprite) a.frustumCulled && !ua.intersectsSprite(a) || Z.push(a);else if (a.isLensFlare) $.push(a);else if (a.isImmediateRenderObject) c && za.setFromMatrixPosition(a.matrixWorld).applyMatrix4(ya), X.push(a, null, a.material, za.z, null);else if ((a.isMesh || a.isLine || a.isPoints) && (a.isSkinnedMesh && a.skeleton.update(), !a.frustumCulled || ua.intersectsObject(a))) {\n          c && za.setFromMatrixPosition(a.matrixWorld).applyMatrix4(ya);\n          var d = Ma.update(a),\n              e = a.material;\n          if (Array.isArray(e)) for (var f = d.groups, g = 0, h = f.length; g < h; g++) {\n            var i = f[g],\n                j = e[i.materialIndex];\n            j && j.visible && X.push(a, d, j, za.z, i);\n          } else e.visible && X.push(a, d, e, za.z, null);\n        }\n\n        for (var k = a.children, g = 0, h = k.length; g < h; g++) {\n          q(k[g], b, c);\n        }\n      }\n    }\n\n    function r(a, b, c, d) {\n      for (var e = 0, f = a.length; e < f; e++) {\n        var g = a[e],\n            h = g.object,\n            i = g.geometry,\n            j = void 0 === d ? g.material : d,\n            k = g.group;\n\n        if (c.isArrayCamera) {\n          ja = c;\n\n          for (var l = c.cameras, m = 0, n = l.length; m < n; m++) {\n            var o = l[m];\n\n            if (h.layers.test(o.layers)) {\n              var p = o.bounds,\n                  q = p.x * oa,\n                  r = p.y * pa,\n                  t = p.z * oa,\n                  u = p.w * pa;\n              Ga.viewport(ka.set(q, r, t, u).multiplyScalar(qa)), s(h, b, o, i, j, k);\n            }\n          }\n        } else ja = null, s(h, b, c, i, j, k);\n      }\n    }\n\n    function s(a, b, c, d, e, f) {\n      if (a.onBeforeRender(_, b, c, d, e, f), a.modelViewMatrix.multiplyMatrices(c.matrixWorldInverse, a.matrixWorld), a.normalMatrix.getNormalMatrix(a.modelViewMatrix), a.isImmediateRenderObject) {\n        var g = a.isMesh && a.matrixWorld.determinant() < 0;\n        Ga.setMaterial(e, g);\n        var h = u(c, b.fog, e, a);\n        ha = \"\", m(a, h, e);\n      } else _.renderBufferDirect(c, b.fog, d, e, a, f);\n\n      a.onAfterRender(_, b, c, d, e, f);\n    }\n\n    function t(a, b, c) {\n      var d = Ha.get(a),\n          e = Pa.getParameters(a, Na.state, V, b, va.numPlanes, va.numIntersection, c),\n          f = Pa.getProgramCode(a, e),\n          g = d.program,\n          i = !0;\n      if (void 0 === g) a.addEventListener(\"dispose\", h);else if (g.code !== f) l(a);else {\n        if (void 0 !== e.shaderID) return;\n        i = !1;\n      }\n\n      if (i) {\n        if (e.shaderID) {\n          var j = Nf[e.shaderID];\n          d.shader = {\n            name: a.type,\n            uniforms: Jd.clone(j.uniforms),\n            vertexShader: j.vertexShader,\n            fragmentShader: j.fragmentShader\n          };\n        } else d.shader = {\n          name: a.type,\n          uniforms: a.uniforms,\n          vertexShader: a.vertexShader,\n          fragmentShader: a.fragmentShader\n        };\n\n        a.onBeforeCompile(d.shader), g = Pa.acquireProgram(a, d.shader, e, f), d.program = g, a.program = g;\n      }\n\n      var k = g.getAttributes();\n\n      if (a.morphTargets) {\n        a.numSupportedMorphTargets = 0;\n\n        for (var m = 0; m < _.maxMorphTargets; m++) {\n          k[\"morphTarget\" + m] >= 0 && a.numSupportedMorphTargets++;\n        }\n      }\n\n      if (a.morphNormals) {\n        a.numSupportedMorphNormals = 0;\n\n        for (var m = 0; m < _.maxMorphNormals; m++) {\n          k[\"morphNormal\" + m] >= 0 && a.numSupportedMorphNormals++;\n        }\n      }\n\n      var n = d.shader.uniforms;\n      (a.isShaderMaterial || a.isRawShaderMaterial) && !0 !== a.clipping || (d.numClippingPlanes = va.numPlanes, d.numIntersection = va.numIntersection, n.clippingPlanes = va.uniform), d.fog = b, d.lightsHash = Na.state.hash, a.lights && (n.ambientLightColor.value = Na.state.ambient, n.directionalLights.value = Na.state.directional, n.spotLights.value = Na.state.spot, n.rectAreaLights.value = Na.state.rectArea, n.pointLights.value = Na.state.point, n.hemisphereLights.value = Na.state.hemi, n.directionalShadowMap.value = Na.state.directionalShadowMap, n.directionalShadowMatrix.value = Na.state.directionalShadowMatrix, n.spotShadowMap.value = Na.state.spotShadowMap, n.spotShadowMatrix.value = Na.state.spotShadowMatrix, n.pointShadowMap.value = Na.state.pointShadowMap, n.pointShadowMatrix.value = Na.state.pointShadowMatrix);\n      var o = d.program.getUniforms(),\n          p = T.seqWithValue(o.seq, n);\n      d.uniformsList = p;\n    }\n\n    function u(a, b, c, d) {\n      na = 0;\n      var e = Ha.get(c);\n\n      if (wa && (xa || a !== ia)) {\n        var f = a === ia && c.id === ga;\n        va.setState(c.clippingPlanes, c.clipIntersection, c.clipShadows, a, e, f);\n      }\n\n      !1 === c.needsUpdate && (void 0 === e.program ? c.needsUpdate = !0 : c.fog && e.fog !== b ? c.needsUpdate = !0 : c.lights && e.lightsHash !== Na.state.hash ? c.needsUpdate = !0 : void 0 === e.numClippingPlanes || e.numClippingPlanes === va.numPlanes && e.numIntersection === va.numIntersection || (c.needsUpdate = !0)), c.needsUpdate && (t(c, b, d), c.needsUpdate = !1);\n      var g = !1,\n          h = !1,\n          i = !1,\n          j = e.program,\n          l = j.getUniforms(),\n          m = e.shader.uniforms;\n\n      if (Ga.useProgram(j.program) && (g = !0, h = !0, i = !0), c.id !== ga && (ga = c.id, h = !0), g || a !== ia) {\n        if (l.setValue(Ca, \"projectionMatrix\", a.projectionMatrix), Fa.logarithmicDepthBuffer && l.setValue(Ca, \"logDepthBufFC\", 2 / (Math.log(a.far + 1) / Math.LN2)), ia !== (ja || a) && (ia = ja || a, h = !0, i = !0), c.isShaderMaterial || c.isMeshPhongMaterial || c.isMeshStandardMaterial || c.envMap) {\n          var n = l.map.cameraPosition;\n          void 0 !== n && n.setValue(Ca, za.setFromMatrixPosition(a.matrixWorld));\n        }\n\n        (c.isMeshPhongMaterial || c.isMeshLambertMaterial || c.isMeshBasicMaterial || c.isMeshStandardMaterial || c.isShaderMaterial || c.skinning) && l.setValue(Ca, \"viewMatrix\", a.matrixWorldInverse);\n      }\n\n      if (c.skinning) {\n        l.setOptional(Ca, d, \"bindMatrix\"), l.setOptional(Ca, d, \"bindMatrixInverse\");\n        var o = d.skeleton;\n\n        if (o) {\n          var p = o.bones;\n\n          if (Fa.floatVertexTextures) {\n            if (void 0 === o.boneTexture) {\n              var q = Math.sqrt(4 * p.length);\n              q = yd.ceilPowerOfTwo(q), q = Math.max(q, 4);\n              var r = new Float32Array(q * q * 4);\n              r.set(o.boneMatrices);\n              var s = new k(r, q, q, $c, Sc);\n              o.boneMatrices = r, o.boneTexture = s, o.boneTextureSize = q;\n            }\n\n            l.setValue(Ca, \"boneTexture\", o.boneTexture), l.setValue(Ca, \"boneTextureSize\", o.boneTextureSize);\n          } else l.setOptional(Ca, o, \"boneMatrices\");\n        }\n      }\n\n      return h && (l.setValue(Ca, \"toneMappingExposure\", _.toneMappingExposure), l.setValue(Ca, \"toneMappingWhitePoint\", _.toneMappingWhitePoint), c.lights && I(m, i), b && c.fog && z(m, b), c.isMeshBasicMaterial ? v(m, c) : c.isMeshLambertMaterial ? (v(m, c), A(m, c)) : c.isMeshPhongMaterial ? (v(m, c), c.isMeshToonMaterial ? C(m, c) : B(m, c)) : c.isMeshStandardMaterial ? (v(m, c), c.isMeshPhysicalMaterial ? E(m, c) : D(m, c)) : c.isMeshDepthMaterial ? (v(m, c), F(m, c)) : c.isMeshDistanceMaterial ? (v(m, c), G(m, c)) : c.isMeshNormalMaterial ? (v(m, c), H(m, c)) : c.isLineBasicMaterial ? (w(m, c), c.isLineDashedMaterial && x(m, c)) : c.isPointsMaterial ? y(m, c) : c.isShadowMaterial && (m.color.value = c.color, m.opacity.value = c.opacity), void 0 !== m.ltcMat && (m.ltcMat.value = Id.LTC_MAT_TEXTURE), void 0 !== m.ltcMag && (m.ltcMag.value = Id.LTC_MAG_TEXTURE), T.upload(Ca, e.uniformsList, m, _)), l.setValue(Ca, \"modelViewMatrix\", d.modelViewMatrix), l.setValue(Ca, \"normalMatrix\", d.normalMatrix), l.setValue(Ca, \"modelMatrix\", d.matrixWorld), j;\n    }\n\n    function v(a, b) {\n      a.opacity.value = b.opacity, b.color && (a.diffuse.value = b.color), b.emissive && a.emissive.value.copy(b.emissive).multiplyScalar(b.emissiveIntensity), b.map && (a.map.value = b.map), b.alphaMap && (a.alphaMap.value = b.alphaMap), b.specularMap && (a.specularMap.value = b.specularMap), b.envMap && (a.envMap.value = b.envMap, a.flipEnvMap.value = b.envMap && b.envMap.isCubeTexture ? -1 : 1, a.reflectivity.value = b.reflectivity, a.refractionRatio.value = b.refractionRatio), b.lightMap && (a.lightMap.value = b.lightMap, a.lightMapIntensity.value = b.lightMapIntensity), b.aoMap && (a.aoMap.value = b.aoMap, a.aoMapIntensity.value = b.aoMapIntensity);\n      var c;\n\n      if (b.map ? c = b.map : b.specularMap ? c = b.specularMap : b.displacementMap ? c = b.displacementMap : b.normalMap ? c = b.normalMap : b.bumpMap ? c = b.bumpMap : b.roughnessMap ? c = b.roughnessMap : b.metalnessMap ? c = b.metalnessMap : b.alphaMap ? c = b.alphaMap : b.emissiveMap && (c = b.emissiveMap), void 0 !== c) {\n        if (c.isWebGLRenderTarget && (c = c.texture), !0 === c.matrixAutoUpdate) {\n          var d = c.offset,\n              e = c.repeat,\n              f = c.rotation,\n              g = c.center;\n          c.matrix.setUvTransform(d.x, d.y, e.x, e.y, f, g.x, g.y);\n        }\n\n        a.uvTransform.value.copy(c.matrix);\n      }\n    }\n\n    function w(a, b) {\n      a.diffuse.value = b.color, a.opacity.value = b.opacity;\n    }\n\n    function x(a, b) {\n      a.dashSize.value = b.dashSize, a.totalSize.value = b.dashSize + b.gapSize, a.scale.value = b.scale;\n    }\n\n    function y(a, b) {\n      if (a.diffuse.value = b.color, a.opacity.value = b.opacity, a.size.value = b.size * qa, a.scale.value = .5 * pa, a.map.value = b.map, null !== b.map) {\n        if (!0 === b.map.matrixAutoUpdate) {\n          var c = b.map.offset,\n              d = b.map.repeat,\n              e = b.map.rotation,\n              f = b.map.center;\n          b.map.matrix.setUvTransform(c.x, c.y, d.x, d.y, e, f.x, f.y);\n        }\n\n        a.uvTransform.value.copy(b.map.matrix);\n      }\n    }\n\n    function z(a, b) {\n      a.fogColor.value = b.color, b.isFog ? (a.fogNear.value = b.near, a.fogFar.value = b.far) : b.isFogExp2 && (a.fogDensity.value = b.density);\n    }\n\n    function A(a, b) {\n      b.emissiveMap && (a.emissiveMap.value = b.emissiveMap);\n    }\n\n    function B(a, b) {\n      a.specular.value = b.specular, a.shininess.value = Math.max(b.shininess, 1e-4), b.emissiveMap && (a.emissiveMap.value = b.emissiveMap), b.bumpMap && (a.bumpMap.value = b.bumpMap, a.bumpScale.value = b.bumpScale), b.normalMap && (a.normalMap.value = b.normalMap, a.normalScale.value.copy(b.normalScale)), b.displacementMap && (a.displacementMap.value = b.displacementMap, a.displacementScale.value = b.displacementScale, a.displacementBias.value = b.displacementBias);\n    }\n\n    function C(a, b) {\n      B(a, b), b.gradientMap && (a.gradientMap.value = b.gradientMap);\n    }\n\n    function D(a, b) {\n      a.roughness.value = b.roughness, a.metalness.value = b.metalness, b.roughnessMap && (a.roughnessMap.value = b.roughnessMap), b.metalnessMap && (a.metalnessMap.value = b.metalnessMap), b.emissiveMap && (a.emissiveMap.value = b.emissiveMap), b.bumpMap && (a.bumpMap.value = b.bumpMap, a.bumpScale.value = b.bumpScale), b.normalMap && (a.normalMap.value = b.normalMap, a.normalScale.value.copy(b.normalScale)), b.displacementMap && (a.displacementMap.value = b.displacementMap, a.displacementScale.value = b.displacementScale, a.displacementBias.value = b.displacementBias), b.envMap && (a.envMapIntensity.value = b.envMapIntensity);\n    }\n\n    function E(a, b) {\n      a.clearCoat.value = b.clearCoat, a.clearCoatRoughness.value = b.clearCoatRoughness, D(a, b);\n    }\n\n    function F(a, b) {\n      b.displacementMap && (a.displacementMap.value = b.displacementMap, a.displacementScale.value = b.displacementScale, a.displacementBias.value = b.displacementBias);\n    }\n\n    function G(a, b) {\n      b.displacementMap && (a.displacementMap.value = b.displacementMap, a.displacementScale.value = b.displacementScale, a.displacementBias.value = b.displacementBias), a.referencePosition.value.copy(b.referencePosition), a.nearDistance.value = b.nearDistance, a.farDistance.value = b.farDistance;\n    }\n\n    function H(a, b) {\n      b.bumpMap && (a.bumpMap.value = b.bumpMap, a.bumpScale.value = b.bumpScale), b.normalMap && (a.normalMap.value = b.normalMap, a.normalScale.value.copy(b.normalScale)), b.displacementMap && (a.displacementMap.value = b.displacementMap, a.displacementScale.value = b.displacementScale, a.displacementBias.value = b.displacementBias);\n    }\n\n    function I(a, b) {\n      a.ambientLightColor.needsUpdate = b, a.directionalLights.needsUpdate = b, a.pointLights.needsUpdate = b, a.spotLights.needsUpdate = b, a.rectAreaLights.needsUpdate = b, a.hemisphereLights.needsUpdate = b;\n    }\n\n    function J() {\n      var a = na;\n      return a >= Fa.maxTextures && console.warn(\"THREE.WebGLRenderer: Trying to use \" + a + \" texture units while this GPU supports only \" + Fa.maxTextures), na += 1, a;\n    }\n\n    console.log(\"THREE.WebGLRenderer\", zb), a = a || {};\n    var K = void 0 !== a.canvas ? a.canvas : document.createElementNS(\"http://www.w3.org/1999/xhtml\", \"canvas\"),\n        L = void 0 !== a.context ? a.context : null,\n        M = void 0 !== a.alpha && a.alpha,\n        N = void 0 === a.depth || a.depth,\n        O = void 0 === a.stencil || a.stencil,\n        P = void 0 !== a.antialias && a.antialias,\n        Q = void 0 === a.premultipliedAlpha || a.premultipliedAlpha,\n        R = void 0 !== a.preserveDrawingBuffer && a.preserveDrawingBuffer,\n        S = void 0 !== a.powerPreference ? a.powerPreference : \"default\",\n        U = [],\n        V = [],\n        X = null,\n        Z = [],\n        $ = [];\n    this.domElement = K, this.context = null, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.gammaInput = !1, this.gammaOutput = !1, this.physicallyCorrectLights = !1, this.toneMapping = rc, this.toneMappingExposure = 1, this.toneMappingWhitePoint = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;\n\n    var _ = this,\n        aa = !1,\n        ba = null,\n        ca = null,\n        ga = -1,\n        ha = \"\",\n        ia = null,\n        ja = null,\n        ka = new i(),\n        la = new i(),\n        ma = null,\n        na = 0,\n        oa = K.width,\n        pa = K.height,\n        qa = 1,\n        ra = new i(0, 0, oa, pa),\n        sa = new i(0, 0, oa, pa),\n        ta = !1,\n        ua = new da(),\n        va = new sb(),\n        wa = !1,\n        xa = !1,\n        ya = new d(),\n        za = new f(),\n        Aa = {\n      geometries: 0,\n      textures: 0\n    },\n        Ba = {\n      frame: 0,\n      calls: 0,\n      vertices: 0,\n      faces: 0,\n      points: 0\n    };\n\n    this.info = {\n      render: Ba,\n      memory: Aa,\n      programs: null\n    };\n    var Ca;\n\n    try {\n      var Da = {\n        alpha: M,\n        depth: N,\n        stencil: O,\n        antialias: P,\n        premultipliedAlpha: Q,\n        preserveDrawingBuffer: R,\n        powerPreference: S\n      };\n      if (K.addEventListener(\"webglcontextlost\", e, !1), K.addEventListener(\"webglcontextrestored\", g, !1), null === (Ca = L || K.getContext(\"webgl\", Da) || K.getContext(\"experimental-webgl\", Da))) throw null !== K.getContext(\"webgl\") ? new Error(\"Error creating WebGL context with your selected attributes.\") : new Error(\"Error creating WebGL context.\");\n      void 0 === Ca.getShaderPrecisionFormat && (Ca.getShaderPrecisionFormat = function () {\n        return {\n          rangeMin: 1,\n          rangeMax: 1,\n          precision: 1\n        };\n      });\n    } catch (a) {\n      console.error(\"THREE.WebGLRenderer: \" + a.message);\n    }\n\n    var Ea, Fa, Ga, Ha, Ia, Ja, La, Ma, Na, Pa, Ua, Xa, Ya, Za, $a, _a, ab, bb;\n\n    c();\n    var cb = new qb(_);\n    this.vr = cb;\n    var db = new ea(_, Ma, Fa.maxTextureSize);\n    this.shadowMap = db, this.getContext = function () {\n      return Ca;\n    }, this.getContextAttributes = function () {\n      return Ca.getContextAttributes();\n    }, this.forceContextLoss = function () {\n      var a = Ea.get(\"WEBGL_lose_context\");\n      a && a.loseContext();\n    }, this.forceContextRestore = function () {\n      var a = Ea.get(\"WEBGL_lose_context\");\n      a && a.restoreContext();\n    }, this.getPixelRatio = function () {\n      return qa;\n    }, this.setPixelRatio = function (a) {\n      void 0 !== a && (qa = a, this.setSize(oa, pa, !1));\n    }, this.getSize = function () {\n      return {\n        width: oa,\n        height: pa\n      };\n    }, this.setSize = function (a, b, c) {\n      var d = cb.getDevice();\n      if (d && d.isPresenting) return void console.warn(\"THREE.WebGLRenderer: Can't change size while VR device is presenting.\");\n      oa = a, pa = b, K.width = a * qa, K.height = b * qa, !1 !== c && (K.style.width = a + \"px\", K.style.height = b + \"px\"), this.setViewport(0, 0, a, b);\n    }, this.getDrawingBufferSize = function () {\n      return {\n        width: oa * qa,\n        height: pa * qa\n      };\n    }, this.setDrawingBufferSize = function (a, b, c) {\n      oa = a, pa = b, qa = c, K.width = a * c, K.height = b * c, this.setViewport(0, 0, a, b);\n    }, this.setViewport = function (a, b, c, d) {\n      ra.set(a, pa - b - d, c, d), Ga.viewport(ka.copy(ra).multiplyScalar(qa));\n    }, this.setScissor = function (a, b, c, d) {\n      sa.set(a, pa - b - d, c, d), Ga.scissor(la.copy(sa).multiplyScalar(qa));\n    }, this.setScissorTest = function (a) {\n      Ga.setScissorTest(ta = a);\n    }, this.getClearColor = function () {\n      return Xa.getClearColor();\n    }, this.setClearColor = function () {\n      Xa.setClearColor.apply(Xa, arguments);\n    }, this.getClearAlpha = function () {\n      return Xa.getClearAlpha();\n    }, this.setClearAlpha = function () {\n      Xa.setClearAlpha.apply(Xa, arguments);\n    }, this.clear = function (a, b, c) {\n      var d = 0;\n      (void 0 === a || a) && (d |= Ca.COLOR_BUFFER_BIT), (void 0 === b || b) && (d |= Ca.DEPTH_BUFFER_BIT), (void 0 === c || c) && (d |= Ca.STENCIL_BUFFER_BIT), Ca.clear(d);\n    }, this.clearColor = function () {\n      this.clear(!0, !1, !1);\n    }, this.clearDepth = function () {\n      this.clear(!1, !0, !1);\n    }, this.clearStencil = function () {\n      this.clear(!1, !1, !0);\n    }, this.clearTarget = function (a, b, c, d) {\n      this.setRenderTarget(a), this.clear(b, c, d);\n    }, this.dispose = function () {\n      K.removeEventListener(\"webglcontextlost\", e, !1), K.removeEventListener(\"webglcontextrestored\", g, !1), Ua.dispose(), cb.dispose();\n    }, this.renderBufferImmediate = function (a, b, c) {\n      Ga.initAttributes();\n      var d = Ha.get(a);\n      a.hasPositions && !d.position && (d.position = Ca.createBuffer()), a.hasNormals && !d.normal && (d.normal = Ca.createBuffer()), a.hasUvs && !d.uv && (d.uv = Ca.createBuffer()), a.hasColors && !d.color && (d.color = Ca.createBuffer());\n      var e = b.getAttributes();\n\n      if (a.hasPositions && (Ca.bindBuffer(Ca.ARRAY_BUFFER, d.position), Ca.bufferData(Ca.ARRAY_BUFFER, a.positionArray, Ca.DYNAMIC_DRAW), Ga.enableAttribute(e.position), Ca.vertexAttribPointer(e.position, 3, Ca.FLOAT, !1, 0, 0)), a.hasNormals) {\n        if (Ca.bindBuffer(Ca.ARRAY_BUFFER, d.normal), !c.isMeshPhongMaterial && !c.isMeshStandardMaterial && !c.isMeshNormalMaterial && !0 === c.flatShading) for (var f = 0, g = 3 * a.count; f < g; f += 9) {\n          var h = a.normalArray,\n              i = (h[f + 0] + h[f + 3] + h[f + 6]) / 3,\n              j = (h[f + 1] + h[f + 4] + h[f + 7]) / 3,\n              k = (h[f + 2] + h[f + 5] + h[f + 8]) / 3;\n          h[f + 0] = i, h[f + 1] = j, h[f + 2] = k, h[f + 3] = i, h[f + 4] = j, h[f + 5] = k, h[f + 6] = i, h[f + 7] = j, h[f + 8] = k;\n        }\n        Ca.bufferData(Ca.ARRAY_BUFFER, a.normalArray, Ca.DYNAMIC_DRAW), Ga.enableAttribute(e.normal), Ca.vertexAttribPointer(e.normal, 3, Ca.FLOAT, !1, 0, 0);\n      }\n\n      a.hasUvs && c.map && (Ca.bindBuffer(Ca.ARRAY_BUFFER, d.uv), Ca.bufferData(Ca.ARRAY_BUFFER, a.uvArray, Ca.DYNAMIC_DRAW), Ga.enableAttribute(e.uv), Ca.vertexAttribPointer(e.uv, 2, Ca.FLOAT, !1, 0, 0)), a.hasColors && c.vertexColors !== Kb && (Ca.bindBuffer(Ca.ARRAY_BUFFER, d.color), Ca.bufferData(Ca.ARRAY_BUFFER, a.colorArray, Ca.DYNAMIC_DRAW), Ga.enableAttribute(e.color), Ca.vertexAttribPointer(e.color, 3, Ca.FLOAT, !1, 0, 0)), Ga.disableUnusedAttributes(), Ca.drawArrays(Ca.TRIANGLES, 0, a.count), a.count = 0;\n    }, this.renderBufferDirect = function (a, c, d, e, f, g) {\n      var h = f.isMesh && f.matrixWorld.determinant() < 0;\n      Ga.setMaterial(e, h);\n      var i = u(a, c, e, f),\n          j = d.id + \"_\" + i.id + \"_\" + (!0 === e.wireframe),\n          k = !1;\n      j !== ha && (ha = j, k = !0), f.morphTargetInfluences && (Ya.update(f, d, e, i), k = !0);\n      var l = d.index,\n          m = d.attributes.position,\n          o = 1;\n      !0 === e.wireframe && (l = La.getWireframeAttribute(d), o = 2);\n      var p,\n          q = Za;\n      null !== l && (p = Ja.get(l), q = $a, q.setIndex(p)), k && (n(e, i, d), null !== l && Ca.bindBuffer(Ca.ELEMENT_ARRAY_BUFFER, p.buffer));\n      var r = 0;\n      null !== l ? r = l.count : void 0 !== m && (r = m.count);\n      var s = d.drawRange.start * o,\n          t = d.drawRange.count * o,\n          v = null !== g ? g.start * o : 0,\n          w = null !== g ? g.count * o : 1 / 0,\n          x = Math.max(s, v),\n          y = Math.min(r, s + t, v + w) - 1,\n          z = Math.max(0, y - x + 1);\n\n      if (0 !== z) {\n        if (f.isMesh) {\n          if (!0 === e.wireframe) Ga.setLineWidth(e.wireframeLinewidth * b()), q.setMode(Ca.LINES);else switch (f.drawMode) {\n            case md:\n              q.setMode(Ca.TRIANGLES);\n              break;\n\n            case nd:\n              q.setMode(Ca.TRIANGLE_STRIP);\n              break;\n\n            case od:\n              q.setMode(Ca.TRIANGLE_FAN);\n          }\n        } else if (f.isLine) {\n          var A = e.linewidth;\n          void 0 === A && (A = 1), Ga.setLineWidth(A * b()), f.isLineSegments ? q.setMode(Ca.LINES) : f.isLineLoop ? q.setMode(Ca.LINE_LOOP) : q.setMode(Ca.LINE_STRIP);\n        } else f.isPoints && q.setMode(Ca.POINTS);\n        d && d.isInstancedBufferGeometry ? d.maxInstancedCount > 0 && q.renderInstances(d, x, z) : q.render(x, z);\n      }\n    }, this.compile = function (a, b) {\n      U.length = 0, V.length = 0, a.traverse(function (a) {\n        a.isLight && (U.push(a), a.castShadow && V.push(a));\n      }), Na.setup(U, V, b), a.traverse(function (b) {\n        if (b.material) if (Array.isArray(b.material)) for (var c = 0; c < b.material.length; c++) {\n          t(b.material[c], a.fog, b);\n        } else t(b.material, a.fog, b);\n      });\n    };\n    var eb = !1,\n        fb = null;\n    this.animate = function (a) {\n      fb = a, o();\n    }, this.render = function (a, b, c, d) {\n      if (!b || !b.isCamera) return void console.error(\"THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.\");\n\n      if (!aa) {\n        ha = \"\", ga = -1, ia = null, !0 === a.autoUpdate && a.updateMatrixWorld(), null === b.parent && b.updateMatrixWorld(), cb.enabled && (b = cb.getCamera(b)), ya.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse), ua.setFromMatrix(ya), U.length = 0, V.length = 0, Z.length = 0, $.length = 0, xa = this.localClippingEnabled, wa = va.init(this.clippingPlanes, xa, b), X = Ua.get(a, b), X.init(), q(a, b, _.sortObjects), !0 === _.sortObjects && X.sort(), Ia.updateVideoTextures(), wa && va.beginShadows(), db.render(V, a, b), Na.setup(U, V, b), wa && va.endShadows(), Ba.frame++, Ba.calls = 0, Ba.vertices = 0, Ba.faces = 0, Ba.points = 0, void 0 === c && (c = null), this.setRenderTarget(c), Xa.render(X, a, b, d);\n        var e = X.opaque,\n            f = X.transparent;\n\n        if (a.overrideMaterial) {\n          var g = a.overrideMaterial;\n          e.length && r(e, a, b, g), f.length && r(f, a, b, g);\n        } else e.length && r(e, a, b), f.length && r(f, a, b);\n\n        ab.render(Z, a, b), _a.render($, a, b, ka), c && Ia.updateRenderTargetMipmap(c), Ga.buffers.depth.setTest(!0), Ga.buffers.depth.setMask(!0), Ga.buffers.color.setMask(!0), Ga.setPolygonOffset(!1), cb.enabled && cb.submitFrame();\n      }\n    }, this.setFaceCulling = function (a, b) {\n      Ga.setCullFace(a), Ga.setFlipSided(b === Db);\n    }, this.allocTextureUnit = J, this.setTexture2D = function () {\n      var a = !1;\n      return function (b, c) {\n        b && b.isWebGLRenderTarget && (a || (console.warn(\"THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.\"), a = !0), b = b.texture), Ia.setTexture2D(b, c);\n      };\n    }(), this.setTexture = function () {\n      var a = !1;\n      return function (b, c) {\n        a || (console.warn(\"THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.\"), a = !0), Ia.setTexture2D(b, c);\n      };\n    }(), this.setTextureCube = function () {\n      var a = !1;\n      return function (b, c) {\n        b && b.isWebGLRenderTargetCube && (a || (console.warn(\"THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.\"), a = !0), b = b.texture), b && b.isCubeTexture || Array.isArray(b.image) && 6 === b.image.length ? Ia.setTextureCube(b, c) : Ia.setTextureCubeDynamic(b, c);\n      };\n    }(), this.getRenderTarget = function () {\n      return ba;\n    }, this.setRenderTarget = function (a) {\n      ba = a, a && void 0 === Ha.get(a).__webglFramebuffer && Ia.setupRenderTarget(a);\n      var b = null,\n          c = !1;\n\n      if (a) {\n        var d = Ha.get(a).__webglFramebuffer;\n\n        a.isWebGLRenderTargetCube ? (b = d[a.activeCubeFace], c = !0) : b = d, ka.copy(a.viewport), la.copy(a.scissor), ma = a.scissorTest;\n      } else ka.copy(ra).multiplyScalar(qa), la.copy(sa).multiplyScalar(qa), ma = ta;\n\n      if (ca !== b && (Ca.bindFramebuffer(Ca.FRAMEBUFFER, b), ca = b), Ga.viewport(ka), Ga.scissor(la), Ga.setScissorTest(ma), c) {\n        var e = Ha.get(a.texture);\n        Ca.framebufferTexture2D(Ca.FRAMEBUFFER, Ca.COLOR_ATTACHMENT0, Ca.TEXTURE_CUBE_MAP_POSITIVE_X + a.activeCubeFace, e.__webglTexture, a.activeMipMapLevel);\n      }\n    }, this.readRenderTargetPixels = function (a, b, c, d, e, f) {\n      if (!a || !a.isWebGLRenderTarget) return void console.error(\"THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.\");\n\n      var g = Ha.get(a).__webglFramebuffer;\n\n      if (g) {\n        var h = !1;\n        g !== ca && (Ca.bindFramebuffer(Ca.FRAMEBUFFER, g), h = !0);\n\n        try {\n          var i = a.texture,\n              j = i.format,\n              k = i.type;\n          if (j !== $c && bb.convert(j) !== Ca.getParameter(Ca.IMPLEMENTATION_COLOR_READ_FORMAT)) return void console.error(\"THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.\");\n          if (!(k === Mc || bb.convert(k) === Ca.getParameter(Ca.IMPLEMENTATION_COLOR_READ_TYPE) || k === Sc && (Ea.get(\"OES_texture_float\") || Ea.get(\"WEBGL_color_buffer_float\")) || k === Tc && Ea.get(\"EXT_color_buffer_half_float\"))) return void console.error(\"THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.\");\n          Ca.checkFramebufferStatus(Ca.FRAMEBUFFER) === Ca.FRAMEBUFFER_COMPLETE ? b >= 0 && b <= a.width - d && c >= 0 && c <= a.height - e && Ca.readPixels(b, c, d, e, bb.convert(j), bb.convert(k), f) : console.error(\"THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.\");\n        } finally {\n          h && Ca.bindFramebuffer(Ca.FRAMEBUFFER, ca);\n        }\n      }\n    };\n  }\n\n  function vb() {\n    ia.call(this), this.type = \"Scene\", this.background = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0;\n  }\n\n  function wb(a, b, c) {\n    var d = this,\n        e = !1,\n        f = 0,\n        g = 0,\n        h = void 0;\n    this.onStart = void 0, this.onLoad = a, this.onProgress = b, this.onError = c, this.itemStart = function (a) {\n      g++, !1 === e && void 0 !== d.onStart && d.onStart(a, f, g), e = !0;\n    }, this.itemEnd = function (a) {\n      f++, void 0 !== d.onProgress && d.onProgress(a, f, g), f === g && (e = !1, void 0 !== d.onLoad && d.onLoad());\n    }, this.itemError = function (a) {\n      void 0 !== d.onError && d.onError(a);\n    }, this.resolveURL = function (a) {\n      return h ? h(a) : a;\n    }, this.setURLModifier = function (a) {\n      return h = a, this;\n    };\n  }\n\n  function xb(a) {\n    this.manager = void 0 !== a ? a : Uf;\n  }\n\n  function yb(a) {\n    this.manager = void 0 !== a ? a : Uf;\n  }\n\n  void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (Number.isInteger = function (a) {\n    return \"number\" == typeof a && isFinite(a) && Math.floor(a) === a;\n  }), void 0 === Math.sign && (Math.sign = function (a) {\n    return a < 0 ? -1 : a > 0 ? 1 : +a;\n  }), \"name\" in Function.prototype == !1 && Object.defineProperty(Function.prototype, \"name\", {\n    get: function get() {\n      return this.toString().match(/^\\s*function\\s*([^\\(\\s]*)/)[1];\n    }\n  }), void 0 === Object.assign && function () {\n    Object.assign = function (a) {\n      if (void 0 === a || null === a) throw new TypeError(\"Cannot convert undefined or null to object\");\n\n      for (var b = Object(a), c = 1; c < arguments.length; c++) {\n        var d = arguments[c];\n        if (void 0 !== d && null !== d) for (var e in d) {\n          Object.prototype.hasOwnProperty.call(d, e) && (b[e] = d[e]);\n        }\n      }\n\n      return b;\n    };\n  }(), Object.assign(b.prototype, {\n    addEventListener: function addEventListener(a, b) {\n      void 0 === this._listeners && (this._listeners = {});\n      var c = this._listeners;\n      void 0 === c[a] && (c[a] = []), -1 === c[a].indexOf(b) && c[a].push(b);\n    },\n    hasEventListener: function hasEventListener(a, b) {\n      if (void 0 === this._listeners) return !1;\n      var c = this._listeners;\n      return void 0 !== c[a] && -1 !== c[a].indexOf(b);\n    },\n    removeEventListener: function removeEventListener(a, b) {\n      if (void 0 !== this._listeners) {\n        var c = this._listeners,\n            d = c[a];\n\n        if (void 0 !== d) {\n          var e = d.indexOf(b);\n          -1 !== e && d.splice(e, 1);\n        }\n      }\n    },\n    dispatchEvent: function dispatchEvent(a) {\n      if (void 0 !== this._listeners) {\n        var b = this._listeners,\n            c = b[a.type];\n\n        if (void 0 !== c) {\n          a.target = this;\n\n          for (var d = c.slice(0), e = 0, f = d.length; e < f; e++) {\n            d[e].call(this, a);\n          }\n        }\n      }\n    }\n  });\n  var zb = \"89\",\n      Ab = 0,\n      Bb = 1,\n      Cb = 2,\n      Db = 0,\n      Eb = 1,\n      Fb = 2,\n      Gb = 0,\n      Hb = 1,\n      Ib = 2,\n      Jb = 1,\n      Kb = 0,\n      Lb = 0,\n      Mb = 1,\n      Nb = 2,\n      Ob = 3,\n      Pb = 4,\n      Qb = 5,\n      Rb = 100,\n      Sb = 101,\n      Tb = 102,\n      Ub = 103,\n      Vb = 104,\n      Wb = 200,\n      Xb = 201,\n      Yb = 202,\n      Zb = 203,\n      $b = 204,\n      _b = 205,\n      ac = 206,\n      bc = 207,\n      cc = 208,\n      dc = 209,\n      ec = 210,\n      fc = 0,\n      gc = 1,\n      hc = 2,\n      ic = 3,\n      jc = 4,\n      kc = 5,\n      lc = 6,\n      mc = 7,\n      nc = 0,\n      oc = 1,\n      pc = 2,\n      qc = 0,\n      rc = 1,\n      sc = 2,\n      tc = 3,\n      uc = 4,\n      vc = 300,\n      wc = 301,\n      xc = 302,\n      yc = 303,\n      zc = 304,\n      Ac = 305,\n      Bc = 306,\n      Cc = 307,\n      Dc = 1e3,\n      Ec = 1001,\n      Fc = 1002,\n      Gc = 1003,\n      Hc = 1004,\n      Ic = 1005,\n      Jc = 1006,\n      Kc = 1007,\n      Lc = 1008,\n      Mc = 1009,\n      Nc = 1010,\n      Oc = 1011,\n      Pc = 1012,\n      Qc = 1013,\n      Rc = 1014,\n      Sc = 1015,\n      Tc = 1016,\n      Uc = 1017,\n      Vc = 1018,\n      Wc = 1019,\n      Xc = 1020,\n      Yc = 1021,\n      Zc = 1022,\n      $c = 1023,\n      _c = 1024,\n      ad = 1025,\n      bd = 1026,\n      cd = 1027,\n      dd = 2001,\n      ed = 2002,\n      fd = 2003,\n      gd = 2004,\n      hd = 2100,\n      id = 2101,\n      jd = 2102,\n      kd = 2103,\n      ld = 2151,\n      md = 0,\n      nd = 1,\n      od = 2,\n      pd = 3e3,\n      qd = 3001,\n      rd = 3007,\n      sd = 3002,\n      td = 3004,\n      ud = 3005,\n      vd = 3006,\n      wd = 3200,\n      xd = 3201,\n      yd = {\n    DEG2RAD: Math.PI / 180,\n    RAD2DEG: 180 / Math.PI,\n    generateUUID: function () {\n      for (var a = [], b = 0; b < 256; b++) {\n        a[b] = (b < 16 ? \"0\" : \"\") + b.toString(16).toUpperCase();\n      }\n\n      return function () {\n        var b = 4294967295 * Math.random() | 0,\n            c = 4294967295 * Math.random() | 0,\n            d = 4294967295 * Math.random() | 0,\n            e = 4294967295 * Math.random() | 0;\n        return a[255 & b] + a[b >> 8 & 255] + a[b >> 16 & 255] + a[b >> 24 & 255] + \"-\" + a[255 & c] + a[c >> 8 & 255] + \"-\" + a[c >> 16 & 15 | 64] + a[c >> 24 & 255] + \"-\" + a[63 & d | 128] + a[d >> 8 & 255] + \"-\" + a[d >> 16 & 255] + a[d >> 24 & 255] + a[255 & e] + a[e >> 8 & 255] + a[e >> 16 & 255] + a[e >> 24 & 255];\n      };\n    }(),\n    clamp: function clamp(a, b, c) {\n      return Math.max(b, Math.min(c, a));\n    },\n    euclideanModulo: function euclideanModulo(a, b) {\n      return (a % b + b) % b;\n    },\n    mapLinear: function mapLinear(a, b, c, d, e) {\n      return d + (a - b) * (e - d) / (c - b);\n    },\n    lerp: function lerp(a, b, c) {\n      return (1 - c) * a + c * b;\n    },\n    smoothstep: function smoothstep(a, b, c) {\n      return a <= b ? 0 : a >= c ? 1 : (a = (a - b) / (c - b)) * a * (3 - 2 * a);\n    },\n    smootherstep: function smootherstep(a, b, c) {\n      return a <= b ? 0 : a >= c ? 1 : (a = (a - b) / (c - b)) * a * a * (a * (6 * a - 15) + 10);\n    },\n    randInt: function randInt(a, b) {\n      return a + Math.floor(Math.random() * (b - a + 1));\n    },\n    randFloat: function randFloat(a, b) {\n      return a + Math.random() * (b - a);\n    },\n    randFloatSpread: function randFloatSpread(a) {\n      return a * (.5 - Math.random());\n    },\n    degToRad: function degToRad(a) {\n      return a * yd.DEG2RAD;\n    },\n    radToDeg: function radToDeg(a) {\n      return a * yd.RAD2DEG;\n    },\n    isPowerOfTwo: function isPowerOfTwo(a) {\n      return 0 == (a & a - 1) && 0 !== a;\n    },\n    ceilPowerOfTwo: function ceilPowerOfTwo(a) {\n      return Math.pow(2, Math.ceil(Math.log(a) / Math.LN2));\n    },\n    floorPowerOfTwo: function floorPowerOfTwo(a) {\n      return Math.pow(2, Math.floor(Math.log(a) / Math.LN2));\n    }\n  };\n  Object.defineProperties(c.prototype, {\n    width: {\n      get: function get() {\n        return this.x;\n      },\n      set: function set(a) {\n        this.x = a;\n      }\n    },\n    height: {\n      get: function get() {\n        return this.y;\n      },\n      set: function set(a) {\n        this.y = a;\n      }\n    }\n  }), Object.assign(c.prototype, {\n    isVector2: !0,\n    set: function set(a, b) {\n      return this.x = a, this.y = b, this;\n    },\n    setScalar: function setScalar(a) {\n      return this.x = a, this.y = a, this;\n    },\n    setX: function setX(a) {\n      return this.x = a, this;\n    },\n    setY: function setY(a) {\n      return this.y = a, this;\n    },\n    setComponent: function setComponent(a, b) {\n      switch (a) {\n        case 0:\n          this.x = b;\n          break;\n\n        case 1:\n          this.y = b;\n          break;\n\n        default:\n          throw new Error(\"index is out of range: \" + a);\n      }\n\n      return this;\n    },\n    getComponent: function getComponent(a) {\n      switch (a) {\n        case 0:\n          return this.x;\n\n        case 1:\n          return this.y;\n\n        default:\n          throw new Error(\"index is out of range: \" + a);\n      }\n    },\n    clone: function clone() {\n      return new this.constructor(this.x, this.y);\n    },\n    copy: function copy(a) {\n      return this.x = a.x, this.y = a.y, this;\n    },\n    add: function add(a, b) {\n      return void 0 !== b ? (console.warn(\"THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.\"), this.addVectors(a, b)) : (this.x += a.x, this.y += a.y, this);\n    },\n    addScalar: function addScalar(a) {\n      return this.x += a, this.y += a, this;\n    },\n    addVectors: function addVectors(a, b) {\n      return this.x = a.x + b.x, this.y = a.y + b.y, this;\n    },\n    addScaledVector: function addScaledVector(a, b) {\n      return this.x += a.x * b, this.y += a.y * b, this;\n    },\n    sub: function sub(a, b) {\n      return void 0 !== b ? (console.warn(\"THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.\"), this.subVectors(a, b)) : (this.x -= a.x, this.y -= a.y, this);\n    },\n    subScalar: function subScalar(a) {\n      return this.x -= a, this.y -= a, this;\n    },\n    subVectors: function subVectors(a, b) {\n      return this.x = a.x - b.x, this.y = a.y - b.y, this;\n    },\n    multiply: function multiply(a) {\n      return this.x *= a.x, this.y *= a.y, this;\n    },\n    multiplyScalar: function multiplyScalar(a) {\n      return this.x *= a, this.y *= a, this;\n    },\n    divide: function divide(a) {\n      return this.x /= a.x, this.y /= a.y, this;\n    },\n    divideScalar: function divideScalar(a) {\n      return this.multiplyScalar(1 / a);\n    },\n    applyMatrix3: function applyMatrix3(a) {\n      var b = this.x,\n          c = this.y,\n          d = a.elements;\n      return this.x = d[0] * b + d[3] * c + d[6], this.y = d[1] * b + d[4] * c + d[7], this;\n    },\n    min: function min(a) {\n      return this.x = Math.min(this.x, a.x), this.y = Math.min(this.y, a.y), this;\n    },\n    max: function max(a) {\n      return this.x = Math.max(this.x, a.x), this.y = Math.max(this.y, a.y), this;\n    },\n    clamp: function clamp(a, b) {\n      return this.x = Math.max(a.x, Math.min(b.x, this.x)), this.y = Math.max(a.y, Math.min(b.y, this.y)), this;\n    },\n    clampScalar: function () {\n      var a = new c(),\n          b = new c();\n      return function (c, d) {\n        return a.set(c, c), b.set(d, d), this.clamp(a, b);\n      };\n    }(),\n    clampLength: function clampLength(a, b) {\n      var c = this.length();\n      return this.divideScalar(c || 1).multiplyScalar(Math.max(a, Math.min(b, c)));\n    },\n    floor: function floor() {\n      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;\n    },\n    ceil: function ceil() {\n      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;\n    },\n    round: function round() {\n      return this.x = Math.round(this.x), this.y = Math.round(this.y), this;\n    },\n    roundToZero: function roundToZero() {\n      return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this;\n    },\n    negate: function negate() {\n      return this.x = -this.x, this.y = -this.y, this;\n    },\n    dot: function dot(a) {\n      return this.x * a.x + this.y * a.y;\n    },\n    lengthSq: function lengthSq() {\n      return this.x * this.x + this.y * this.y;\n    },\n    length: function length() {\n      return Math.sqrt(this.x * this.x + this.y * this.y);\n    },\n    manhattanLength: function manhattanLength() {\n      return Math.abs(this.x) + Math.abs(this.y);\n    },\n    normalize: function normalize() {\n      return this.divideScalar(this.length() || 1);\n    },\n    angle: function angle() {\n      var a = Math.atan2(this.y, this.x);\n      return a < 0 && (a += 2 * Math.PI), a;\n    },\n    distanceTo: function distanceTo(a) {\n      return Math.sqrt(this.distanceToSquared(a));\n    },\n    distanceToSquared: function distanceToSquared(a) {\n      var b = this.x - a.x,\n          c = this.y - a.y;\n      return b * b + c * c;\n    },\n    manhattanDistanceTo: function manhattanDistanceTo(a) {\n      return Math.abs(this.x - a.x) + Math.abs(this.y - a.y);\n    },\n    setLength: function setLength(a) {\n      return this.normalize().multiplyScalar(a);\n    },\n    lerp: function lerp(a, b) {\n      return this.x += (a.x - this.x) * b, this.y += (a.y - this.y) * b, this;\n    },\n    lerpVectors: function lerpVectors(a, b, c) {\n      return this.subVectors(b, a).multiplyScalar(c).add(a);\n    },\n    equals: function equals(a) {\n      return a.x === this.x && a.y === this.y;\n    },\n    fromArray: function fromArray(a, b) {\n      return void 0 === b && (b = 0), this.x = a[b], this.y = a[b + 1], this;\n    },\n    toArray: function toArray(a, b) {\n      return void 0 === a && (a = []), void 0 === b && (b = 0), a[b] = this.x, a[b + 1] = this.y, a;\n    },\n    fromBufferAttribute: function fromBufferAttribute(a, b, c) {\n      return void 0 !== c && console.warn(\"THREE.Vector2: offset has been removed from .fromBufferAttribute().\"), this.x = a.getX(b), this.y = a.getY(b), this;\n    },\n    rotateAround: function rotateAround(a, b) {\n      var c = Math.cos(b),\n          d = Math.sin(b),\n          e = this.x - a.x,\n          f = this.y - a.y;\n      return this.x = e * c - f * d + a.x, this.y = e * d + f * c + a.y, this;\n    }\n  }), Object.assign(d.prototype, {\n    isMatrix4: !0,\n    set: function set(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) {\n      var q = this.elements;\n      return q[0] = a, q[4] = b, q[8] = c, q[12] = d, q[1] = e, q[5] = f, q[9] = g, q[13] = h, q[2] = i, q[6] = j, q[10] = k, q[14] = l, q[3] = m, q[7] = n, q[11] = o, q[15] = p, this;\n    },\n    identity: function identity() {\n      return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;\n    },\n    clone: function clone() {\n      return new d().fromArray(this.elements);\n    },\n    copy: function copy(a) {\n      var b = this.elements,\n          c = a.elements;\n      return b[0] = c[0], b[1] = c[1], b[2] = c[2], b[3] = c[3], b[4] = c[4], b[5] = c[5], b[6] = c[6], b[7] = c[7], b[8] = c[8], b[9] = c[9], b[10] = c[10], b[11] = c[11], b[12] = c[12], b[13] = c[13], b[14] = c[14], b[15] = c[15], this;\n    },\n    copyPosition: function copyPosition(a) {\n      var b = this.elements,\n          c = a.elements;\n      return b[12] = c[12], b[13] = c[13], b[14] = c[14], this;\n    },\n    extractBasis: function extractBasis(a, b, c) {\n      return a.setFromMatrixColumn(this, 0), b.setFromMatrixColumn(this, 1), c.setFromMatrixColumn(this, 2), this;\n    },\n    makeBasis: function makeBasis(a, b, c) {\n      return this.set(a.x, b.x, c.x, 0, a.y, b.y, c.y, 0, a.z, b.z, c.z, 0, 0, 0, 0, 1), this;\n    },\n    extractRotation: function () {\n      var a = new f();\n      return function (b) {\n        var c = this.elements,\n            d = b.elements,\n            e = 1 / a.setFromMatrixColumn(b, 0).length(),\n            f = 1 / a.setFromMatrixColumn(b, 1).length(),\n            g = 1 / a.setFromMatrixColumn(b, 2).length();\n        return c[0] = d[0] * e, c[1] = d[1] * e, c[2] = d[2] * e, c[4] = d[4] * f, c[5] = d[5] * f, c[6] = d[6] * f, c[8] = d[8] * g, c[9] = d[9] * g, c[10] = d[10] * g, this;\n      };\n    }(),\n    makeRotationFromEuler: function makeRotationFromEuler(a) {\n      a && a.isEuler || console.error(\"THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.\");\n      var b = this.elements,\n          c = a.x,\n          d = a.y,\n          e = a.z,\n          f = Math.cos(c),\n          g = Math.sin(c),\n          h = Math.cos(d),\n          i = Math.sin(d),\n          j = Math.cos(e),\n          k = Math.sin(e);\n\n      if (\"XYZ\" === a.order) {\n        var l = f * j,\n            m = f * k,\n            n = g * j,\n            o = g * k;\n        b[0] = h * j, b[4] = -h * k, b[8] = i, b[1] = m + n * i, b[5] = l - o * i, b[9] = -g * h, b[2] = o - l * i, b[6] = n + m * i, b[10] = f * h;\n      } else if (\"YXZ\" === a.order) {\n        var p = h * j,\n            q = h * k,\n            r = i * j,\n            s = i * k;\n        b[0] = p + s * g, b[4] = r * g - q, b[8] = f * i, b[1] = f * k, b[5] = f * j, b[9] = -g, b[2] = q * g - r, b[6] = s + p * g, b[10] = f * h;\n      } else if (\"ZXY\" === a.order) {\n        var p = h * j,\n            q = h * k,\n            r = i * j,\n            s = i * k;\n        b[0] = p - s * g, b[4] = -f * k, b[8] = r + q * g, b[1] = q + r * g, b[5] = f * j, b[9] = s - p * g, b[2] = -f * i, b[6] = g, b[10] = f * h;\n      } else if (\"ZYX\" === a.order) {\n        var l = f * j,\n            m = f * k,\n            n = g * j,\n            o = g * k;\n        b[0] = h * j, b[4] = n * i - m, b[8] = l * i + o, b[1] = h * k, b[5] = o * i + l, b[9] = m * i - n, b[2] = -i, b[6] = g * h, b[10] = f * h;\n      } else if (\"YZX\" === a.order) {\n        var t = f * h,\n            u = f * i,\n            v = g * h,\n            w = g * i;\n        b[0] = h * j, b[4] = w - t * k, b[8] = v * k + u, b[1] = k, b[5] = f * j, b[9] = -g * j, b[2] = -i * j, b[6] = u * k + v, b[10] = t - w * k;\n      } else if (\"XZY\" === a.order) {\n        var t = f * h,\n            u = f * i,\n            v = g * h,\n            w = g * i;\n        b[0] = h * j, b[4] = -k, b[8] = i * j, b[1] = t * k + w, b[5] = f * j, b[9] = u * k - v, b[2] = v * k - u, b[6] = g * j, b[10] = w * k + t;\n      }\n\n      return b[3] = 0, b[7] = 0, b[11] = 0, b[12] = 0, b[13] = 0, b[14] = 0, b[15] = 1, this;\n    },\n    makeRotationFromQuaternion: function makeRotationFromQuaternion(a) {\n      var b = this.elements,\n          c = a._x,\n          d = a._y,\n          e = a._z,\n          f = a._w,\n          g = c + c,\n          h = d + d,\n          i = e + e,\n          j = c * g,\n          k = c * h,\n          l = c * i,\n          m = d * h,\n          n = d * i,\n          o = e * i,\n          p = f * g,\n          q = f * h,\n          r = f * i;\n      return b[0] = 1 - (m + o), b[4] = k - r, b[8] = l + q, b[1] = k + r, b[5] = 1 - (j + o), b[9] = n - p, b[2] = l - q, b[6] = n + p, b[10] = 1 - (j + m), b[3] = 0, b[7] = 0, b[11] = 0, b[12] = 0, b[13] = 0, b[14] = 0, b[15] = 1, this;\n    },\n    lookAt: function () {\n      var a = new f(),\n          b = new f(),\n          c = new f();\n      return function (d, e, f) {\n        var g = this.elements;\n        return c.subVectors(d, e), 0 === c.lengthSq() && (c.z = 1), c.normalize(), a.crossVectors(f, c), 0 === a.lengthSq() && (1 === Math.abs(f.z) ? c.x += 1e-4 : c.z += 1e-4, c.normalize(), a.crossVectors(f, c)), a.normalize(), b.crossVectors(c, a), g[0] = a.x, g[4] = b.x, g[8] = c.x, g[1] = a.y, g[5] = b.y, g[9] = c.y, g[2] = a.z, g[6] = b.z, g[10] = c.z, this;\n      };\n    }(),\n    multiply: function multiply(a, b) {\n      return void 0 !== b ? (console.warn(\"THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.\"), this.multiplyMatrices(a, b)) : this.multiplyMatrices(this, a);\n    },\n    premultiply: function premultiply(a) {\n      return this.multiplyMatrices(a, this);\n    },\n    multiplyMatrices: function multiplyMatrices(a, b) {\n      var c = a.elements,\n          d = b.elements,\n          e = this.elements,\n          f = c[0],\n          g = c[4],\n          h = c[8],\n          i = c[12],\n          j = c[1],\n          k = c[5],\n          l = c[9],\n          m = c[13],\n          n = c[2],\n          o = c[6],\n          p = c[10],\n          q = c[14],\n          r = c[3],\n          s = c[7],\n          t = c[11],\n          u = c[15],\n          v = d[0],\n          w = d[4],\n          x = d[8],\n          y = d[12],\n          z = d[1],\n          A = d[5],\n          B = d[9],\n          C = d[13],\n          D = d[2],\n          E = d[6],\n          F = d[10],\n          G = d[14],\n          H = d[3],\n          I = d[7],\n          J = d[11],\n          K = d[15];\n      return e[0] = f * v + g * z + h * D + i * H, e[4] = f * w + g * A + h * E + i * I, e[8] = f * x + g * B + h * F + i * J, e[12] = f * y + g * C + h * G + i * K, e[1] = j * v + k * z + l * D + m * H, e[5] = j * w + k * A + l * E + m * I, e[9] = j * x + k * B + l * F + m * J, e[13] = j * y + k * C + l * G + m * K, e[2] = n * v + o * z + p * D + q * H, e[6] = n * w + o * A + p * E + q * I, e[10] = n * x + o * B + p * F + q * J, e[14] = n * y + o * C + p * G + q * K, e[3] = r * v + s * z + t * D + u * H, e[7] = r * w + s * A + t * E + u * I, e[11] = r * x + s * B + t * F + u * J, e[15] = r * y + s * C + t * G + u * K, this;\n    },\n    multiplyScalar: function multiplyScalar(a) {\n      var b = this.elements;\n      return b[0] *= a, b[4] *= a, b[8] *= a, b[12] *= a, b[1] *= a, b[5] *= a, b[9] *= a, b[13] *= a, b[2] *= a, b[6] *= a, b[10] *= a, b[14] *= a, b[3] *= a, b[7] *= a, b[11] *= a, b[15] *= a, this;\n    },\n    applyToBufferAttribute: function () {\n      var a = new f();\n      return function (b) {\n        for (var c = 0, d = b.count; c < d; c++) {\n          a.x = b.getX(c), a.y = b.getY(c), a.z = b.getZ(c), a.applyMatrix4(this), b.setXYZ(c, a.x, a.y, a.z);\n        }\n\n        return b;\n      };\n    }(),\n    determinant: function determinant() {\n      var a = this.elements,\n          b = a[0],\n          c = a[4],\n          d = a[8],\n          e = a[12],\n          f = a[1],\n          g = a[5],\n          h = a[9],\n          i = a[13],\n          j = a[2],\n          k = a[6],\n          l = a[10],\n          m = a[14];\n      return a[3] * (+e * h * k - d * i * k - e * g * l + c * i * l + d * g * m - c * h * m) + a[7] * (+b * h * m - b * i * l + e * f * l - d * f * m + d * i * j - e * h * j) + a[11] * (+b * i * k - b * g * m - e * f * k + c * f * m + e * g * j - c * i * j) + a[15] * (-d * g * j - b * h * k + b * g * l + d * f * k - c * f * l + c * h * j);\n    },\n    transpose: function transpose() {\n      var a,\n          b = this.elements;\n      return a = b[1], b[1] = b[4], b[4] = a, a = b[2], b[2] = b[8], b[8] = a, a = b[6], b[6] = b[9], b[9] = a, a = b[3], b[3] = b[12], b[12] = a, a = b[7], b[7] = b[13], b[13] = a, a = b[11], b[11] = b[14], b[14] = a, this;\n    },\n    setPosition: function setPosition(a) {\n      var b = this.elements;\n      return b[12] = a.x, b[13] = a.y, b[14] = a.z, this;\n    },\n    getInverse: function getInverse(a, b) {\n      var c = this.elements,\n          d = a.elements,\n          e = d[0],\n          f = d[1],\n          g = d[2],\n          h = d[3],\n          i = d[4],\n          j = d[5],\n          k = d[6],\n          l = d[7],\n          m = d[8],\n          n = d[9],\n          o = d[10],\n          p = d[11],\n          q = d[12],\n          r = d[13],\n          s = d[14],\n          t = d[15],\n          u = n * s * l - r * o * l + r * k * p - j * s * p - n * k * t + j * o * t,\n          v = q * o * l - m * s * l - q * k * p + i * s * p + m * k * t - i * o * t,\n          w = m * r * l - q * n * l + q * j * p - i * r * p - m * j * t + i * n * t,\n          x = q * n * k - m * r * k - q * j * o + i * r * o + m * j * s - i * n * s,\n          y = e * u + f * v + g * w + h * x;\n\n      if (0 === y) {\n        var z = \"THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0\";\n        if (!0 === b) throw new Error(z);\n        return console.warn(z), this.identity();\n      }\n\n      var A = 1 / y;\n      return c[0] = u * A, c[1] = (r * o * h - n * s * h - r * g * p + f * s * p + n * g * t - f * o * t) * A, c[2] = (j * s * h - r * k * h + r * g * l - f * s * l - j * g * t + f * k * t) * A, c[3] = (n * k * h - j * o * h - n * g * l + f * o * l + j * g * p - f * k * p) * A, c[4] = v * A, c[5] = (m * s * h - q * o * h + q * g * p - e * s * p - m * g * t + e * o * t) * A, c[6] = (q * k * h - i * s * h - q * g * l + e * s * l + i * g * t - e * k * t) * A, c[7] = (i * o * h - m * k * h + m * g * l - e * o * l - i * g * p + e * k * p) * A, c[8] = w * A, c[9] = (q * n * h - m * r * h - q * f * p + e * r * p + m * f * t - e * n * t) * A, c[10] = (i * r * h - q * j * h + q * f * l - e * r * l - i * f * t + e * j * t) * A, c[11] = (m * j * h - i * n * h - m * f * l + e * n * l + i * f * p - e * j * p) * A, c[12] = x * A, c[13] = (m * r * g - q * n * g + q * f * o - e * r * o - m * f * s + e * n * s) * A, c[14] = (q * j * g - i * r * g - q * f * k + e * r * k + i * f * s - e * j * s) * A, c[15] = (i * n * g - m * j * g + m * f * k - e * n * k - i * f * o + e * j * o) * A, this;\n    },\n    scale: function scale(a) {\n      var b = this.elements,\n          c = a.x,\n          d = a.y,\n          e = a.z;\n      return b[0] *= c, b[4] *= d, b[8] *= e, b[1] *= c, b[5] *= d, b[9] *= e, b[2] *= c, b[6] *= d, b[10] *= e, b[3] *= c, b[7] *= d, b[11] *= e, this;\n    },\n    getMaxScaleOnAxis: function getMaxScaleOnAxis() {\n      var a = this.elements,\n          b = a[0] * a[0] + a[1] * a[1] + a[2] * a[2],\n          c = a[4] * a[4] + a[5] * a[5] + a[6] * a[6],\n          d = a[8] * a[8] + a[9] * a[9] + a[10] * a[10];\n      return Math.sqrt(Math.max(b, c, d));\n    },\n    makeTranslation: function makeTranslation(a, b, c) {\n      return this.set(1, 0, 0, a, 0, 1, 0, b, 0, 0, 1, c, 0, 0, 0, 1), this;\n    },\n    makeRotationX: function makeRotationX(a) {\n      var b = Math.cos(a),\n          c = Math.sin(a);\n      return this.set(1, 0, 0, 0, 0, b, -c, 0, 0, c, b, 0, 0, 0, 0, 1), this;\n    },\n    makeRotationY: function makeRotationY(a) {\n      var b = Math.cos(a),\n          c = Math.sin(a);\n      return this.set(b, 0, c, 0, 0, 1, 0, 0, -c, 0, b, 0, 0, 0, 0, 1), this;\n    },\n    makeRotationZ: function makeRotationZ(a) {\n      var b = Math.cos(a),\n          c = Math.sin(a);\n      return this.set(b, -c, 0, 0, c, b, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;\n    },\n    makeRotationAxis: function makeRotationAxis(a, b) {\n      var c = Math.cos(b),\n          d = Math.sin(b),\n          e = 1 - c,\n          f = a.x,\n          g = a.y,\n          h = a.z,\n          i = e * f,\n          j = e * g;\n      return this.set(i * f + c, i * g - d * h, i * h + d * g, 0, i * g + d * h, j * g + c, j * h - d * f, 0, i * h - d * g, j * h + d * f, e * h * h + c, 0, 0, 0, 0, 1), this;\n    },\n    makeScale: function makeScale(a, b, c) {\n      return this.set(a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, 0, 0, 0, 1), this;\n    },\n    makeShear: function makeShear(a, b, c) {\n      return this.set(1, b, c, 0, a, 1, c, 0, a, b, 1, 0, 0, 0, 0, 1), this;\n    },\n    compose: function compose(a, b, c) {\n      return this.makeRotationFromQuaternion(b), this.scale(c), this.setPosition(a), this;\n    },\n    decompose: function () {\n      var a = new f(),\n          b = new d();\n      return function (c, d, e) {\n        var f = this.elements,\n            g = a.set(f[0], f[1], f[2]).length(),\n            h = a.set(f[4], f[5], f[6]).length(),\n            i = a.set(f[8], f[9], f[10]).length();\n        this.determinant() < 0 && (g = -g), c.x = f[12], c.y = f[13], c.z = f[14], b.copy(this);\n        var j = 1 / g,\n            k = 1 / h,\n            l = 1 / i;\n        return b.elements[0] *= j, b.elements[1] *= j, b.elements[2] *= j, b.elements[4] *= k, b.elements[5] *= k, b.elements[6] *= k, b.elements[8] *= l, b.elements[9] *= l, b.elements[10] *= l, d.setFromRotationMatrix(b), e.x = g, e.y = h, e.z = i, this;\n      };\n    }(),\n    makePerspective: function makePerspective(a, b, c, d, e, f) {\n      void 0 === f && console.warn(\"THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.\");\n      var g = this.elements,\n          h = 2 * e / (b - a),\n          i = 2 * e / (c - d),\n          j = (b + a) / (b - a),\n          k = (c + d) / (c - d),\n          l = -(f + e) / (f - e),\n          m = -2 * f * e / (f - e);\n      return g[0] = h, g[4] = 0, g[8] = j, g[12] = 0, g[1] = 0, g[5] = i, g[9] = k, g[13] = 0, g[2] = 0, g[6] = 0, g[10] = l, g[14] = m, g[3] = 0, g[7] = 0, g[11] = -1, g[15] = 0, this;\n    },\n    makeOrthographic: function makeOrthographic(a, b, c, d, e, f) {\n      var g = this.elements,\n          h = 1 / (b - a),\n          i = 1 / (c - d),\n          j = 1 / (f - e),\n          k = (b + a) * h,\n          l = (c + d) * i,\n          m = (f + e) * j;\n      return g[0] = 2 * h, g[4] = 0, g[8] = 0, g[12] = -k, g[1] = 0, g[5] = 2 * i, g[9] = 0, g[13] = -l, g[2] = 0, g[6] = 0, g[10] = -2 * j, g[14] = -m, g[3] = 0, g[7] = 0, g[11] = 0, g[15] = 1, this;\n    },\n    equals: function equals(a) {\n      for (var b = this.elements, c = a.elements, d = 0; d < 16; d++) {\n        if (b[d] !== c[d]) return !1;\n      }\n\n      return !0;\n    },\n    fromArray: function fromArray(a, b) {\n      void 0 === b && (b = 0);\n\n      for (var c = 0; c < 16; c++) {\n        this.elements[c] = a[c + b];\n      }\n\n      return this;\n    },\n    toArray: function toArray(a, b) {\n      void 0 === a && (a = []), void 0 === b && (b = 0);\n      var c = this.elements;\n      return a[b] = c[0], a[b + 1] = c[1], a[b + 2] = c[2], a[b + 3] = c[3], a[b + 4] = c[4], a[b + 5] = c[5], a[b + 6] = c[6], a[b + 7] = c[7], a[b + 8] = c[8], a[b + 9] = c[9], a[b + 10] = c[10], a[b + 11] = c[11], a[b + 12] = c[12], a[b + 13] = c[13], a[b + 14] = c[14], a[b + 15] = c[15], a;\n    }\n  }), Object.assign(e, {\n    slerp: function slerp(a, b, c, d) {\n      return c.copy(a).slerp(b, d);\n    },\n    slerpFlat: function slerpFlat(a, b, c, d, e, f, g) {\n      var h = c[d + 0],\n          i = c[d + 1],\n          j = c[d + 2],\n          k = c[d + 3],\n          l = e[f + 0],\n          m = e[f + 1],\n          n = e[f + 2],\n          o = e[f + 3];\n\n      if (k !== o || h !== l || i !== m || j !== n) {\n        var p = 1 - g,\n            q = h * l + i * m + j * n + k * o,\n            r = q >= 0 ? 1 : -1,\n            s = 1 - q * q;\n\n        if (s > Number.EPSILON) {\n          var t = Math.sqrt(s),\n              u = Math.atan2(t, q * r);\n          p = Math.sin(p * u) / t, g = Math.sin(g * u) / t;\n        }\n\n        var v = g * r;\n\n        if (h = h * p + l * v, i = i * p + m * v, j = j * p + n * v, k = k * p + o * v, p === 1 - g) {\n          var w = 1 / Math.sqrt(h * h + i * i + j * j + k * k);\n          h *= w, i *= w, j *= w, k *= w;\n        }\n      }\n\n      a[b] = h, a[b + 1] = i, a[b + 2] = j, a[b + 3] = k;\n    }\n  }), Object.defineProperties(e.prototype, {\n    x: {\n      get: function get() {\n        return this._x;\n      },\n      set: function set(a) {\n        this._x = a, this.onChangeCallback();\n      }\n    },\n    y: {\n      get: function get() {\n        return this._y;\n      },\n      set: function set(a) {\n        this._y = a, this.onChangeCallback();\n      }\n    },\n    z: {\n      get: function get() {\n        return this._z;\n      },\n      set: function set(a) {\n        this._z = a, this.onChangeCallback();\n      }\n    },\n    w: {\n      get: function get() {\n        return this._w;\n      },\n      set: function set(a) {\n        this._w = a, this.onChangeCallback();\n      }\n    }\n  }), Object.assign(e.prototype, {\n    set: function set(a, b, c, d) {\n      return this._x = a, this._y = b, this._z = c, this._w = d, this.onChangeCallback(), this;\n    },\n    clone: function clone() {\n      return new this.constructor(this._x, this._y, this._z, this._w);\n    },\n    copy: function copy(a) {\n      return this._x = a.x, this._y = a.y, this._z = a.z, this._w = a.w, this.onChangeCallback(), this;\n    },\n    setFromEuler: function setFromEuler(a, b) {\n      if (!a || !a.isEuler) throw new Error(\"THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.\");\n      var c = a._x,\n          d = a._y,\n          e = a._z,\n          f = a.order,\n          g = Math.cos,\n          h = Math.sin,\n          i = g(c / 2),\n          j = g(d / 2),\n          k = g(e / 2),\n          l = h(c / 2),\n          m = h(d / 2),\n          n = h(e / 2);\n      return \"XYZ\" === f ? (this._x = l * j * k + i * m * n, this._y = i * m * k - l * j * n, this._z = i * j * n + l * m * k, this._w = i * j * k - l * m * n) : \"YXZ\" === f ? (this._x = l * j * k + i * m * n, this._y = i * m * k - l * j * n, this._z = i * j * n - l * m * k, this._w = i * j * k + l * m * n) : \"ZXY\" === f ? (this._x = l * j * k - i * m * n, this._y = i * m * k + l * j * n, this._z = i * j * n + l * m * k, this._w = i * j * k - l * m * n) : \"ZYX\" === f ? (this._x = l * j * k - i * m * n, this._y = i * m * k + l * j * n, this._z = i * j * n - l * m * k, this._w = i * j * k + l * m * n) : \"YZX\" === f ? (this._x = l * j * k + i * m * n, this._y = i * m * k + l * j * n, this._z = i * j * n - l * m * k, this._w = i * j * k - l * m * n) : \"XZY\" === f && (this._x = l * j * k - i * m * n, this._y = i * m * k - l * j * n, this._z = i * j * n + l * m * k, this._w = i * j * k + l * m * n), !1 !== b && this.onChangeCallback(), this;\n    },\n    setFromAxisAngle: function setFromAxisAngle(a, b) {\n      var c = b / 2,\n          d = Math.sin(c);\n      return this._x = a.x * d, this._y = a.y * d, this._z = a.z * d, this._w = Math.cos(c), this.onChangeCallback(), this;\n    },\n    setFromRotationMatrix: function setFromRotationMatrix(a) {\n      var b,\n          c = a.elements,\n          d = c[0],\n          e = c[4],\n          f = c[8],\n          g = c[1],\n          h = c[5],\n          i = c[9],\n          j = c[2],\n          k = c[6],\n          l = c[10],\n          m = d + h + l;\n      return m > 0 ? (b = .5 / Math.sqrt(m + 1), this._w = .25 / b, this._x = (k - i) * b, this._y = (f - j) * b, this._z = (g - e) * b) : d > h && d > l ? (b = 2 * Math.sqrt(1 + d - h - l), this._w = (k - i) / b, this._x = .25 * b, this._y = (e + g) / b, this._z = (f + j) / b) : h > l ? (b = 2 * Math.sqrt(1 + h - d - l), this._w = (f - j) / b, this._x = (e + g) / b, this._y = .25 * b, this._z = (i + k) / b) : (b = 2 * Math.sqrt(1 + l - d - h), this._w = (g - e) / b, this._x = (f + j) / b, this._y = (i + k) / b, this._z = .25 * b), this.onChangeCallback(), this;\n    },\n    setFromUnitVectors: function () {\n      var a,\n          b = new f();\n      return function (c, d) {\n        return void 0 === b && (b = new f()), a = c.dot(d) + 1, a < 1e-6 ? (a = 0, Math.abs(c.x) > Math.abs(c.z) ? b.set(-c.y, c.x, 0) : b.set(0, -c.z, c.y)) : b.crossVectors(c, d), this._x = b.x, this._y = b.y, this._z = b.z, this._w = a, this.normalize();\n      };\n    }(),\n    inverse: function inverse() {\n      return this.conjugate().normalize();\n    },\n    conjugate: function conjugate() {\n      return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this;\n    },\n    dot: function dot(a) {\n      return this._x * a._x + this._y * a._y + this._z * a._z + this._w * a._w;\n    },\n    lengthSq: function lengthSq() {\n      return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n    },\n    length: function length() {\n      return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);\n    },\n    normalize: function normalize() {\n      var a = this.length();\n      return 0 === a ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (a = 1 / a, this._x = this._x * a, this._y = this._y * a, this._z = this._z * a, this._w = this._w * a), this.onChangeCallback(), this;\n    },\n    multiply: function multiply(a, b) {\n      return void 0 !== b ? (console.warn(\"THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.\"), this.multiplyQuaternions(a, b)) : this.multiplyQuaternions(this, a);\n    },\n    premultiply: function premultiply(a) {\n      return this.multiplyQuaternions(a, this);\n    },\n    multiplyQuaternions: function multiplyQuaternions(a, b) {\n      var c = a._x,\n          d = a._y,\n          e = a._z,\n          f = a._w,\n          g = b._x,\n          h = b._y,\n          i = b._z,\n          j = b._w;\n      return this._x = c * j + f * g + d * i - e * h, this._y = d * j + f * h + e * g - c * i, this._z = e * j + f * i + c * h - d * g, this._w = f * j - c * g - d * h - e * i, this.onChangeCallback(), this;\n    },\n    slerp: function slerp(a, b) {\n      if (0 === b) return this;\n      if (1 === b) return this.copy(a);\n      var c = this._x,\n          d = this._y,\n          e = this._z,\n          f = this._w,\n          g = f * a._w + c * a._x + d * a._y + e * a._z;\n      if (g < 0 ? (this._w = -a._w, this._x = -a._x, this._y = -a._y, this._z = -a._z, g = -g) : this.copy(a), g >= 1) return this._w = f, this._x = c, this._y = d, this._z = e, this;\n      var h = Math.sqrt(1 - g * g);\n      if (Math.abs(h) < .001) return this._w = .5 * (f + this._w), this._x = .5 * (c + this._x), this._y = .5 * (d + this._y), this._z = .5 * (e + this._z), this;\n      var i = Math.atan2(h, g),\n          j = Math.sin((1 - b) * i) / h,\n          k = Math.sin(b * i) / h;\n      return this._w = f * j + this._w * k, this._x = c * j + this._x * k, this._y = d * j + this._y * k, this._z = e * j + this._z * k, this.onChangeCallback(), this;\n    },\n    equals: function equals(a) {\n      return a._x === this._x && a._y === this._y && a._z === this._z && a._w === this._w;\n    },\n    fromArray: function fromArray(a, b) {\n      return void 0 === b && (b = 0), this._x = a[b], this._y = a[b + 1], this._z = a[b + 2], this._w = a[b + 3], this.onChangeCallback(), this;\n    },\n    toArray: function toArray(a, b) {\n      return void 0 === a && (a = []), void 0 === b && (b = 0), a[b] = this._x, a[b + 1] = this._y, a[b + 2] = this._z, a[b + 3] = this._w, a;\n    },\n    onChange: function onChange(a) {\n      return this.onChangeCallback = a, this;\n    },\n    onChangeCallback: function onChangeCallback() {}\n  }), Object.assign(f.prototype, {\n    isVector3: !0,\n    set: function set(a, b, c) {\n      return this.x = a, this.y = b, this.z = c, this;\n    },\n    setScalar: function setScalar(a) {\n      return this.x = a, this.y = a, this.z = a, this;\n    },\n    setX: function setX(a) {\n      return this.x = a, this;\n    },\n    setY: function setY(a) {\n      return this.y = a, this;\n    },\n    setZ: function setZ(a) {\n      return this.z = a, this;\n    },\n    setComponent: function setComponent(a, b) {\n      switch (a) {\n        case 0:\n          this.x = b;\n          break;\n\n        case 1:\n          this.y = b;\n          break;\n\n        case 2:\n          this.z = b;\n          break;\n\n        default:\n          throw new Error(\"index is out of range: \" + a);\n      }\n\n      return this;\n    },\n    getComponent: function getComponent(a) {\n      switch (a) {\n        case 0:\n          return this.x;\n\n        case 1:\n          return this.y;\n\n        case 2:\n          return this.z;\n\n        default:\n          throw new Error(\"index is out of range: \" + a);\n      }\n    },\n    clone: function clone() {\n      return new this.constructor(this.x, this.y, this.z);\n    },\n    copy: function copy(a) {\n      return this.x = a.x, this.y = a.y, this.z = a.z, this;\n    },\n    add: function add(a, b) {\n      return void 0 !== b ? (console.warn(\"THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.\"), this.addVectors(a, b)) : (this.x += a.x, this.y += a.y, this.z += a.z, this);\n    },\n    addScalar: function addScalar(a) {\n      return this.x += a, this.y += a, this.z += a, this;\n    },\n    addVectors: function addVectors(a, b) {\n      return this.x = a.x + b.x, this.y = a.y + b.y, this.z = a.z + b.z, this;\n    },\n    addScaledVector: function addScaledVector(a, b) {\n      return this.x += a.x * b, this.y += a.y * b, this.z += a.z * b, this;\n    },\n    sub: function sub(a, b) {\n      return void 0 !== b ? (console.warn(\"THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.\"), this.subVectors(a, b)) : (this.x -= a.x, this.y -= a.y, this.z -= a.z, this);\n    },\n    subScalar: function subScalar(a) {\n      return this.x -= a, this.y -= a, this.z -= a, this;\n    },\n    subVectors: function subVectors(a, b) {\n      return this.x = a.x - b.x, this.y = a.y - b.y, this.z = a.z - b.z, this;\n    },\n    multiply: function multiply(a, b) {\n      return void 0 !== b ? (console.warn(\"THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.\"), this.multiplyVectors(a, b)) : (this.x *= a.x, this.y *= a.y, this.z *= a.z, this);\n    },\n    multiplyScalar: function multiplyScalar(a) {\n      return this.x *= a, this.y *= a, this.z *= a, this;\n    },\n    multiplyVectors: function multiplyVectors(a, b) {\n      return this.x = a.x * b.x, this.y = a.y * b.y, this.z = a.z * b.z, this;\n    },\n    applyEuler: function () {\n      var a = new e();\n      return function (b) {\n        return b && b.isEuler || console.error(\"THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.\"), this.applyQuaternion(a.setFromEuler(b));\n      };\n    }(),\n    applyAxisAngle: function () {\n      var a = new e();\n      return function (b, c) {\n        return this.applyQuaternion(a.setFromAxisAngle(b, c));\n      };\n    }(),\n    applyMatrix3: function applyMatrix3(a) {\n      var b = this.x,\n          c = this.y,\n          d = this.z,\n          e = a.elements;\n      return this.x = e[0] * b + e[3] * c + e[6] * d, this.y = e[1] * b + e[4] * c + e[7] * d, this.z = e[2] * b + e[5] * c + e[8] * d, this;\n    },\n    applyMatrix4: function applyMatrix4(a) {\n      var b = this.x,\n          c = this.y,\n          d = this.z,\n          e = a.elements,\n          f = 1 / (e[3] * b + e[7] * c + e[11] * d + e[15]);\n      return this.x = (e[0] * b + e[4] * c + e[8] * d + e[12]) * f, this.y = (e[1] * b + e[5] * c + e[9] * d + e[13]) * f, this.z = (e[2] * b + e[6] * c + e[10] * d + e[14]) * f, this;\n    },\n    applyQuaternion: function applyQuaternion(a) {\n      var b = this.x,\n          c = this.y,\n          d = this.z,\n          e = a.x,\n          f = a.y,\n          g = a.z,\n          h = a.w,\n          i = h * b + f * d - g * c,\n          j = h * c + g * b - e * d,\n          k = h * d + e * c - f * b,\n          l = -e * b - f * c - g * d;\n      return this.x = i * h + l * -e + j * -g - k * -f, this.y = j * h + l * -f + k * -e - i * -g, this.z = k * h + l * -g + i * -f - j * -e, this;\n    },\n    project: function () {\n      var a = new d();\n      return function (b) {\n        return a.multiplyMatrices(b.projectionMatrix, a.getInverse(b.matrixWorld)), this.applyMatrix4(a);\n      };\n    }(),\n    unproject: function () {\n      var a = new d();\n      return function (b) {\n        return a.multiplyMatrices(b.matrixWorld, a.getInverse(b.projectionMatrix)), this.applyMatrix4(a);\n      };\n    }(),\n    transformDirection: function transformDirection(a) {\n      var b = this.x,\n          c = this.y,\n          d = this.z,\n          e = a.elements;\n      return this.x = e[0] * b + e[4] * c + e[8] * d, this.y = e[1] * b + e[5] * c + e[9] * d, this.z = e[2] * b + e[6] * c + e[10] * d, this.normalize();\n    },\n    divide: function divide(a) {\n      return this.x /= a.x, this.y /= a.y, this.z /= a.z, this;\n    },\n    divideScalar: function divideScalar(a) {\n      return this.multiplyScalar(1 / a);\n    },\n    min: function min(a) {\n      return this.x = Math.min(this.x, a.x), this.y = Math.min(this.y, a.y), this.z = Math.min(this.z, a.z), this;\n    },\n    max: function max(a) {\n      return this.x = Math.max(this.x, a.x), this.y = Math.max(this.y, a.y), this.z = Math.max(this.z, a.z), this;\n    },\n    clamp: function clamp(a, b) {\n      return this.x = Math.max(a.x, Math.min(b.x, this.x)), this.y = Math.max(a.y, Math.min(b.y, this.y)), this.z = Math.max(a.z, Math.min(b.z, this.z)), this;\n    },\n    clampScalar: function () {\n      var a = new f(),\n          b = new f();\n      return function (c, d) {\n        return a.set(c, c, c), b.set(d, d, d), this.clamp(a, b);\n      };\n    }(),\n    clampLength: function clampLength(a, b) {\n      var c = this.length();\n      return this.divideScalar(c || 1).multiplyScalar(Math.max(a, Math.min(b, c)));\n    },\n    floor: function floor() {\n      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;\n    },\n    ceil: function ceil() {\n      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;\n    },\n    round: function round() {\n      return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;\n    },\n    roundToZero: function roundToZero() {\n      return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this;\n    },\n    negate: function negate() {\n      return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;\n    },\n    dot: function dot(a) {\n      return this.x * a.x + this.y * a.y + this.z * a.z;\n    },\n    lengthSq: function lengthSq() {\n      return this.x * this.x + this.y * this.y + this.z * this.z;\n    },\n    length: function length() {\n      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n    },\n    manhattanLength: function manhattanLength() {\n      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);\n    },\n    normalize: function normalize() {\n      return this.divideScalar(this.length() || 1);\n    },\n    setLength: function setLength(a) {\n      return this.normalize().multiplyScalar(a);\n    },\n    lerp: function lerp(a, b) {\n      return this.x += (a.x - this.x) * b, this.y += (a.y - this.y) * b, this.z += (a.z - this.z) * b, this;\n    },\n    lerpVectors: function lerpVectors(a, b, c) {\n      return this.subVectors(b, a).multiplyScalar(c).add(a);\n    },\n    cross: function cross(a, b) {\n      return void 0 !== b ? (console.warn(\"THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.\"), this.crossVectors(a, b)) : this.crossVectors(this, a);\n    },\n    crossVectors: function crossVectors(a, b) {\n      var c = a.x,\n          d = a.y,\n          e = a.z,\n          f = b.x,\n          g = b.y,\n          h = b.z;\n      return this.x = d * h - e * g, this.y = e * f - c * h, this.z = c * g - d * f, this;\n    },\n    projectOnVector: function projectOnVector(a) {\n      var b = a.dot(this) / a.lengthSq();\n      return this.copy(a).multiplyScalar(b);\n    },\n    projectOnPlane: function () {\n      var a = new f();\n      return function (b) {\n        return a.copy(this).projectOnVector(b), this.sub(a);\n      };\n    }(),\n    reflect: function () {\n      var a = new f();\n      return function (b) {\n        return this.sub(a.copy(b).multiplyScalar(2 * this.dot(b)));\n      };\n    }(),\n    angleTo: function angleTo(a) {\n      var b = this.dot(a) / Math.sqrt(this.lengthSq() * a.lengthSq());\n      return Math.acos(yd.clamp(b, -1, 1));\n    },\n    distanceTo: function distanceTo(a) {\n      return Math.sqrt(this.distanceToSquared(a));\n    },\n    distanceToSquared: function distanceToSquared(a) {\n      var b = this.x - a.x,\n          c = this.y - a.y,\n          d = this.z - a.z;\n      return b * b + c * c + d * d;\n    },\n    manhattanDistanceTo: function manhattanDistanceTo(a) {\n      return Math.abs(this.x - a.x) + Math.abs(this.y - a.y) + Math.abs(this.z - a.z);\n    },\n    setFromSpherical: function setFromSpherical(a) {\n      var b = Math.sin(a.phi) * a.radius;\n      return this.x = b * Math.sin(a.theta), this.y = Math.cos(a.phi) * a.radius, this.z = b * Math.cos(a.theta), this;\n    },\n    setFromCylindrical: function setFromCylindrical(a) {\n      return this.x = a.radius * Math.sin(a.theta), this.y = a.y, this.z = a.radius * Math.cos(a.theta), this;\n    },\n    setFromMatrixPosition: function setFromMatrixPosition(a) {\n      var b = a.elements;\n      return this.x = b[12], this.y = b[13], this.z = b[14], this;\n    },\n    setFromMatrixScale: function setFromMatrixScale(a) {\n      var b = this.setFromMatrixColumn(a, 0).length(),\n          c = this.setFromMatrixColumn(a, 1).length(),\n          d = this.setFromMatrixColumn(a, 2).length();\n      return this.x = b, this.y = c, this.z = d, this;\n    },\n    setFromMatrixColumn: function setFromMatrixColumn(a, b) {\n      return this.fromArray(a.elements, 4 * b);\n    },\n    equals: function equals(a) {\n      return a.x === this.x && a.y === this.y && a.z === this.z;\n    },\n    fromArray: function fromArray(a, b) {\n      return void 0 === b && (b = 0), this.x = a[b], this.y = a[b + 1], this.z = a[b + 2], this;\n    },\n    toArray: function toArray(a, b) {\n      return void 0 === a && (a = []), void 0 === b && (b = 0), a[b] = this.x, a[b + 1] = this.y, a[b + 2] = this.z, a;\n    },\n    fromBufferAttribute: function fromBufferAttribute(a, b, c) {\n      return void 0 !== c && console.warn(\"THREE.Vector3: offset has been removed from .fromBufferAttribute().\"), this.x = a.getX(b), this.y = a.getY(b), this.z = a.getZ(b), this;\n    }\n  }), Object.assign(g.prototype, {\n    isMatrix3: !0,\n    set: function set(a, b, c, d, e, f, g, h, i) {\n      var j = this.elements;\n      return j[0] = a, j[1] = d, j[2] = g, j[3] = b, j[4] = e, j[5] = h, j[6] = c, j[7] = f, j[8] = i, this;\n    },\n    identity: function identity() {\n      return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;\n    },\n    clone: function clone() {\n      return new this.constructor().fromArray(this.elements);\n    },\n    copy: function copy(a) {\n      var b = this.elements,\n          c = a.elements;\n      return b[0] = c[0], b[1] = c[1], b[2] = c[2], b[3] = c[3], b[4] = c[4], b[5] = c[5], b[6] = c[6], b[7] = c[7], b[8] = c[8], this;\n    },\n    setFromMatrix4: function setFromMatrix4(a) {\n      var b = a.elements;\n      return this.set(b[0], b[4], b[8], b[1], b[5], b[9], b[2], b[6], b[10]), this;\n    },\n    applyToBufferAttribute: function () {\n      var a = new f();\n      return function (b) {\n        for (var c = 0, d = b.count; c < d; c++) {\n          a.x = b.getX(c), a.y = b.getY(c), a.z = b.getZ(c), a.applyMatrix3(this), b.setXYZ(c, a.x, a.y, a.z);\n        }\n\n        return b;\n      };\n    }(),\n    multiply: function multiply(a) {\n      return this.multiplyMatrices(this, a);\n    },\n    premultiply: function premultiply(a) {\n      return this.multiplyMatrices(a, this);\n    },\n    multiplyMatrices: function multiplyMatrices(a, b) {\n      var c = a.elements,\n          d = b.elements,\n          e = this.elements,\n          f = c[0],\n          g = c[3],\n          h = c[6],\n          i = c[1],\n          j = c[4],\n          k = c[7],\n          l = c[2],\n          m = c[5],\n          n = c[8],\n          o = d[0],\n          p = d[3],\n          q = d[6],\n          r = d[1],\n          s = d[4],\n          t = d[7],\n          u = d[2],\n          v = d[5],\n          w = d[8];\n      return e[0] = f * o + g * r + h * u, e[3] = f * p + g * s + h * v, e[6] = f * q + g * t + h * w, e[1] = i * o + j * r + k * u, e[4] = i * p + j * s + k * v, e[7] = i * q + j * t + k * w, e[2] = l * o + m * r + n * u, e[5] = l * p + m * s + n * v, e[8] = l * q + m * t + n * w, this;\n    },\n    multiplyScalar: function multiplyScalar(a) {\n      var b = this.elements;\n      return b[0] *= a, b[3] *= a, b[6] *= a, b[1] *= a, b[4] *= a, b[7] *= a, b[2] *= a, b[5] *= a, b[8] *= a, this;\n    },\n    determinant: function determinant() {\n      var a = this.elements,\n          b = a[0],\n          c = a[1],\n          d = a[2],\n          e = a[3],\n          f = a[4],\n          g = a[5],\n          h = a[6],\n          i = a[7],\n          j = a[8];\n      return b * f * j - b * g * i - c * e * j + c * g * h + d * e * i - d * f * h;\n    },\n    getInverse: function getInverse(a, b) {\n      a && a.isMatrix4 && console.error(\"THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.\");\n      var c = a.elements,\n          d = this.elements,\n          e = c[0],\n          f = c[1],\n          g = c[2],\n          h = c[3],\n          i = c[4],\n          j = c[5],\n          k = c[6],\n          l = c[7],\n          m = c[8],\n          n = m * i - j * l,\n          o = j * k - m * h,\n          p = l * h - i * k,\n          q = e * n + f * o + g * p;\n\n      if (0 === q) {\n        var r = \"THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0\";\n        if (!0 === b) throw new Error(r);\n        return console.warn(r), this.identity();\n      }\n\n      var s = 1 / q;\n      return d[0] = n * s, d[1] = (g * l - m * f) * s, d[2] = (j * f - g * i) * s, d[3] = o * s, d[4] = (m * e - g * k) * s, d[5] = (g * h - j * e) * s, d[6] = p * s, d[7] = (f * k - l * e) * s, d[8] = (i * e - f * h) * s, this;\n    },\n    transpose: function transpose() {\n      var a,\n          b = this.elements;\n      return a = b[1], b[1] = b[3], b[3] = a, a = b[2], b[2] = b[6], b[6] = a, a = b[5], b[5] = b[7], b[7] = a, this;\n    },\n    getNormalMatrix: function getNormalMatrix(a) {\n      return this.setFromMatrix4(a).getInverse(this).transpose();\n    },\n    transposeIntoArray: function transposeIntoArray(a) {\n      var b = this.elements;\n      return a[0] = b[0], a[1] = b[3], a[2] = b[6], a[3] = b[1], a[4] = b[4], a[5] = b[7], a[6] = b[2], a[7] = b[5], a[8] = b[8], this;\n    },\n    setUvTransform: function setUvTransform(a, b, c, d, e, f, g) {\n      var h = Math.cos(e),\n          i = Math.sin(e);\n      this.set(c * h, c * i, -c * (h * f + i * g) + f + a, -d * i, d * h, -d * (-i * f + h * g) + g + b, 0, 0, 1);\n    },\n    scale: function scale(a, b) {\n      var c = this.elements;\n      return c[0] *= a, c[3] *= a, c[6] *= a, c[1] *= b, c[4] *= b, c[7] *= b, this;\n    },\n    rotate: function rotate(a) {\n      var b = Math.cos(a),\n          c = Math.sin(a),\n          d = this.elements,\n          e = d[0],\n          f = d[3],\n          g = d[6],\n          h = d[1],\n          i = d[4],\n          j = d[7];\n      return d[0] = b * e + c * h, d[3] = b * f + c * i, d[6] = b * g + c * j, d[1] = -c * e + b * h, d[4] = -c * f + b * i, d[7] = -c * g + b * j, this;\n    },\n    translate: function translate(a, b) {\n      var c = this.elements;\n      return c[0] += a * c[2], c[3] += a * c[5], c[6] += a * c[8], c[1] += b * c[2], c[4] += b * c[5], c[7] += b * c[8], this;\n    },\n    equals: function equals(a) {\n      for (var b = this.elements, c = a.elements, d = 0; d < 9; d++) {\n        if (b[d] !== c[d]) return !1;\n      }\n\n      return !0;\n    },\n    fromArray: function fromArray(a, b) {\n      void 0 === b && (b = 0);\n\n      for (var c = 0; c < 9; c++) {\n        this.elements[c] = a[c + b];\n      }\n\n      return this;\n    },\n    toArray: function toArray(a, b) {\n      void 0 === a && (a = []), void 0 === b && (b = 0);\n      var c = this.elements;\n      return a[b] = c[0], a[b + 1] = c[1], a[b + 2] = c[2], a[b + 3] = c[3], a[b + 4] = c[4], a[b + 5] = c[5], a[b + 6] = c[6], a[b + 7] = c[7], a[b + 8] = c[8], a;\n    }\n  });\n  var zd = 0;\n  h.DEFAULT_IMAGE = void 0, h.DEFAULT_MAPPING = vc, h.prototype = Object.assign(Object.create(b.prototype), {\n    constructor: h,\n    isTexture: !0,\n    clone: function clone() {\n      return new this.constructor().copy(this);\n    },\n    copy: function copy(a) {\n      return this.name = a.name, this.image = a.image, this.mipmaps = a.mipmaps.slice(0), this.mapping = a.mapping, this.wrapS = a.wrapS, this.wrapT = a.wrapT, this.magFilter = a.magFilter, this.minFilter = a.minFilter, this.anisotropy = a.anisotropy, this.format = a.format, this.type = a.type, this.offset.copy(a.offset), this.repeat.copy(a.repeat), this.center.copy(a.center), this.rotation = a.rotation, this.matrixAutoUpdate = a.matrixAutoUpdate, this.matrix.copy(a.matrix), this.generateMipmaps = a.generateMipmaps, this.premultiplyAlpha = a.premultiplyAlpha, this.flipY = a.flipY, this.unpackAlignment = a.unpackAlignment, this.encoding = a.encoding, this;\n    },\n    toJSON: function toJSON(a) {\n      function b(a) {\n        var b;\n        if (a instanceof HTMLCanvasElement) b = a;else {\n          b = document.createElementNS(\"http://www.w3.org/1999/xhtml\", \"canvas\"), b.width = a.width, b.height = a.height;\n          var c = b.getContext(\"2d\");\n          a instanceof ImageData ? c.putImageData(a, 0, 0) : c.drawImage(a, 0, 0, a.width, a.height);\n        }\n        return b.width > 2048 || b.height > 2048 ? b.toDataURL(\"image/jpeg\", .6) : b.toDataURL(\"image/png\");\n      }\n\n      var c = void 0 === a || \"string\" == typeof a;\n      if (!c && void 0 !== a.textures[this.uuid]) return a.textures[this.uuid];\n      var d = {\n        metadata: {\n          version: 4.5,\n          type: \"Texture\",\n          generator: \"Texture.toJSON\"\n        },\n        uuid: this.uuid,\n        name: this.name,\n        mapping: this.mapping,\n        repeat: [this.repeat.x, this.repeat.y],\n        offset: [this.offset.x, this.offset.y],\n        center: [this.center.x, this.center.y],\n        rotation: this.rotation,\n        wrap: [this.wrapS, this.wrapT],\n        minFilter: this.minFilter,\n        magFilter: this.magFilter,\n        anisotropy: this.anisotropy,\n        flipY: this.flipY\n      };\n\n      if (void 0 !== this.image) {\n        var e = this.image;\n        void 0 === e.uuid && (e.uuid = yd.generateUUID()), c || void 0 !== a.images[e.uuid] || (a.images[e.uuid] = {\n          uuid: e.uuid,\n          url: b(e)\n        }), d.image = e.uuid;\n      }\n\n      return c || (a.textures[this.uuid] = d), d;\n    },\n    dispose: function dispose() {\n      this.dispatchEvent({\n        type: \"dispose\"\n      });\n    },\n    transformUv: function transformUv(a) {\n      if (this.mapping === vc) {\n        if (a.applyMatrix3(this.matrix), a.x < 0 || a.x > 1) switch (this.wrapS) {\n          case Dc:\n            a.x = a.x - Math.floor(a.x);\n            break;\n\n          case Ec:\n            a.x = a.x < 0 ? 0 : 1;\n            break;\n\n          case Fc:\n            1 === Math.abs(Math.floor(a.x) % 2) ? a.x = Math.ceil(a.x) - a.x : a.x = a.x - Math.floor(a.x);\n        }\n        if (a.y < 0 || a.y > 1) switch (this.wrapT) {\n          case Dc:\n            a.y = a.y - Math.floor(a.y);\n            break;\n\n          case Ec:\n            a.y = a.y < 0 ? 0 : 1;\n            break;\n\n          case Fc:\n            1 === Math.abs(Math.floor(a.y) % 2) ? a.y = Math.ceil(a.y) - a.y : a.y = a.y - Math.floor(a.y);\n        }\n        this.flipY && (a.y = 1 - a.y);\n      }\n    }\n  }), Object.defineProperty(h.prototype, \"needsUpdate\", {\n    set: function set(a) {\n      !0 === a && this.version++;\n    }\n  }), Object.assign(i.prototype, {\n    isVector4: !0,\n    set: function set(a, b, c, d) {\n      return this.x = a, this.y = b, this.z = c, this.w = d, this;\n    },\n    setScalar: function setScalar(a) {\n      return this.x = a, this.y = a, this.z = a, this.w = a, this;\n    },\n    setX: function setX(a) {\n      return this.x = a, this;\n    },\n    setY: function setY(a) {\n      return this.y = a, this;\n    },\n    setZ: function setZ(a) {\n      return this.z = a, this;\n    },\n    setW: function setW(a) {\n      return this.w = a, this;\n    },\n    setComponent: function setComponent(a, b) {\n      switch (a) {\n        case 0:\n          this.x = b;\n          break;\n\n        case 1:\n          this.y = b;\n          break;\n\n        case 2:\n          this.z = b;\n          break;\n\n        case 3:\n          this.w = b;\n          break;\n\n        default:\n          throw new Error(\"index is out of range: \" + a);\n      }\n\n      return this;\n    },\n    getComponent: function getComponent(a) {\n      switch (a) {\n        case 0:\n          return this.x;\n\n        case 1:\n          return this.y;\n\n        case 2:\n          return this.z;\n\n        case 3:\n          return this.w;\n\n        default:\n          throw new Error(\"index is out of range: \" + a);\n      }\n    },\n    clone: function clone() {\n      return new this.constructor(this.x, this.y, this.z, this.w);\n    },\n    copy: function copy(a) {\n      return this.x = a.x, this.y = a.y, this.z = a.z, this.w = void 0 !== a.w ? a.w : 1, this;\n    },\n    add: function add(a, b) {\n      return void 0 !== b ? (console.warn(\"THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.\"), this.addVectors(a, b)) : (this.x += a.x, this.y += a.y, this.z += a.z, this.w += a.w, this);\n    },\n    addScalar: function addScalar(a) {\n      return this.x += a, this.y += a, this.z += a, this.w += a, this;\n    },\n    addVectors: function addVectors(a, b) {\n      return this.x = a.x + b.x, this.y = a.y + b.y, this.z = a.z + b.z, this.w = a.w + b.w, this;\n    },\n    addScaledVector: function addScaledVector(a, b) {\n      return this.x += a.x * b, this.y += a.y * b, this.z += a.z * b, this.w += a.w * b, this;\n    },\n    sub: function sub(a, b) {\n      return void 0 !== b ? (console.warn(\"THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.\"), this.subVectors(a, b)) : (this.x -= a.x, this.y -= a.y, this.z -= a.z, this.w -= a.w, this);\n    },\n    subScalar: function subScalar(a) {\n      return this.x -= a, this.y -= a, this.z -= a, this.w -= a, this;\n    },\n    subVectors: function subVectors(a, b) {\n      return this.x = a.x - b.x, this.y = a.y - b.y, this.z = a.z - b.z, this.w = a.w - b.w, this;\n    },\n    multiplyScalar: function multiplyScalar(a) {\n      return this.x *= a, this.y *= a, this.z *= a, this.w *= a, this;\n    },\n    applyMatrix4: function applyMatrix4(a) {\n      var b = this.x,\n          c = this.y,\n          d = this.z,\n          e = this.w,\n          f = a.elements;\n      return this.x = f[0] * b + f[4] * c + f[8] * d + f[12] * e, this.y = f[1] * b + f[5] * c + f[9] * d + f[13] * e, this.z = f[2] * b + f[6] * c + f[10] * d + f[14] * e, this.w = f[3] * b + f[7] * c + f[11] * d + f[15] * e, this;\n    },\n    divideScalar: function divideScalar(a) {\n      return this.multiplyScalar(1 / a);\n    },\n    setAxisAngleFromQuaternion: function setAxisAngleFromQuaternion(a) {\n      this.w = 2 * Math.acos(a.w);\n      var b = Math.sqrt(1 - a.w * a.w);\n      return b < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = a.x / b, this.y = a.y / b, this.z = a.z / b), this;\n    },\n    setAxisAngleFromRotationMatrix: function setAxisAngleFromRotationMatrix(a) {\n      var b,\n          c,\n          d,\n          e,\n          f = .01,\n          g = .1,\n          h = a.elements,\n          i = h[0],\n          j = h[4],\n          k = h[8],\n          l = h[1],\n          m = h[5],\n          n = h[9],\n          o = h[2],\n          p = h[6],\n          q = h[10];\n\n      if (Math.abs(j - l) < f && Math.abs(k - o) < f && Math.abs(n - p) < f) {\n        if (Math.abs(j + l) < g && Math.abs(k + o) < g && Math.abs(n + p) < g && Math.abs(i + m + q - 3) < g) return this.set(1, 0, 0, 0), this;\n        b = Math.PI;\n        var r = (i + 1) / 2,\n            s = (m + 1) / 2,\n            t = (q + 1) / 2,\n            u = (j + l) / 4,\n            v = (k + o) / 4,\n            w = (n + p) / 4;\n        return r > s && r > t ? r < f ? (c = 0, d = .707106781, e = .707106781) : (c = Math.sqrt(r), d = u / c, e = v / c) : s > t ? s < f ? (c = .707106781, d = 0, e = .707106781) : (d = Math.sqrt(s), c = u / d, e = w / d) : t < f ? (c = .707106781, d = .707106781, e = 0) : (e = Math.sqrt(t), c = v / e, d = w / e), this.set(c, d, e, b), this;\n      }\n\n      var x = Math.sqrt((p - n) * (p - n) + (k - o) * (k - o) + (l - j) * (l - j));\n      return Math.abs(x) < .001 && (x = 1), this.x = (p - n) / x, this.y = (k - o) / x, this.z = (l - j) / x, this.w = Math.acos((i + m + q - 1) / 2), this;\n    },\n    min: function min(a) {\n      return this.x = Math.min(this.x, a.x), this.y = Math.min(this.y, a.y), this.z = Math.min(this.z, a.z), this.w = Math.min(this.w, a.w), this;\n    },\n    max: function max(a) {\n      return this.x = Math.max(this.x, a.x), this.y = Math.max(this.y, a.y), this.z = Math.max(this.z, a.z), this.w = Math.max(this.w, a.w), this;\n    },\n    clamp: function clamp(a, b) {\n      return this.x = Math.max(a.x, Math.min(b.x, this.x)), this.y = Math.max(a.y, Math.min(b.y, this.y)), this.z = Math.max(a.z, Math.min(b.z, this.z)), this.w = Math.max(a.w, Math.min(b.w, this.w)), this;\n    },\n    clampScalar: function () {\n      var a, b;\n      return function (c, d) {\n        return void 0 === a && (a = new i(), b = new i()), a.set(c, c, c, c), b.set(d, d, d, d), this.clamp(a, b);\n      };\n    }(),\n    clampLength: function clampLength(a, b) {\n      var c = this.length();\n      return this.divideScalar(c || 1).multiplyScalar(Math.max(a, Math.min(b, c)));\n    },\n    floor: function floor() {\n      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;\n    },\n    ceil: function ceil() {\n      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;\n    },\n    round: function round() {\n      return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;\n    },\n    roundToZero: function roundToZero() {\n      return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this;\n    },\n    negate: function negate() {\n      return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;\n    },\n    dot: function dot(a) {\n      return this.x * a.x + this.y * a.y + this.z * a.z + this.w * a.w;\n    },\n    lengthSq: function lengthSq() {\n      return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n    },\n    length: function length() {\n      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\n    },\n    manhattanLength: function manhattanLength() {\n      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);\n    },\n    normalize: function normalize() {\n      return this.divideScalar(this.length() || 1);\n    },\n    setLength: function setLength(a) {\n      return this.normalize().multiplyScalar(a);\n    },\n    lerp: function lerp(a, b) {\n      return this.x += (a.x - this.x) * b, this.y += (a.y - this.y) * b, this.z += (a.z - this.z) * b, this.w += (a.w - this.w) * b, this;\n    },\n    lerpVectors: function lerpVectors(a, b, c) {\n      return this.subVectors(b, a).multiplyScalar(c).add(a);\n    },\n    equals: function equals(a) {\n      return a.x === this.x && a.y === this.y && a.z === this.z && a.w === this.w;\n    },\n    fromArray: function fromArray(a, b) {\n      return void 0 === b && (b = 0), this.x = a[b], this.y = a[b + 1], this.z = a[b + 2], this.w = a[b + 3], this;\n    },\n    toArray: function toArray(a, b) {\n      return void 0 === a && (a = []), void 0 === b && (b = 0), a[b] = this.x, a[b + 1] = this.y, a[b + 2] = this.z, a[b + 3] = this.w, a;\n    },\n    fromBufferAttribute: function fromBufferAttribute(a, b, c) {\n      return void 0 !== c && console.warn(\"THREE.Vector4: offset has been removed from .fromBufferAttribute().\"), this.x = a.getX(b), this.y = a.getY(b), this.z = a.getZ(b), this.w = a.getW(b), this;\n    }\n  }), j.prototype = Object.assign(Object.create(b.prototype), {\n    constructor: j,\n    isWebGLRenderTarget: !0,\n    setSize: function setSize(a, b) {\n      this.width === a && this.height === b || (this.width = a, this.height = b, this.dispose()), this.viewport.set(0, 0, a, b), this.scissor.set(0, 0, a, b);\n    },\n    clone: function clone() {\n      return new this.constructor().copy(this);\n    },\n    copy: function copy(a) {\n      return this.width = a.width, this.height = a.height, this.viewport.copy(a.viewport), this.texture = a.texture.clone(), this.depthBuffer = a.depthBuffer, this.stencilBuffer = a.stencilBuffer, this.depthTexture = a.depthTexture, this;\n    },\n    dispose: function dispose() {\n      this.dispatchEvent({\n        type: \"dispose\"\n      });\n    }\n  }), k.prototype = Object.create(h.prototype), k.prototype.constructor = k, k.prototype.isDataTexture = !0, l.prototype = Object.create(h.prototype), l.prototype.constructor = l, l.prototype.isCubeTexture = !0, Object.defineProperty(l.prototype, \"images\", {\n    get: function get() {\n      return this.image;\n    },\n    set: function set(a) {\n      this.image = a;\n    }\n  });\n  var Ad = new h(),\n      Bd = new l(),\n      Cd = [],\n      Dd = [],\n      Ed = new Float32Array(16),\n      Fd = new Float32Array(9);\n\n  Q.prototype.setValue = function (a, b) {\n    for (var c = this.seq, d = 0, e = c.length; d !== e; ++d) {\n      var f = c[d];\n      f.setValue(a, b[f.id]);\n    }\n  };\n\n  var Gd = /([\\w\\d_]+)(\\])?(\\[|\\.)?/g;\n  T.prototype.setValue = function (a, b, c) {\n    var d = this.map[b];\n    void 0 !== d && d.setValue(a, c, this.renderer);\n  }, T.prototype.setOptional = function (a, b, c) {\n    var d = b[c];\n    void 0 !== d && this.setValue(a, c, d);\n  }, T.upload = function (a, b, c, d) {\n    for (var e = 0, f = b.length; e !== f; ++e) {\n      var g = b[e],\n          h = c[g.id];\n      !1 !== h.needsUpdate && g.setValue(a, h.value, d);\n    }\n  }, T.seqWithValue = function (a, b) {\n    for (var c = [], d = 0, e = a.length; d !== e; ++d) {\n      var f = a[d];\n      f.id in b && c.push(f);\n    }\n\n    return c;\n  };\n  var Hd = {\n    aliceblue: 15792383,\n    antiquewhite: 16444375,\n    aqua: 65535,\n    aquamarine: 8388564,\n    azure: 15794175,\n    beige: 16119260,\n    bisque: 16770244,\n    black: 0,\n    blanchedalmond: 16772045,\n    blue: 255,\n    blueviolet: 9055202,\n    brown: 10824234,\n    burlywood: 14596231,\n    cadetblue: 6266528,\n    chartreuse: 8388352,\n    chocolate: 13789470,\n    coral: 16744272,\n    cornflowerblue: 6591981,\n    cornsilk: 16775388,\n    crimson: 14423100,\n    cyan: 65535,\n    darkblue: 139,\n    darkcyan: 35723,\n    darkgoldenrod: 12092939,\n    darkgray: 11119017,\n    darkgreen: 25600,\n    darkgrey: 11119017,\n    darkkhaki: 12433259,\n    darkmagenta: 9109643,\n    darkolivegreen: 5597999,\n    darkorange: 16747520,\n    darkorchid: 10040012,\n    darkred: 9109504,\n    darksalmon: 15308410,\n    darkseagreen: 9419919,\n    darkslateblue: 4734347,\n    darkslategray: 3100495,\n    darkslategrey: 3100495,\n    darkturquoise: 52945,\n    darkviolet: 9699539,\n    deeppink: 16716947,\n    deepskyblue: 49151,\n    dimgray: 6908265,\n    dimgrey: 6908265,\n    dodgerblue: 2003199,\n    firebrick: 11674146,\n    floralwhite: 16775920,\n    forestgreen: 2263842,\n    fuchsia: 16711935,\n    gainsboro: 14474460,\n    ghostwhite: 16316671,\n    gold: 16766720,\n    goldenrod: 14329120,\n    gray: 8421504,\n    green: 32768,\n    greenyellow: 11403055,\n    grey: 8421504,\n    honeydew: 15794160,\n    hotpink: 16738740,\n    indianred: 13458524,\n    indigo: 4915330,\n    ivory: 16777200,\n    khaki: 15787660,\n    lavender: 15132410,\n    lavenderblush: 16773365,\n    lawngreen: 8190976,\n    lemonchiffon: 16775885,\n    lightblue: 11393254,\n    lightcoral: 15761536,\n    lightcyan: 14745599,\n    lightgoldenrodyellow: 16448210,\n    lightgray: 13882323,\n    lightgreen: 9498256,\n    lightgrey: 13882323,\n    lightpink: 16758465,\n    lightsalmon: 16752762,\n    lightseagreen: 2142890,\n    lightskyblue: 8900346,\n    lightslategray: 7833753,\n    lightslategrey: 7833753,\n    lightsteelblue: 11584734,\n    lightyellow: 16777184,\n    lime: 65280,\n    limegreen: 3329330,\n    linen: 16445670,\n    magenta: 16711935,\n    maroon: 8388608,\n    mediumaquamarine: 6737322,\n    mediumblue: 205,\n    mediumorchid: 12211667,\n    mediumpurple: 9662683,\n    mediumseagreen: 3978097,\n    mediumslateblue: 8087790,\n    mediumspringgreen: 64154,\n    mediumturquoise: 4772300,\n    mediumvioletred: 13047173,\n    midnightblue: 1644912,\n    mintcream: 16121850,\n    mistyrose: 16770273,\n    moccasin: 16770229,\n    navajowhite: 16768685,\n    navy: 128,\n    oldlace: 16643558,\n    olive: 8421376,\n    olivedrab: 7048739,\n    orange: 16753920,\n    orangered: 16729344,\n    orchid: 14315734,\n    palegoldenrod: 15657130,\n    palegreen: 10025880,\n    paleturquoise: 11529966,\n    palevioletred: 14381203,\n    papayawhip: 16773077,\n    peachpuff: 16767673,\n    peru: 13468991,\n    pink: 16761035,\n    plum: 14524637,\n    powderblue: 11591910,\n    purple: 8388736,\n    rebeccapurple: 6697881,\n    red: 16711680,\n    rosybrown: 12357519,\n    royalblue: 4286945,\n    saddlebrown: 9127187,\n    salmon: 16416882,\n    sandybrown: 16032864,\n    seagreen: 3050327,\n    seashell: 16774638,\n    sienna: 10506797,\n    silver: 12632256,\n    skyblue: 8900331,\n    slateblue: 6970061,\n    slategray: 7372944,\n    slategrey: 7372944,\n    snow: 16775930,\n    springgreen: 65407,\n    steelblue: 4620980,\n    tan: 13808780,\n    teal: 32896,\n    thistle: 14204888,\n    tomato: 16737095,\n    turquoise: 4251856,\n    violet: 15631086,\n    wheat: 16113331,\n    white: 16777215,\n    whitesmoke: 16119285,\n    yellow: 16776960,\n    yellowgreen: 10145074\n  };\n  Object.assign(U.prototype, {\n    isColor: !0,\n    r: 1,\n    g: 1,\n    b: 1,\n    set: function set(a) {\n      return a && a.isColor ? this.copy(a) : \"number\" == typeof a ? this.setHex(a) : \"string\" == typeof a && this.setStyle(a), this;\n    },\n    setScalar: function setScalar(a) {\n      return this.r = a, this.g = a, this.b = a, this;\n    },\n    setHex: function setHex(a) {\n      return a = Math.floor(a), this.r = (a >> 16 & 255) / 255, this.g = (a >> 8 & 255) / 255, this.b = (255 & a) / 255, this;\n    },\n    setRGB: function setRGB(a, b, c) {\n      return this.r = a, this.g = b, this.b = c, this;\n    },\n    setHSL: function () {\n      function a(a, b, c) {\n        return c < 0 && (c += 1), c > 1 && (c -= 1), c < 1 / 6 ? a + 6 * (b - a) * c : c < .5 ? b : c < 2 / 3 ? a + 6 * (b - a) * (2 / 3 - c) : a;\n      }\n\n      return function (b, c, d) {\n        if (b = yd.euclideanModulo(b, 1), c = yd.clamp(c, 0, 1), d = yd.clamp(d, 0, 1), 0 === c) this.r = this.g = this.b = d;else {\n          var e = d <= .5 ? d * (1 + c) : d + c - d * c,\n              f = 2 * d - e;\n          this.r = a(f, e, b + 1 / 3), this.g = a(f, e, b), this.b = a(f, e, b - 1 / 3);\n        }\n        return this;\n      };\n    }(),\n    setStyle: function setStyle(a) {\n      function b(b) {\n        void 0 !== b && parseFloat(b) < 1 && console.warn(\"THREE.Color: Alpha component of \" + a + \" will be ignored.\");\n      }\n\n      var c;\n\n      if (c = /^((?:rgb|hsl)a?)\\(\\s*([^\\)]*)\\)/.exec(a)) {\n        var d,\n            e = c[1],\n            f = c[2];\n\n        switch (e) {\n          case \"rgb\":\n          case \"rgba\":\n            if (d = /^(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec(f)) return this.r = Math.min(255, parseInt(d[1], 10)) / 255, this.g = Math.min(255, parseInt(d[2], 10)) / 255, this.b = Math.min(255, parseInt(d[3], 10)) / 255, b(d[5]), this;\n            if (d = /^(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec(f)) return this.r = Math.min(100, parseInt(d[1], 10)) / 100, this.g = Math.min(100, parseInt(d[2], 10)) / 100, this.b = Math.min(100, parseInt(d[3], 10)) / 100, b(d[5]), this;\n            break;\n\n          case \"hsl\":\n          case \"hsla\":\n            if (d = /^([0-9]*\\.?[0-9]+)\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec(f)) {\n              var g = parseFloat(d[1]) / 360,\n                  h = parseInt(d[2], 10) / 100,\n                  i = parseInt(d[3], 10) / 100;\n              return b(d[5]), this.setHSL(g, h, i);\n            }\n\n        }\n      } else if (c = /^\\#([A-Fa-f0-9]+)$/.exec(a)) {\n        var j = c[1],\n            k = j.length;\n        if (3 === k) return this.r = parseInt(j.charAt(0) + j.charAt(0), 16) / 255, this.g = parseInt(j.charAt(1) + j.charAt(1), 16) / 255, this.b = parseInt(j.charAt(2) + j.charAt(2), 16) / 255, this;\n        if (6 === k) return this.r = parseInt(j.charAt(0) + j.charAt(1), 16) / 255, this.g = parseInt(j.charAt(2) + j.charAt(3), 16) / 255, this.b = parseInt(j.charAt(4) + j.charAt(5), 16) / 255, this;\n      }\n\n      if (a && a.length > 0) {\n        var j = Hd[a];\n        void 0 !== j ? this.setHex(j) : console.warn(\"THREE.Color: Unknown color \" + a);\n      }\n\n      return this;\n    },\n    clone: function clone() {\n      return new this.constructor(this.r, this.g, this.b);\n    },\n    copy: function copy(a) {\n      return this.r = a.r, this.g = a.g, this.b = a.b, this;\n    },\n    copyGammaToLinear: function copyGammaToLinear(a, b) {\n      return void 0 === b && (b = 2), this.r = Math.pow(a.r, b), this.g = Math.pow(a.g, b), this.b = Math.pow(a.b, b), this;\n    },\n    copyLinearToGamma: function copyLinearToGamma(a, b) {\n      void 0 === b && (b = 2);\n      var c = b > 0 ? 1 / b : 1;\n      return this.r = Math.pow(a.r, c), this.g = Math.pow(a.g, c), this.b = Math.pow(a.b, c), this;\n    },\n    convertGammaToLinear: function convertGammaToLinear() {\n      var a = this.r,\n          b = this.g,\n          c = this.b;\n      return this.r = a * a, this.g = b * b, this.b = c * c, this;\n    },\n    convertLinearToGamma: function convertLinearToGamma() {\n      return this.r = Math.sqrt(this.r), this.g = Math.sqrt(this.g), this.b = Math.sqrt(this.b), this;\n    },\n    getHex: function getHex() {\n      return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0;\n    },\n    getHexString: function getHexString() {\n      return (\"000000\" + this.getHex().toString(16)).slice(-6);\n    },\n    getHSL: function getHSL(a) {\n      var b,\n          c,\n          d = a || {\n        h: 0,\n        s: 0,\n        l: 0\n      },\n          e = this.r,\n          f = this.g,\n          g = this.b,\n          h = Math.max(e, f, g),\n          i = Math.min(e, f, g),\n          j = (i + h) / 2;\n      if (i === h) b = 0, c = 0;else {\n        var k = h - i;\n\n        switch (c = j <= .5 ? k / (h + i) : k / (2 - h - i), h) {\n          case e:\n            b = (f - g) / k + (f < g ? 6 : 0);\n            break;\n\n          case f:\n            b = (g - e) / k + 2;\n            break;\n\n          case g:\n            b = (e - f) / k + 4;\n        }\n\n        b /= 6;\n      }\n      return d.h = b, d.s = c, d.l = j, d;\n    },\n    getStyle: function getStyle() {\n      return \"rgb(\" + (255 * this.r | 0) + \",\" + (255 * this.g | 0) + \",\" + (255 * this.b | 0) + \")\";\n    },\n    offsetHSL: function offsetHSL(a, b, c) {\n      var d = this.getHSL();\n      return d.h += a, d.s += b, d.l += c, this.setHSL(d.h, d.s, d.l), this;\n    },\n    add: function add(a) {\n      return this.r += a.r, this.g += a.g, this.b += a.b, this;\n    },\n    addColors: function addColors(a, b) {\n      return this.r = a.r + b.r, this.g = a.g + b.g, this.b = a.b + b.b, this;\n    },\n    addScalar: function addScalar(a) {\n      return this.r += a, this.g += a, this.b += a, this;\n    },\n    sub: function sub(a) {\n      return this.r = Math.max(0, this.r - a.r), this.g = Math.max(0, this.g - a.g), this.b = Math.max(0, this.b - a.b), this;\n    },\n    multiply: function multiply(a) {\n      return this.r *= a.r, this.g *= a.g, this.b *= a.b, this;\n    },\n    multiplyScalar: function multiplyScalar(a) {\n      return this.r *= a, this.g *= a, this.b *= a, this;\n    },\n    lerp: function lerp(a, b) {\n      return this.r += (a.r - this.r) * b, this.g += (a.g - this.g) * b, this.b += (a.b - this.b) * b, this;\n    },\n    equals: function equals(a) {\n      return a.r === this.r && a.g === this.g && a.b === this.b;\n    },\n    fromArray: function fromArray(a, b) {\n      return void 0 === b && (b = 0), this.r = a[b], this.g = a[b + 1], this.b = a[b + 2], this;\n    },\n    toArray: function toArray(a, b) {\n      return void 0 === a && (a = []), void 0 === b && (b = 0), a[b] = this.r, a[b + 1] = this.g, a[b + 2] = this.b, a;\n    },\n    toJSON: function toJSON() {\n      return this.getHex();\n    }\n  });\n  var Id = {\n    common: {\n      diffuse: {\n        value: new U(15658734)\n      },\n      opacity: {\n        value: 1\n      },\n      map: {\n        value: null\n      },\n      uvTransform: {\n        value: new g()\n      },\n      alphaMap: {\n        value: null\n      }\n    },\n    specularmap: {\n      specularMap: {\n        value: null\n      }\n    },\n    envmap: {\n      envMap: {\n        value: null\n      },\n      flipEnvMap: {\n        value: -1\n      },\n      reflectivity: {\n        value: 1\n      },\n      refractionRatio: {\n        value: .98\n      }\n    },\n    aomap: {\n      aoMap: {\n        value: null\n      },\n      aoMapIntensity: {\n        value: 1\n      }\n    },\n    lightmap: {\n      lightMap: {\n        value: null\n      },\n      lightMapIntensity: {\n        value: 1\n      }\n    },\n    emissivemap: {\n      emissiveMap: {\n        value: null\n      }\n    },\n    bumpmap: {\n      bumpMap: {\n        value: null\n      },\n      bumpScale: {\n        value: 1\n      }\n    },\n    normalmap: {\n      normalMap: {\n        value: null\n      },\n      normalScale: {\n        value: new c(1, 1)\n      }\n    },\n    displacementmap: {\n      displacementMap: {\n        value: null\n      },\n      displacementScale: {\n        value: 1\n      },\n      displacementBias: {\n        value: 0\n      }\n    },\n    roughnessmap: {\n      roughnessMap: {\n        value: null\n      }\n    },\n    metalnessmap: {\n      metalnessMap: {\n        value: null\n      }\n    },\n    gradientmap: {\n      gradientMap: {\n        value: null\n      }\n    },\n    fog: {\n      fogDensity: {\n        value: 25e-5\n      },\n      fogNear: {\n        value: 1\n      },\n      fogFar: {\n        value: 2e3\n      },\n      fogColor: {\n        value: new U(16777215)\n      }\n    },\n    lights: {\n      ambientLightColor: {\n        value: []\n      },\n      directionalLights: {\n        value: [],\n        properties: {\n          direction: {},\n          color: {},\n          shadow: {},\n          shadowBias: {},\n          shadowRadius: {},\n          shadowMapSize: {}\n        }\n      },\n      directionalShadowMap: {\n        value: []\n      },\n      directionalShadowMatrix: {\n        value: []\n      },\n      spotLights: {\n        value: [],\n        properties: {\n          color: {},\n          position: {},\n          direction: {},\n          distance: {},\n          coneCos: {},\n          penumbraCos: {},\n          decay: {},\n          shadow: {},\n          shadowBias: {},\n          shadowRadius: {},\n          shadowMapSize: {}\n        }\n      },\n      spotShadowMap: {\n        value: []\n      },\n      spotShadowMatrix: {\n        value: []\n      },\n      pointLights: {\n        value: [],\n        properties: {\n          color: {},\n          position: {},\n          decay: {},\n          distance: {},\n          shadow: {},\n          shadowBias: {},\n          shadowRadius: {},\n          shadowMapSize: {},\n          shadowCameraNear: {},\n          shadowCameraFar: {}\n        }\n      },\n      pointShadowMap: {\n        value: []\n      },\n      pointShadowMatrix: {\n        value: []\n      },\n      hemisphereLights: {\n        value: [],\n        properties: {\n          direction: {},\n          skyColor: {},\n          groundColor: {}\n        }\n      },\n      rectAreaLights: {\n        value: [],\n        properties: {\n          color: {},\n          position: {},\n          width: {},\n          height: {}\n        }\n      }\n    },\n    points: {\n      diffuse: {\n        value: new U(15658734)\n      },\n      opacity: {\n        value: 1\n      },\n      size: {\n        value: 1\n      },\n      scale: {\n        value: 1\n      },\n      map: {\n        value: null\n      },\n      uvTransform: {\n        value: new g()\n      }\n    }\n  },\n      Jd = {\n    merge: function merge(a) {\n      for (var b = {}, c = 0; c < a.length; c++) {\n        var d = this.clone(a[c]);\n\n        for (var e in d) {\n          b[e] = d[e];\n        }\n      }\n\n      return b;\n    },\n    clone: function clone(a) {\n      var b = {};\n\n      for (var c in a) {\n        b[c] = {};\n\n        for (var d in a[c]) {\n          var e = a[c][d];\n          e && (e.isColor || e.isMatrix3 || e.isMatrix4 || e.isVector2 || e.isVector3 || e.isVector4 || e.isTexture) ? b[c][d] = e.clone() : Array.isArray(e) ? b[c][d] = e.slice() : b[c][d] = e;\n        }\n      }\n\n      return b;\n    }\n  },\n      Kd = \"#ifdef USE_ALPHAMAP\\n\\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\\n#endif\\n\",\n      Ld = \"#ifdef USE_ALPHAMAP\\n\\tuniform sampler2D alphaMap;\\n#endif\\n\",\n      Md = \"#ifdef ALPHATEST\\n\\tif ( diffuseColor.a < ALPHATEST ) discard;\\n#endif\\n\",\n      Nd = \"#ifdef USE_AOMAP\\n\\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\\n\\treflectedLight.indirectDiffuse *= ambientOcclusion;\\n\\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\\t\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\t\\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\\n\\t#endif\\n#endif\\n\",\n      Od = \"#ifdef USE_AOMAP\\n\\tuniform sampler2D aoMap;\\n\\tuniform float aoMapIntensity;\\n#endif\",\n      Pd = \"\\nvec3 transformed = vec3( position );\\n\",\n      Qd = \"\\nvec3 objectNormal = vec3( normal );\\n\",\n      Rd = \"float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\n\\tif( decayExponent > 0.0 ) {\\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\\n\\t\\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\\n\\t\\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\\n\\t\\treturn distanceFalloff * maxDistanceCutoffFactor;\\n#else\\n\\t\\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\\n#endif\\n\\t}\\n\\treturn 1.0;\\n}\\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\\n\\treturn RECIPROCAL_PI * diffuseColor;\\n}\\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\\n\\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\\n\\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\\n}\\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\treturn 1.0 / ( gl * gv );\\n}\\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\treturn 0.5 / max( gv + gl, EPSILON );\\n}\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\\n\\treturn RECIPROCAL_PI * a2 / pow2( denom );\\n}\\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\\tfloat alpha = pow2( roughness );\\n\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotLH );\\n\\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\n\\tfloat D = D_GGX( alpha, dotNH );\\n\\treturn F * ( G * D );\\n}\\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\\n\\tconst float LUT_SIZE  = 64.0;\\n\\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\\n\\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\\n\\tfloat theta = acos( dot( N, V ) );\\n\\tvec2 uv = vec2(\\n\\t\\tsqrt( saturate( roughness ) ),\\n\\t\\tsaturate( theta / ( 0.5 * PI ) ) );\\n\\tuv = uv * LUT_SCALE + LUT_BIAS;\\n\\treturn uv;\\n}\\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\\n\\tfloat l = length( f );\\n\\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\\n}\\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\\n\\tfloat x = dot( v1, v2 );\\n\\tfloat y = abs( x );\\n\\tfloat a = 0.86267 + (0.49788 + 0.01436 * y ) * y;\\n\\tfloat b = 3.45068 + (4.18814 + y) * y;\\n\\tfloat v = a / b;\\n\\tfloat theta_sintheta = (x > 0.0) ? v : 0.5 * inversesqrt( 1.0 - x * x ) - v;\\n\\treturn cross( v1, v2 ) * theta_sintheta;\\n}\\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\\n\\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\\n\\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\\n\\tvec3 lightNormal = cross( v1, v2 );\\n\\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\\n\\tvec3 T1, T2;\\n\\tT1 = normalize( V - N * dot( V, N ) );\\n\\tT2 = - cross( N, T1 );\\n\\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\\n\\tvec3 coords[ 4 ];\\n\\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\\n\\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\\n\\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\\n\\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\\n\\tcoords[ 0 ] = normalize( coords[ 0 ] );\\n\\tcoords[ 1 ] = normalize( coords[ 1 ] );\\n\\tcoords[ 2 ] = normalize( coords[ 2 ] );\\n\\tcoords[ 3 ] = normalize( coords[ 3 ] );\\n\\tvec3 vectorFormFactor = vec3( 0.0 );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\\n\\tvec3 result = vec3( LTC_ClippedSphereFormFactor( vectorFormFactor ) );\\n\\treturn result;\\n}\\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\n\\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\n\\tvec4 r = roughness * c0 + c1;\\n\\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\n\\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\\n\\treturn specularColor * AB.x + AB.y;\\n}\\nfloat G_BlinnPhong_Implicit( ) {\\n\\treturn 0.25;\\n}\\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\\n\\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\n}\\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\\n\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotLH );\\n\\tfloat G = G_BlinnPhong_Implicit( );\\n\\tfloat D = D_BlinnPhong( shininess, dotNH );\\n\\treturn F * ( G * D );\\n}\\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\\n\\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\\n}\\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\\n\\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\\n}\\n\",\n      Sd = \"#ifdef USE_BUMPMAP\\n\\tuniform sampler2D bumpMap;\\n\\tuniform float bumpScale;\\n\\tvec2 dHdxy_fwd() {\\n\\t\\tvec2 dSTdx = dFdx( vUv );\\n\\t\\tvec2 dSTdy = dFdy( vUv );\\n\\t\\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\n\\t\\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\n\\t\\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\n\\t\\treturn vec2( dBx, dBy );\\n\\t}\\n\\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\\n\\t\\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\\n\\t\\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\\n\\t\\tvec3 vN = surf_norm;\\n\\t\\tvec3 R1 = cross( vSigmaY, vN );\\n\\t\\tvec3 R2 = cross( vN, vSigmaX );\\n\\t\\tfloat fDet = dot( vSigmaX, R1 );\\n\\t\\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n\\t\\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\n\\t}\\n#endif\\n\",\n      Td = \"#if NUM_CLIPPING_PLANES > 0\\n\\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\\n\\t\\tvec4 plane = clippingPlanes[ i ];\\n\\t\\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\\n\\t}\\n\\t\\t\\n\\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\\n\\t\\tbool clipped = true;\\n\\t\\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\\n\\t\\t\\tvec4 plane = clippingPlanes[ i ];\\n\\t\\t\\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\\n\\t\\t}\\n\\t\\tif ( clipped ) discard;\\n\\t\\n\\t#endif\\n#endif\\n\",\n      Ud = \"#if NUM_CLIPPING_PLANES > 0\\n\\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\\n\\t\\tvarying vec3 vViewPosition;\\n\\t#endif\\n\\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\\n#endif\\n\",\n      Vd = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n\",\n      Wd = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\n\\tvViewPosition = - mvPosition.xyz;\\n#endif\\n\",\n      Xd = \"#ifdef USE_COLOR\\n\\tdiffuseColor.rgb *= vColor;\\n#endif\",\n      Yd = \"#ifdef USE_COLOR\\n\\tvarying vec3 vColor;\\n#endif\\n\",\n      Zd = \"#ifdef USE_COLOR\\n\\tvarying vec3 vColor;\\n#endif\",\n      $d = \"#ifdef USE_COLOR\\n\\tvColor.xyz = color.xyz;\\n#endif\",\n      _d = \"#define PI 3.14159265359\\n#define PI2 6.28318530718\\n#define PI_HALF 1.5707963267949\\n#define RECIPROCAL_PI 0.31830988618\\n#define RECIPROCAL_PI2 0.15915494\\n#define LOG2 1.442695\\n#define EPSILON 1e-6\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\\nfloat pow2( const in float x ) { return x*x; }\\nfloat pow3( const in float x ) { return x*x*x; }\\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\\nhighp float rand( const in vec2 uv ) {\\n\\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\\n\\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\\n\\treturn fract(sin(sn) * c);\\n}\\nstruct IncidentLight {\\n\\tvec3 color;\\n\\tvec3 direction;\\n\\tbool visible;\\n};\\nstruct ReflectedLight {\\n\\tvec3 directDiffuse;\\n\\tvec3 directSpecular;\\n\\tvec3 indirectDiffuse;\\n\\tvec3 indirectSpecular;\\n};\\nstruct GeometricContext {\\n\\tvec3 position;\\n\\tvec3 normal;\\n\\tvec3 viewDir;\\n};\\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\n}\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n}\\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\tfloat distance = dot( planeNormal, point - pointOnPlane );\\n\\treturn - distance * planeNormal + point;\\n}\\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn sign( dot( point - pointOnPlane, planeNormal ) );\\n}\\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\\n}\\nmat3 transposeMat3( const in mat3 m ) {\\n\\tmat3 tmp;\\n\\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\\n\\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\\n\\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\\n\\treturn tmp;\\n}\\nfloat linearToRelativeLuminance( const in vec3 color ) {\\n\\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\\n\\treturn dot( weights, color.rgb );\\n}\\n\",\n      ae = \"#ifdef ENVMAP_TYPE_CUBE_UV\\n#define cubeUV_textureSize (1024.0)\\nint getFaceFromDirection(vec3 direction) {\\n\\tvec3 absDirection = abs(direction);\\n\\tint face = -1;\\n\\tif( absDirection.x > absDirection.z ) {\\n\\t\\tif(absDirection.x > absDirection.y )\\n\\t\\t\\tface = direction.x > 0.0 ? 0 : 3;\\n\\t\\telse\\n\\t\\t\\tface = direction.y > 0.0 ? 1 : 4;\\n\\t}\\n\\telse {\\n\\t\\tif(absDirection.z > absDirection.y )\\n\\t\\t\\tface = direction.z > 0.0 ? 2 : 5;\\n\\t\\telse\\n\\t\\t\\tface = direction.y > 0.0 ? 1 : 4;\\n\\t}\\n\\treturn face;\\n}\\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\\n\\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\\n\\tfloat dxRoughness = dFdx(roughness);\\n\\tfloat dyRoughness = dFdy(roughness);\\n\\tvec3 dx = dFdx( vec * scale * dxRoughness );\\n\\tvec3 dy = dFdy( vec * scale * dyRoughness );\\n\\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\\n\\td = clamp(d, 1.0, cubeUV_rangeClamp);\\n\\tfloat mipLevel = 0.5 * log2(d);\\n\\treturn vec2(floor(mipLevel), fract(mipLevel));\\n}\\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\\n\\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\\n\\tfloat a = 16.0 * cubeUV_rcpTextureSize;\\n\\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\\n\\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\\n\\tfloat powScale = exp2_packed.x * exp2_packed.y;\\n\\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\\n\\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\\n\\tbool bRes = mipLevel == 0.0;\\n\\tscale =  bRes && (scale < a) ? a : scale;\\n\\tvec3 r;\\n\\tvec2 offset;\\n\\tint face = getFaceFromDirection(direction);\\n\\tfloat rcpPowScale = 1.0 / powScale;\\n\\tif( face == 0) {\\n\\t\\tr = vec3(direction.x, -direction.z, direction.y);\\n\\t\\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\\n\\t}\\n\\telse if( face == 1) {\\n\\t\\tr = vec3(direction.y, direction.x, direction.z);\\n\\t\\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\\n\\t}\\n\\telse if( face == 2) {\\n\\t\\tr = vec3(direction.z, direction.x, direction.y);\\n\\t\\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\\n\\t}\\n\\telse if( face == 3) {\\n\\t\\tr = vec3(direction.x, direction.z, direction.y);\\n\\t\\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\\n\\t}\\n\\telse if( face == 4) {\\n\\t\\tr = vec3(direction.y, direction.x, -direction.z);\\n\\t\\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\\n\\t}\\n\\telse {\\n\\t\\tr = vec3(direction.z, -direction.x, direction.y);\\n\\t\\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\\n\\t}\\n\\tr = normalize(r);\\n\\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\\n\\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\\n\\tvec2 base = offset + vec2( texelOffset );\\n\\treturn base + s * ( scale - 2.0 * texelOffset );\\n}\\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\\n\\tfloat roughnessVal = roughness* cubeUV_maxLods3;\\n\\tfloat r1 = floor(roughnessVal);\\n\\tfloat r2 = r1 + 1.0;\\n\\tfloat t = fract(roughnessVal);\\n\\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\\n\\tfloat s = mipInfo.y;\\n\\tfloat level0 = mipInfo.x;\\n\\tfloat level1 = level0 + 1.0;\\n\\tlevel1 = level1 > 5.0 ? 5.0 : level1;\\n\\tlevel0 += min( floor( s + 0.5 ), 5.0 );\\n\\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\\n\\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\\n\\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\\n\\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\\n\\tvec4 result = mix(color10, color20, t);\\n\\treturn vec4(result.rgb, 1.0);\\n}\\n#endif\\n\",\n      be = \"vec3 transformedNormal = normalMatrix * objectNormal;\\n#ifdef FLIP_SIDED\\n\\ttransformedNormal = - transformedNormal;\\n#endif\\n\",\n      ce = \"#ifdef USE_DISPLACEMENTMAP\\n\\tuniform sampler2D displacementMap;\\n\\tuniform float displacementScale;\\n\\tuniform float displacementBias;\\n#endif\\n\",\n      de = \"#ifdef USE_DISPLACEMENTMAP\\n\\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\\n#endif\\n\",\n      ee = \"#ifdef USE_EMISSIVEMAP\\n\\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\\n\\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\\n\\ttotalEmissiveRadiance *= emissiveColor.rgb;\\n#endif\\n\",\n      fe = \"#ifdef USE_EMISSIVEMAP\\n\\tuniform sampler2D emissiveMap;\\n#endif\\n\",\n      ge = \"  gl_FragColor = linearToOutputTexel( gl_FragColor );\\n\",\n      he = \"\\nvec4 LinearToLinear( in vec4 value ) {\\n\\treturn value;\\n}\\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\\n\\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\\n}\\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\\n\\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\\n}\\nvec4 sRGBToLinear( in vec4 value ) {\\n\\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\\n}\\nvec4 LinearTosRGB( in vec4 value ) {\\n\\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\\n}\\nvec4 RGBEToLinear( in vec4 value ) {\\n\\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\\n}\\nvec4 LinearToRGBE( in vec4 value ) {\\n\\tfloat maxComponent = max( max( value.r, value.g ), value.b );\\n\\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\\n\\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\\n}\\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\\n\\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\\n}\\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\\n\\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\\n\\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\\n\\tM            = ceil( M * 255.0 ) / 255.0;\\n\\treturn vec4( value.rgb / ( M * maxRange ), M );\\n}\\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\\n\\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\\n}\\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\\n\\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\\n\\tfloat D      = max( maxRange / maxRGB, 1.0 );\\n\\tD            = min( floor( D ) / 255.0, 1.0 );\\n\\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\\n}\\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\\nvec4 LinearToLogLuv( in vec4 value )  {\\n\\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\\n\\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\\n\\tvec4 vResult;\\n\\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\\n\\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\\n\\tvResult.w = fract(Le);\\n\\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\\n\\treturn vResult;\\n}\\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\\nvec4 LogLuvToLinear( in vec4 value ) {\\n\\tfloat Le = value.z * 255.0 + value.w;\\n\\tvec3 Xp_Y_XYZp;\\n\\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\\n\\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\\n\\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\\n\\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\\n\\treturn vec4( max(vRGB, 0.0), 1.0 );\\n}\\n\",\n      ie = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\\n\\t\\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#else\\n\\t\\tvec3 reflectVec = vReflect;\\n\\t#endif\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\\t\\tvec2 sampleUV;\\n\\t\\treflectVec = normalize( reflectVec );\\n\\t\\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\n\\t\\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\\t\\tvec4 envColor = texture2D( envMap, sampleUV );\\n\\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\\t\\treflectVec = normalize( reflectVec );\\n\\t\\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\\n\\t\\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\\n\\t#else\\n\\t\\tvec4 envColor = vec4( 0.0 );\\n\\t#endif\\n\\tenvColor = envMapTexelToLinear( envColor );\\n\\t#ifdef ENVMAP_BLENDING_MULTIPLY\\n\\t\\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_MIX )\\n\\t\\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_ADD )\\n\\t\\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\n\\t#endif\\n#endif\\n\",\n      je = \"#if defined( USE_ENVMAP ) || defined( PHYSICAL )\\n\\tuniform float reflectivity;\\n\\tuniform float envMapIntensity;\\n#endif\\n#ifdef USE_ENVMAP\\n\\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t#endif\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tuniform samplerCube envMap;\\n\\t#else\\n\\t\\tuniform sampler2D envMap;\\n\\t#endif\\n\\tuniform float flipEnvMap;\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\\n\\t\\tuniform float refractionRatio;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t#endif\\n#endif\\n\",\n      ke = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t\\tuniform float refractionRatio;\\n\\t#endif\\n#endif\\n\",\n      le = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvWorldPosition = worldPosition.xyz;\\n\\t#else\\n\\t\\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\\t\\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvReflect = reflect( cameraToVertex, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#endif\\n#endif\\n\",\n      me = \"\\n#ifdef USE_FOG\\nfogDepth = -mvPosition.z;\\n#endif\",\n      ne = \"#ifdef USE_FOG\\n  varying float fogDepth;\\n#endif\\n\",\n      oe = \"#ifdef USE_FOG\\n\\t#ifdef FOG_EXP2\\n\\t\\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\\n\\t#else\\n\\t\\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\\n\\t#endif\\n\\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\\n#endif\\n\",\n      pe = \"#ifdef USE_FOG\\n\\tuniform vec3 fogColor;\\n\\tvarying float fogDepth;\\n\\t#ifdef FOG_EXP2\\n\\t\\tuniform float fogDensity;\\n\\t#else\\n\\t\\tuniform float fogNear;\\n\\t\\tuniform float fogFar;\\n\\t#endif\\n#endif\\n\",\n      qe = \"#ifdef TOON\\n\\tuniform sampler2D gradientMap;\\n\\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\\n\\t\\tfloat dotNL = dot( normal, lightDirection );\\n\\t\\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\\n\\t\\t#ifdef USE_GRADIENTMAP\\n\\t\\t\\treturn texture2D( gradientMap, coord ).rgb;\\n\\t\\t#else\\n\\t\\t\\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\\n\\t\\t#endif\\n\\t}\\n#endif\\n\",\n      re = \"#ifdef USE_LIGHTMAP\\n\\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n#endif\\n\",\n      se = \"#ifdef USE_LIGHTMAP\\n\\tuniform sampler2D lightMap;\\n\\tuniform float lightMapIntensity;\\n#endif\",\n      te = \"vec3 diffuse = vec3( 1.0 );\\nGeometricContext geometry;\\ngeometry.position = mvPosition.xyz;\\ngeometry.normal = normalize( transformedNormal );\\ngeometry.viewDir = normalize( -mvPosition.xyz );\\nGeometricContext backGeometry;\\nbackGeometry.position = geometry.position;\\nbackGeometry.normal = -geometry.normal;\\nbackGeometry.viewDir = geometry.viewDir;\\nvLightFront = vec3( 0.0 );\\n#ifdef DOUBLE_SIDED\\n\\tvLightBack = vec3( 0.0 );\\n#endif\\nIncidentLight directLight;\\nfloat dotNL;\\nvec3 directLightColor_Diffuse;\\n#if NUM_POINT_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_DIR_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\\n\\t\\t#endif\\n\\t}\\n#endif\\n\",\n      ue = \"uniform vec3 ambientLightColor;\\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\\n\\tvec3 irradiance = ambientLightColor;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treturn irradiance;\\n}\\n#if NUM_DIR_LIGHTS > 0\\n\\tstruct DirectionalLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t};\\n\\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\\n\\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tdirectLight.color = directionalLight.color;\\n\\t\\tdirectLight.direction = directionalLight.direction;\\n\\t\\tdirectLight.visible = true;\\n\\t}\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\\tstruct PointLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t\\tfloat shadowCameraNear;\\n\\t\\tfloat shadowCameraFar;\\n\\t};\\n\\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\\n\\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tvec3 lVector = pointLight.position - geometry.position;\\n\\t\\tdirectLight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tdirectLight.color = pointLight.color;\\n\\t\\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\\n\\t\\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\\n\\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\tstruct SpotLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t\\tfloat coneCos;\\n\\t\\tfloat penumbraCos;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t};\\n\\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\\n\\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\\n\\t\\tvec3 lVector = spotLight.position - geometry.position;\\n\\t\\tdirectLight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tfloat angleCos = dot( directLight.direction, spotLight.direction );\\n\\t\\tif ( angleCos > spotLight.coneCos ) {\\n\\t\\t\\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\\n\\t\\t\\tdirectLight.color = spotLight.color;\\n\\t\\t\\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\\n\\t\\t\\tdirectLight.visible = true;\\n\\t\\t} else {\\n\\t\\t\\tdirectLight.color = vec3( 0.0 );\\n\\t\\t\\tdirectLight.visible = false;\\n\\t\\t}\\n\\t}\\n#endif\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\\tstruct RectAreaLight {\\n\\t\\tvec3 color;\\n\\t\\tvec3 position;\\n\\t\\tvec3 halfWidth;\\n\\t\\tvec3 halfHeight;\\n\\t};\\n\\tuniform sampler2D ltcMat;\\tuniform sampler2D ltcMag;\\n\\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\tstruct HemisphereLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 skyColor;\\n\\t\\tvec3 groundColor;\\n\\t};\\n\\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\\n\\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\\n\\t\\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\\n\\t\\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\n\\t\\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tirradiance *= PI;\\n\\t\\t#endif\\n\\t\\treturn irradiance;\\n\\t}\\n#endif\\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\\n\\t\\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\t\\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\\t\\t\\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\\n\\t\\t#else\\n\\t\\t\\tvec4 envMapColor = vec4( 0.0 );\\n\\t\\t#endif\\n\\t\\treturn PI * envMapColor.rgb * envMapIntensity;\\n\\t}\\n\\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\\t\\tfloat maxMIPLevelScalar = float( maxMIPLevel );\\n\\t\\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\\n\\t\\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\\n\\t}\\n\\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\\n\\t\\t#endif\\n\\t\\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\n\\t\\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\t\\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\\t\\t\\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\\n\\t\\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\\t\\t\\tvec2 sampleUV;\\n\\t\\t\\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\n\\t\\t\\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\\t\\t\\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#endif\\n\\t\\treturn envMapColor.rgb * envMapIntensity;\\n\\t}\\n#endif\\n\",\n      ve = \"BlinnPhongMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\\nmaterial.specularColor = specular;\\nmaterial.specularShininess = shininess;\\nmaterial.specularStrength = specularStrength;\\n\",\n      we = \"varying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\nstruct BlinnPhongMaterial {\\n\\tvec3\\tdiffuseColor;\\n\\tvec3\\tspecularColor;\\n\\tfloat\\tspecularShininess;\\n\\tfloat\\tspecularStrength;\\n};\\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t#ifdef TOON\\n\\t\\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\\n\\t#else\\n\\t\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\t\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#endif\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\\n}\\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_BlinnPhong\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_BlinnPhong\\n#define Material_LightProbeLOD( material )\\t(0)\\n\",\n      xe = \"PhysicalMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\\n#ifdef STANDARD\\n\\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\\n#else\\n\\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\\n\\tmaterial.clearCoat = saturate( clearCoat );\\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\\n#endif\\n\",\n      ye = \"struct PhysicalMaterial {\\n\\tvec3\\tdiffuseColor;\\n\\tfloat\\tspecularRoughness;\\n\\tvec3\\tspecularColor;\\n\\t#ifndef STANDARD\\n\\t\\tfloat clearCoat;\\n\\t\\tfloat clearCoatRoughness;\\n\\t#endif\\n};\\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\\n\\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\\n}\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t\\tvec3 normal = geometry.normal;\\n\\t\\tvec3 viewDir = geometry.viewDir;\\n\\t\\tvec3 position = geometry.position;\\n\\t\\tvec3 lightPos = rectAreaLight.position;\\n\\t\\tvec3 halfWidth = rectAreaLight.halfWidth;\\n\\t\\tvec3 halfHeight = rectAreaLight.halfHeight;\\n\\t\\tvec3 lightColor = rectAreaLight.color;\\n\\t\\tfloat roughness = material.specularRoughness;\\n\\t\\tvec3 rectCoords[ 4 ];\\n\\t\\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\\t\\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\\n\\t\\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\\n\\t\\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\\n\\t\\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\\n\\t\\tfloat norm = texture2D( ltcMag, uv ).a;\\n\\t\\tvec4 t = texture2D( ltcMat, uv );\\n\\t\\tmat3 mInv = mat3(\\n\\t\\t\\tvec3(   1,   0, t.y ),\\n\\t\\t\\tvec3(   0, t.z,   0 ),\\n\\t\\t\\tvec3( t.w,   0, t.x )\\n\\t\\t);\\n\\t\\treflectedLight.directSpecular += lightColor * material.specularColor * norm * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\\n\\t\\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1 ), rectCoords );\\n\\t}\\n#endif\\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\t#ifndef STANDARD\\n\\t\\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\\n\\t#else\\n\\t\\tfloat clearCoatDHR = 0.0;\\n\\t#endif\\n\\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\\n\\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\t#ifndef STANDARD\\n\\t\\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\\t#endif\\n}\\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t#ifndef STANDARD\\n\\t\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\t\\tfloat dotNL = dotNV;\\n\\t\\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\\n\\t#else\\n\\t\\tfloat clearCoatDHR = 0.0;\\n\\t#endif\\n\\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\\n\\t#ifndef STANDARD\\n\\t\\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\\t#endif\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_Physical\\n#define RE_Direct_RectArea\\t\\tRE_Direct_RectArea_Physical\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_Physical\\n#define RE_IndirectSpecular\\t\\tRE_IndirectSpecular_Physical\\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\\n\\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\\n}\\n\",\n      ze = \"\\nGeometricContext geometry;\\ngeometry.position = - vViewPosition;\\ngeometry.normal = normal;\\ngeometry.viewDir = normalize( vViewPosition );\\nIncidentLight directLight;\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tPointLight pointLight;\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tpointLight = pointLights[ i ];\\n\\t\\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tSpotLight spotLight;\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tspotLight = spotLights[ i ];\\n\\t\\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tDirectionalLight directionalLight;\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\\n\\tRectAreaLight rectAreaLight;\\n\\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\\n\\t\\trectAreaLight = rectAreaLights[ i ];\\n\\t\\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if defined( RE_IndirectDiffuse )\\n\\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tlightMapIrradiance *= PI;\\n\\t\\t#endif\\n\\t\\tirradiance += lightMapIrradiance;\\n\\t#endif\\n\\t#if ( NUM_HEMI_LIGHTS > 0 )\\n\\t\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\t\\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\\t\\t}\\n\\t#endif\\n\\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\\n\\t#endif\\n\\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\\n#endif\\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\\n\\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\\n\\t#ifndef STANDARD\\n\\t\\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\\n\\t#else\\n\\t\\tvec3 clearCoatRadiance = vec3( 0.0 );\\n\\t#endif\\n\\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\\n#endif\\n\",\n      Ae = \"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\\n\\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\\n#endif\",\n      Be = \"#ifdef USE_LOGDEPTHBUF\\n\\tuniform float logDepthBufFC;\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvarying float vFragDepth;\\n\\t#endif\\n#endif\\n\",\n      Ce = \"#ifdef USE_LOGDEPTHBUF\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvarying float vFragDepth;\\n\\t#endif\\n\\tuniform float logDepthBufFC;\\n#endif\",\n      De = \"#ifdef USE_LOGDEPTHBUF\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvFragDepth = 1.0 + gl_Position.w;\\n\\t#else\\n\\t\\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\\n\\t\\tgl_Position.z *= gl_Position.w;\\n\\t#endif\\n#endif\\n\",\n      Ee = \"#ifdef USE_MAP\\n\\tvec4 texelColor = texture2D( map, vUv );\\n\\ttexelColor = mapTexelToLinear( texelColor );\\n\\tdiffuseColor *= texelColor;\\n#endif\\n\",\n      Fe = \"#ifdef USE_MAP\\n\\tuniform sampler2D map;\\n#endif\\n\",\n      Ge = \"#ifdef USE_MAP\\n\\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\\n\\tvec4 mapTexel = texture2D( map, uv );\\n\\tdiffuseColor *= mapTexelToLinear( mapTexel );\\n#endif\\n\",\n      He = \"#ifdef USE_MAP\\n\\tuniform mat3 uvTransform;\\n\\tuniform sampler2D map;\\n#endif\\n\",\n      Ie = \"float metalnessFactor = metalness;\\n#ifdef USE_METALNESSMAP\\n\\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\\n\\tmetalnessFactor *= texelMetalness.b;\\n#endif\\n\",\n      Je = \"#ifdef USE_METALNESSMAP\\n\\tuniform sampler2D metalnessMap;\\n#endif\",\n      Ke = \"#ifdef USE_MORPHNORMALS\\n\\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\\n\\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\\n\\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\\n\\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\\n#endif\\n\",\n      Le = \"#ifdef USE_MORPHTARGETS\\n\\t#ifndef USE_MORPHNORMALS\\n\\tuniform float morphTargetInfluences[ 8 ];\\n\\t#else\\n\\tuniform float morphTargetInfluences[ 4 ];\\n\\t#endif\\n#endif\",\n      Me = \"#ifdef USE_MORPHTARGETS\\n\\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\\n\\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\\n\\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\\n\\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\\n\\t#ifndef USE_MORPHNORMALS\\n\\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\\n\\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\\n\\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\\n\\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\\n\\t#endif\\n#endif\\n\",\n      Ne = \"#ifdef FLAT_SHADED\\n\\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\\n\\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\\n\\tvec3 normal = normalize( cross( fdx, fdy ) );\\n#else\\n\\tvec3 normal = normalize( vNormal );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\\t#endif\\n#endif\\n#ifdef USE_NORMALMAP\\n\\tnormal = perturbNormal2Arb( -vViewPosition, normal );\\n#elif defined( USE_BUMPMAP )\\n\\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\\n#endif\\n\",\n      Oe = \"#ifdef USE_NORMALMAP\\n\\tuniform sampler2D normalMap;\\n\\tuniform vec2 normalScale;\\n\\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\\n\\t\\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\\n\\t\\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\\n\\t\\tvec2 st0 = dFdx( vUv.st );\\n\\t\\tvec2 st1 = dFdy( vUv.st );\\n\\t\\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\\n\\t\\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\\n\\t\\tvec3 N = normalize( surf_norm );\\n\\t\\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\\t\\tmapN.xy = normalScale * mapN.xy;\\n\\t\\tmat3 tsn = mat3( S, T, N );\\n\\t\\treturn normalize( tsn * mapN );\\n\\t}\\n#endif\\n\",\n      Pe = \"vec3 packNormalToRGB( const in vec3 normal ) {\\n\\treturn normalize( normal ) * 0.5 + 0.5;\\n}\\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\\n\\treturn 2.0 * rgb.xyz - 1.0;\\n}\\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\\nconst float ShiftRight8 = 1. / 256.;\\nvec4 packDepthToRGBA( const in float v ) {\\n\\tvec4 r = vec4( fract( v * PackFactors ), v );\\n\\tr.yzw -= r.xyz * ShiftRight8;\\treturn r * PackUpscale;\\n}\\nfloat unpackRGBAToDepth( const in vec4 v ) {\\n\\treturn dot( v, UnpackFactors );\\n}\\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\\n\\treturn ( viewZ + near ) / ( near - far );\\n}\\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\\n\\treturn linearClipZ * ( near - far ) - near;\\n}\\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\\n\\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\\n}\\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\\n\\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\\n}\\n\",\n      Qe = \"#ifdef PREMULTIPLIED_ALPHA\\n\\tgl_FragColor.rgb *= gl_FragColor.a;\\n#endif\\n\",\n      Re = \"vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\\ngl_Position = projectionMatrix * mvPosition;\\n\",\n      Se = \"#if defined( DITHERING )\\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\\n#endif\\n\",\n      Te = \"#if defined( DITHERING )\\n\\tvec3 dithering( vec3 color ) {\\n\\t\\tfloat grid_position = rand( gl_FragCoord.xy );\\n\\t\\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\\n\\t\\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\\n\\t\\treturn color + dither_shift_RGB;\\n\\t}\\n#endif\\n\",\n      Ue = \"float roughnessFactor = roughness;\\n#ifdef USE_ROUGHNESSMAP\\n\\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\\n\\troughnessFactor *= texelRoughness.g;\\n#endif\\n\",\n      Ve = \"#ifdef USE_ROUGHNESSMAP\\n\\tuniform sampler2D roughnessMap;\\n#endif\",\n      We = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\t\\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\t\\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\t\\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\\t#endif\\n\\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\\n\\t\\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\\n\\t}\\n\\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\\n\\t\\tconst vec2 offset = vec2( 0.0, 1.0 );\\n\\t\\tvec2 texelSize = vec2( 1.0 ) / size;\\n\\t\\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\\n\\t\\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\\n\\t\\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\\n\\t\\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\\n\\t\\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\\n\\t\\tvec2 f = fract( uv * size + 0.5 );\\n\\t\\tfloat a = mix( lb, lt, f.y );\\n\\t\\tfloat b = mix( rb, rt, f.y );\\n\\t\\tfloat c = mix( a, b, f.x );\\n\\t\\treturn c;\\n\\t}\\n\\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\\t\\tfloat shadow = 1.0;\\n\\t\\tshadowCoord.xyz /= shadowCoord.w;\\n\\t\\tshadowCoord.z += shadowBias;\\n\\t\\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\n\\t\\tbool inFrustum = all( inFrustumVec );\\n\\t\\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\n\\t\\tbool frustumTest = all( frustumTestVec );\\n\\t\\tif ( frustumTest ) {\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx0 = - texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy0 = - texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx1 = + texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy1 = + texelSize.y * shadowRadius;\\n\\t\\t\\tshadow = (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx0 = - texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy0 = - texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx1 = + texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy1 = + texelSize.y * shadowRadius;\\n\\t\\t\\tshadow = (\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#else\\n\\t\\t\\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\\t\\t#endif\\n\\t\\t}\\n\\t\\treturn shadow;\\n\\t}\\n\\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\\n\\t\\tvec3 absV = abs( v );\\n\\t\\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\\n\\t\\tabsV *= scaleToCube;\\n\\t\\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\\n\\t\\tvec2 planar = v.xy;\\n\\t\\tfloat almostATexel = 1.5 * texelSizeY;\\n\\t\\tfloat almostOne = 1.0 - almostATexel;\\n\\t\\tif ( absV.z >= almostOne ) {\\n\\t\\t\\tif ( v.z > 0.0 )\\n\\t\\t\\t\\tplanar.x = 4.0 - v.x;\\n\\t\\t} else if ( absV.x >= almostOne ) {\\n\\t\\t\\tfloat signX = sign( v.x );\\n\\t\\t\\tplanar.x = v.z * signX + 2.0 * signX;\\n\\t\\t} else if ( absV.y >= almostOne ) {\\n\\t\\t\\tfloat signY = sign( v.y );\\n\\t\\t\\tplanar.x = v.x + 2.0 * signY + 2.0;\\n\\t\\t\\tplanar.y = v.z * signY - 2.0;\\n\\t\\t}\\n\\t\\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\\n\\t}\\n\\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\\n\\t\\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\\n\\t\\tvec3 lightToPosition = shadowCoord.xyz;\\n\\t\\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\\t\\tdp += shadowBias;\\n\\t\\tvec3 bd3D = normalize( lightToPosition );\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\t\\t\\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\\n\\t\\t\\treturn (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#else\\n\\t\\t\\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\\n\\t\\t#endif\\n\\t}\\n#endif\\n\",\n      Xe = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\t\\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\t\\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\t\\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\\t#endif\\n#endif\\n\",\n      Ye = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n#endif\\n\",\n      Ze = \"float getShadowMask() {\\n\\tfloat shadow = 1.0;\\n\\t#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\tDirectionalLight directionalLight;\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\tSpotLight spotLight;\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tspotLight = spotLights[ i ];\\n\\t\\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\tPointLight pointLight;\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tpointLight = pointLights[ i ];\\n\\t\\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#endif\\n\\treturn shadow;\\n}\\n\",\n      $e = \"#ifdef USE_SKINNING\\n\\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\n\\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n\\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n\\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\n#endif\",\n      _e = \"#ifdef USE_SKINNING\\n\\tuniform mat4 bindMatrix;\\n\\tuniform mat4 bindMatrixInverse;\\n\\t#ifdef BONE_TEXTURE\\n\\t\\tuniform sampler2D boneTexture;\\n\\t\\tuniform int boneTextureSize;\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\t\\tfloat j = i * 4.0;\\n\\t\\t\\tfloat x = mod( j, float( boneTextureSize ) );\\n\\t\\t\\tfloat y = floor( j / float( boneTextureSize ) );\\n\\t\\t\\tfloat dx = 1.0 / float( boneTextureSize );\\n\\t\\t\\tfloat dy = 1.0 / float( boneTextureSize );\\n\\t\\t\\ty = dy * ( y + 0.5 );\\n\\t\\t\\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\n\\t\\t\\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\n\\t\\t\\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\n\\t\\t\\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\n\\t\\t\\tmat4 bone = mat4( v1, v2, v3, v4 );\\n\\t\\t\\treturn bone;\\n\\t\\t}\\n\\t#else\\n\\t\\tuniform mat4 boneMatrices[ MAX_BONES ];\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\t\\tmat4 bone = boneMatrices[ int(i) ];\\n\\t\\t\\treturn bone;\\n\\t\\t}\\n\\t#endif\\n#endif\\n\",\n      af = \"#ifdef USE_SKINNING\\n\\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\n\\tvec4 skinned = vec4( 0.0 );\\n\\tskinned += boneMatX * skinVertex * skinWeight.x;\\n\\tskinned += boneMatY * skinVertex * skinWeight.y;\\n\\tskinned += boneMatZ * skinVertex * skinWeight.z;\\n\\tskinned += boneMatW * skinVertex * skinWeight.w;\\n\\ttransformed = ( bindMatrixInverse * skinned ).xyz;\\n#endif\\n\",\n      bf = \"#ifdef USE_SKINNING\\n\\tmat4 skinMatrix = mat4( 0.0 );\\n\\tskinMatrix += skinWeight.x * boneMatX;\\n\\tskinMatrix += skinWeight.y * boneMatY;\\n\\tskinMatrix += skinWeight.z * boneMatZ;\\n\\tskinMatrix += skinWeight.w * boneMatW;\\n\\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\\n\\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\n#endif\\n\",\n      cf = \"float specularStrength;\\n#ifdef USE_SPECULARMAP\\n\\tvec4 texelSpecular = texture2D( specularMap, vUv );\\n\\tspecularStrength = texelSpecular.r;\\n#else\\n\\tspecularStrength = 1.0;\\n#endif\",\n      df = \"#ifdef USE_SPECULARMAP\\n\\tuniform sampler2D specularMap;\\n#endif\",\n      ef = \"#if defined( TONE_MAPPING )\\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\\n#endif\\n\",\n      ff = \"#ifndef saturate\\n\\t#define saturate(a) clamp( a, 0.0, 1.0 )\\n#endif\\nuniform float toneMappingExposure;\\nuniform float toneMappingWhitePoint;\\nvec3 LinearToneMapping( vec3 color ) {\\n\\treturn toneMappingExposure * color;\\n}\\nvec3 ReinhardToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\treturn saturate( color / ( vec3( 1.0 ) + color ) );\\n}\\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\\nvec3 Uncharted2ToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\\n}\\nvec3 OptimizedCineonToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\tcolor = max( vec3( 0.0 ), color - 0.004 );\\n\\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\\n}\\n\",\n      gf = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvarying vec2 vUv;\\n#endif\",\n      hf = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvarying vec2 vUv;\\n\\tuniform mat3 uvTransform;\\n#endif\\n\",\n      jf = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\\n#endif\",\n      kf = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvarying vec2 vUv2;\\n#endif\",\n      lf = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tattribute vec2 uv2;\\n\\tvarying vec2 vUv2;\\n#endif\",\n      mf = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvUv2 = uv2;\\n#endif\",\n      nf = \"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\\n\\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\\n#endif\\n\",\n      of = \"uniform samplerCube tCube;\\nuniform float tFlip;\\nuniform float opacity;\\nvarying vec3 vWorldPosition;\\nvoid main() {\\n\\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\\n\\tgl_FragColor.a *= opacity;\\n}\\n\",\n      pf = \"varying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tvWorldPosition = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\tgl_Position.z = gl_Position.w;\\n}\\n\",\n      qf = \"#if DEPTH_PACKING == 3200\\n\\tuniform float opacity;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( 1.0 );\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tdiffuseColor.a = opacity;\\n\\t#endif\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <logdepthbuf_fragment>\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\\n\\t#elif DEPTH_PACKING == 3201\\n\\t\\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\\n\\t#endif\\n}\\n\",\n      rf = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_DISPLACEMENTMAP\\n\\t\\t#include <beginnormal_vertex>\\n\\t\\t#include <morphnormal_vertex>\\n\\t\\t#include <skinnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n}\\n\",\n      sf = \"#define DISTANCE\\nuniform vec3 referencePosition;\\nuniform float nearDistance;\\nuniform float farDistance;\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main () {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( 1.0 );\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\tfloat dist = length( vWorldPosition - referencePosition );\\n\\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\\n\\tdist = saturate( dist );\\n\\tgl_FragColor = packDepthToRGBA( dist );\\n}\\n\",\n      tf = \"#define DISTANCE\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_DISPLACEMENTMAP\\n\\t\\t#include <beginnormal_vertex>\\n\\t\\t#include <morphnormal_vertex>\\n\\t\\t#include <skinnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvWorldPosition = worldPosition.xyz;\\n}\\n\",\n      uf = \"uniform sampler2D tEquirect;\\nvarying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tvec3 direction = normalize( vWorldPosition );\\n\\tvec2 sampleUV;\\n\\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\n\\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\\n\\tgl_FragColor = texture2D( tEquirect, sampleUV );\\n}\\n\",\n      vf = \"varying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tvWorldPosition = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n}\\n\",\n      wf = \"uniform vec3 diffuse;\\nuniform float opacity;\\nuniform float dashSize;\\nuniform float totalSize;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\\n\\t\\tdiscard;\\n\\t}\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <color_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\",\n      xf = \"uniform float scale;\\nattribute float lineDistance;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <color_vertex>\\n\\tvLineDistance = scale * lineDistance;\\n\\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n\\tgl_Position = projectionMatrix * mvPosition;\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <fog_vertex>\\n}\\n\",\n      yf = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n\\t#else\\n\\t\\treflectedLight.indirectDiffuse += vec3( 1.0 );\\n\\t#endif\\n\\t#include <aomap_fragment>\\n\\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\\n\\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\",\n      zf = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_ENVMAP\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <fog_vertex>\\n}\\n\",\n      Af = \"uniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <emissivemap_fragment>\\n\\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\\n\\t#include <lightmap_fragment>\\n\\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\\n\\t#else\\n\\t\\treflectedLight.directDiffuse = vLightFront;\\n\\t#endif\\n\\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\\n\",\n      Bf = \"#define LAMBERT\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <lights_lambert_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\\n\",\n      Cf = \"#define PHONG\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float shininess;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <gradientmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <lights_phong_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <normal_fragment>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_phong_fragment>\\n\\t#include <lights_template>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\\n\",\n      Df = \"#define PHONG\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\\n\",\n      Ef = \"#define PHYSICAL\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float roughness;\\nuniform float metalness;\\nuniform float opacity;\\n#ifndef STANDARD\\n\\tuniform float clearCoat;\\n\\tuniform float clearCoatRoughness;\\n#endif\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <cube_uv_reflection_fragment>\\n#include <lights_pars>\\n#include <lights_physical_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <roughnessmap_pars_fragment>\\n#include <metalnessmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <roughnessmap_fragment>\\n\\t#include <metalnessmap_fragment>\\n\\t#include <normal_fragment>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_physical_fragment>\\n\\t#include <lights_template>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\\n\",\n      Ff = \"#define PHYSICAL\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\\n\",\n      Gf = \"#define NORMAL\\nuniform float opacity;\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\nvoid main() {\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <normal_fragment>\\n\\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\\n}\\n\",\n      Hf = \"#define NORMAL\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\\n\\tvViewPosition = - mvPosition.xyz;\\n#endif\\n}\\n\",\n      If = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <map_particle_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_particle_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphatest_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\",\n      Jf = \"uniform float size;\\nuniform float scale;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <color_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\t#ifdef USE_SIZEATTENUATION\\n\\t\\tgl_PointSize = size * ( scale / - mvPosition.z );\\n\\t#else\\n\\t\\tgl_PointSize = size;\\n\\t#endif\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\\n\",\n      Kf = \"uniform vec3 color;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\nvoid main() {\\n\\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\\n\\t#include <fog_fragment>\\n}\\n\",\n      Lf = \"#include <fog_pars_vertex>\\n#include <shadowmap_pars_vertex>\\nvoid main() {\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\\n\",\n      Mf = {\n    alphamap_fragment: Kd,\n    alphamap_pars_fragment: Ld,\n    alphatest_fragment: Md,\n    aomap_fragment: Nd,\n    aomap_pars_fragment: Od,\n    begin_vertex: Pd,\n    beginnormal_vertex: Qd,\n    bsdfs: Rd,\n    bumpmap_pars_fragment: Sd,\n    clipping_planes_fragment: Td,\n    clipping_planes_pars_fragment: Ud,\n    clipping_planes_pars_vertex: Vd,\n    clipping_planes_vertex: Wd,\n    color_fragment: Xd,\n    color_pars_fragment: Yd,\n    color_pars_vertex: Zd,\n    color_vertex: $d,\n    common: _d,\n    cube_uv_reflection_fragment: ae,\n    defaultnormal_vertex: be,\n    displacementmap_pars_vertex: ce,\n    displacementmap_vertex: de,\n    emissivemap_fragment: ee,\n    emissivemap_pars_fragment: fe,\n    encodings_fragment: ge,\n    encodings_pars_fragment: he,\n    envmap_fragment: ie,\n    envmap_pars_fragment: je,\n    envmap_pars_vertex: ke,\n    envmap_vertex: le,\n    fog_vertex: me,\n    fog_pars_vertex: ne,\n    fog_fragment: oe,\n    fog_pars_fragment: pe,\n    gradientmap_pars_fragment: qe,\n    lightmap_fragment: re,\n    lightmap_pars_fragment: se,\n    lights_lambert_vertex: te,\n    lights_pars: ue,\n    lights_phong_fragment: ve,\n    lights_phong_pars_fragment: we,\n    lights_physical_fragment: xe,\n    lights_physical_pars_fragment: ye,\n    lights_template: ze,\n    logdepthbuf_fragment: Ae,\n    logdepthbuf_pars_fragment: Be,\n    logdepthbuf_pars_vertex: Ce,\n    logdepthbuf_vertex: De,\n    map_fragment: Ee,\n    map_pars_fragment: Fe,\n    map_particle_fragment: Ge,\n    map_particle_pars_fragment: He,\n    metalnessmap_fragment: Ie,\n    metalnessmap_pars_fragment: Je,\n    morphnormal_vertex: Ke,\n    morphtarget_pars_vertex: Le,\n    morphtarget_vertex: Me,\n    normal_fragment: Ne,\n    normalmap_pars_fragment: Oe,\n    packing: Pe,\n    premultiplied_alpha_fragment: Qe,\n    project_vertex: Re,\n    dithering_fragment: Se,\n    dithering_pars_fragment: Te,\n    roughnessmap_fragment: Ue,\n    roughnessmap_pars_fragment: Ve,\n    shadowmap_pars_fragment: We,\n    shadowmap_pars_vertex: Xe,\n    shadowmap_vertex: Ye,\n    shadowmask_pars_fragment: Ze,\n    skinbase_vertex: $e,\n    skinning_pars_vertex: _e,\n    skinning_vertex: af,\n    skinnormal_vertex: bf,\n    specularmap_fragment: cf,\n    specularmap_pars_fragment: df,\n    tonemapping_fragment: ef,\n    tonemapping_pars_fragment: ff,\n    uv_pars_fragment: gf,\n    uv_pars_vertex: hf,\n    uv_vertex: jf,\n    uv2_pars_fragment: kf,\n    uv2_pars_vertex: lf,\n    uv2_vertex: mf,\n    worldpos_vertex: nf,\n    cube_frag: of,\n    cube_vert: pf,\n    depth_frag: qf,\n    depth_vert: rf,\n    distanceRGBA_frag: sf,\n    distanceRGBA_vert: tf,\n    equirect_frag: uf,\n    equirect_vert: vf,\n    linedashed_frag: wf,\n    linedashed_vert: xf,\n    meshbasic_frag: yf,\n    meshbasic_vert: zf,\n    meshlambert_frag: Af,\n    meshlambert_vert: Bf,\n    meshphong_frag: Cf,\n    meshphong_vert: Df,\n    meshphysical_frag: Ef,\n    meshphysical_vert: Ff,\n    normal_frag: Gf,\n    normal_vert: Hf,\n    points_frag: If,\n    points_vert: Jf,\n    shadow_frag: Kf,\n    shadow_vert: Lf\n  },\n      Nf = {\n    basic: {\n      uniforms: Jd.merge([Id.common, Id.specularmap, Id.envmap, Id.aomap, Id.lightmap, Id.fog]),\n      vertexShader: Mf.meshbasic_vert,\n      fragmentShader: Mf.meshbasic_frag\n    },\n    lambert: {\n      uniforms: Jd.merge([Id.common, Id.specularmap, Id.envmap, Id.aomap, Id.lightmap, Id.emissivemap, Id.fog, Id.lights, {\n        emissive: {\n          value: new U(0)\n        }\n      }]),\n      vertexShader: Mf.meshlambert_vert,\n      fragmentShader: Mf.meshlambert_frag\n    },\n    phong: {\n      uniforms: Jd.merge([Id.common, Id.specularmap, Id.envmap, Id.aomap, Id.lightmap, Id.emissivemap, Id.bumpmap, Id.normalmap, Id.displacementmap, Id.gradientmap, Id.fog, Id.lights, {\n        emissive: {\n          value: new U(0)\n        },\n        specular: {\n          value: new U(1118481)\n        },\n        shininess: {\n          value: 30\n        }\n      }]),\n      vertexShader: Mf.meshphong_vert,\n      fragmentShader: Mf.meshphong_frag\n    },\n    standard: {\n      uniforms: Jd.merge([Id.common, Id.envmap, Id.aomap, Id.lightmap, Id.emissivemap, Id.bumpmap, Id.normalmap, Id.displacementmap, Id.roughnessmap, Id.metalnessmap, Id.fog, Id.lights, {\n        emissive: {\n          value: new U(0)\n        },\n        roughness: {\n          value: .5\n        },\n        metalness: {\n          value: .5\n        },\n        envMapIntensity: {\n          value: 1\n        }\n      }]),\n      vertexShader: Mf.meshphysical_vert,\n      fragmentShader: Mf.meshphysical_frag\n    },\n    points: {\n      uniforms: Jd.merge([Id.points, Id.fog]),\n      vertexShader: Mf.points_vert,\n      fragmentShader: Mf.points_frag\n    },\n    dashed: {\n      uniforms: Jd.merge([Id.common, Id.fog, {\n        scale: {\n          value: 1\n        },\n        dashSize: {\n          value: 1\n        },\n        totalSize: {\n          value: 2\n        }\n      }]),\n      vertexShader: Mf.linedashed_vert,\n      fragmentShader: Mf.linedashed_frag\n    },\n    depth: {\n      uniforms: Jd.merge([Id.common, Id.displacementmap]),\n      vertexShader: Mf.depth_vert,\n      fragmentShader: Mf.depth_frag\n    },\n    normal: {\n      uniforms: Jd.merge([Id.common, Id.bumpmap, Id.normalmap, Id.displacementmap, {\n        opacity: {\n          value: 1\n        }\n      }]),\n      vertexShader: Mf.normal_vert,\n      fragmentShader: Mf.normal_frag\n    },\n    cube: {\n      uniforms: {\n        tCube: {\n          value: null\n        },\n        tFlip: {\n          value: -1\n        },\n        opacity: {\n          value: 1\n        }\n      },\n      vertexShader: Mf.cube_vert,\n      fragmentShader: Mf.cube_frag\n    },\n    equirect: {\n      uniforms: {\n        tEquirect: {\n          value: null\n        }\n      },\n      vertexShader: Mf.equirect_vert,\n      fragmentShader: Mf.equirect_frag\n    },\n    distanceRGBA: {\n      uniforms: Jd.merge([Id.common, Id.displacementmap, {\n        referencePosition: {\n          value: new f()\n        },\n        nearDistance: {\n          value: 1\n        },\n        farDistance: {\n          value: 1e3\n        }\n      }]),\n      vertexShader: Mf.distanceRGBA_vert,\n      fragmentShader: Mf.distanceRGBA_frag\n    },\n    shadow: {\n      uniforms: Jd.merge([Id.lights, Id.fog, {\n        color: {\n          value: new U(0)\n        },\n        opacity: {\n          value: 1\n        }\n      }]),\n      vertexShader: Mf.shadow_vert,\n      fragmentShader: Mf.shadow_frag\n    }\n  };\n  Nf.physical = {\n    uniforms: Jd.merge([Nf.standard.uniforms, {\n      clearCoat: {\n        value: 0\n      },\n      clearCoatRoughness: {\n        value: 0\n      }\n    }]),\n    vertexShader: Mf.meshphysical_vert,\n    fragmentShader: Mf.meshphysical_frag\n  }, Object.assign(V.prototype, {\n    set: function set(a, b) {\n      return this.min.copy(a), this.max.copy(b), this;\n    },\n    setFromPoints: function setFromPoints(a) {\n      this.makeEmpty();\n\n      for (var b = 0, c = a.length; b < c; b++) {\n        this.expandByPoint(a[b]);\n      }\n\n      return this;\n    },\n    setFromCenterAndSize: function () {\n      var a = new c();\n      return function (b, c) {\n        var d = a.copy(c).multiplyScalar(.5);\n        return this.min.copy(b).sub(d), this.max.copy(b).add(d), this;\n      };\n    }(),\n    clone: function clone() {\n      return new this.constructor().copy(this);\n    },\n    copy: function copy(a) {\n      return this.min.copy(a.min), this.max.copy(a.max), this;\n    },\n    makeEmpty: function makeEmpty() {\n      return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;\n    },\n    isEmpty: function isEmpty() {\n      return this.max.x < this.min.x || this.max.y < this.min.y;\n    },\n    getCenter: function getCenter(a) {\n      var b = a || new c();\n      return this.isEmpty() ? b.set(0, 0) : b.addVectors(this.min, this.max).multiplyScalar(.5);\n    },\n    getSize: function getSize(a) {\n      var b = a || new c();\n      return this.isEmpty() ? b.set(0, 0) : b.subVectors(this.max, this.min);\n    },\n    expandByPoint: function expandByPoint(a) {\n      return this.min.min(a), this.max.max(a), this;\n    },\n    expandByVector: function expandByVector(a) {\n      return this.min.sub(a), this.max.add(a), this;\n    },\n    expandByScalar: function expandByScalar(a) {\n      return this.min.addScalar(-a), this.max.addScalar(a), this;\n    },\n    containsPoint: function containsPoint(a) {\n      return !(a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y);\n    },\n    containsBox: function containsBox(a) {\n      return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y;\n    },\n    getParameter: function getParameter(a, b) {\n      return (b || new c()).set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y));\n    },\n    intersectsBox: function intersectsBox(a) {\n      return !(a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y);\n    },\n    clampPoint: function clampPoint(a, b) {\n      return (b || new c()).copy(a).clamp(this.min, this.max);\n    },\n    distanceToPoint: function () {\n      var a = new c();\n      return function (b) {\n        return a.copy(b).clamp(this.min, this.max).sub(b).length();\n      };\n    }(),\n    intersect: function intersect(a) {\n      return this.min.max(a.min), this.max.min(a.max), this;\n    },\n    union: function union(a) {\n      return this.min.min(a.min), this.max.max(a.max), this;\n    },\n    translate: function translate(a) {\n      return this.min.add(a), this.max.add(a), this;\n    },\n    equals: function equals(a) {\n      return a.min.equals(this.min) && a.max.equals(this.max);\n    }\n  }), X.prototype = Object.create(h.prototype), X.prototype.constructor = X;\n  var Of = 0;\n  Z.prototype = Object.assign(Object.create(b.prototype), {\n    constructor: Z,\n    isMaterial: !0,\n    onBeforeCompile: function onBeforeCompile() {},\n    setValues: function setValues(a) {\n      if (void 0 !== a) for (var b in a) {\n        var c = a[b];\n        if (void 0 !== c) {\n          if (\"shading\" !== b) {\n            var d = this[b];\n            void 0 !== d ? d && d.isColor ? d.set(c) : d && d.isVector3 && c && c.isVector3 ? d.copy(c) : this[b] = \"overdraw\" === b ? Number(c) : c : console.warn(\"THREE.\" + this.type + \": '\" + b + \"' is not a property of this material.\");\n          } else console.warn(\"THREE.\" + this.type + \": .shading has been removed. Use the boolean .flatShading instead.\"), this.flatShading = c === Jb;\n        } else console.warn(\"THREE.Material: '\" + b + \"' parameter is undefined.\");\n      }\n    },\n    toJSON: function toJSON(a) {\n      function b(a) {\n        var b = [];\n\n        for (var c in a) {\n          var d = a[c];\n          delete d.metadata, b.push(d);\n        }\n\n        return b;\n      }\n\n      var c = void 0 === a || \"string\" == typeof a;\n      c && (a = {\n        textures: {},\n        images: {}\n      });\n      var d = {\n        metadata: {\n          version: 4.5,\n          type: \"Material\",\n          generator: \"Material.toJSON\"\n        }\n      };\n\n      if (d.uuid = this.uuid, d.type = this.type, \"\" !== this.name && (d.name = this.name), this.color && this.color.isColor && (d.color = this.color.getHex()), void 0 !== this.roughness && (d.roughness = this.roughness), void 0 !== this.metalness && (d.metalness = this.metalness), this.emissive && this.emissive.isColor && (d.emissive = this.emissive.getHex()), 1 !== this.emissiveIntensity && (d.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (d.specular = this.specular.getHex()), void 0 !== this.shininess && (d.shininess = this.shininess), void 0 !== this.clearCoat && (d.clearCoat = this.clearCoat), void 0 !== this.clearCoatRoughness && (d.clearCoatRoughness = this.clearCoatRoughness), this.map && this.map.isTexture && (d.map = this.map.toJSON(a).uuid), this.alphaMap && this.alphaMap.isTexture && (d.alphaMap = this.alphaMap.toJSON(a).uuid), this.lightMap && this.lightMap.isTexture && (d.lightMap = this.lightMap.toJSON(a).uuid), this.bumpMap && this.bumpMap.isTexture && (d.bumpMap = this.bumpMap.toJSON(a).uuid, d.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (d.normalMap = this.normalMap.toJSON(a).uuid, d.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (d.displacementMap = this.displacementMap.toJSON(a).uuid, d.displacementScale = this.displacementScale, d.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (d.roughnessMap = this.roughnessMap.toJSON(a).uuid), this.metalnessMap && this.metalnessMap.isTexture && (d.metalnessMap = this.metalnessMap.toJSON(a).uuid), this.emissiveMap && this.emissiveMap.isTexture && (d.emissiveMap = this.emissiveMap.toJSON(a).uuid), this.specularMap && this.specularMap.isTexture && (d.specularMap = this.specularMap.toJSON(a).uuid), this.envMap && this.envMap.isTexture && (d.envMap = this.envMap.toJSON(a).uuid, d.reflectivity = this.reflectivity), this.gradientMap && this.gradientMap.isTexture && (d.gradientMap = this.gradientMap.toJSON(a).uuid), void 0 !== this.size && (d.size = this.size), void 0 !== this.sizeAttenuation && (d.sizeAttenuation = this.sizeAttenuation), this.blending !== Mb && (d.blending = this.blending), !0 === this.flatShading && (d.flatShading = this.flatShading), this.side !== Gb && (d.side = this.side), this.vertexColors !== Kb && (d.vertexColors = this.vertexColors), this.opacity < 1 && (d.opacity = this.opacity), !0 === this.transparent && (d.transparent = this.transparent), d.depthFunc = this.depthFunc, d.depthTest = this.depthTest, d.depthWrite = this.depthWrite, 0 !== this.rotation && (d.rotation = this.rotation), 1 !== this.linewidth && (d.linewidth = this.linewidth), void 0 !== this.dashSize && (d.dashSize = this.dashSize), void 0 !== this.gapSize && (d.gapSize = this.gapSize), void 0 !== this.scale && (d.scale = this.scale), !0 === this.dithering && (d.dithering = !0), this.alphaTest > 0 && (d.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (d.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (d.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (d.wireframeLinewidth = this.wireframeLinewidth), \"round\" !== this.wireframeLinecap && (d.wireframeLinecap = this.wireframeLinecap), \"round\" !== this.wireframeLinejoin && (d.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (d.morphTargets = !0), !0 === this.skinning && (d.skinning = !0), !1 === this.visible && (d.visible = !1), \"{}\" !== JSON.stringify(this.userData) && (d.userData = this.userData), c) {\n        var e = b(a.textures),\n            f = b(a.images);\n        e.length > 0 && (d.textures = e), f.length > 0 && (d.images = f);\n      }\n\n      return d;\n    },\n    clone: function clone() {\n      return new this.constructor().copy(this);\n    },\n    copy: function copy(a) {\n      this.name = a.name, this.fog = a.fog, this.lights = a.lights, this.blending = a.blending, this.side = a.side, this.flatShading = a.flatShading, this.vertexColors = a.vertexColors, this.opacity = a.opacity, this.transparent = a.transparent, this.blendSrc = a.blendSrc, this.blendDst = a.blendDst, this.blendEquation = a.blendEquation, this.blendSrcAlpha = a.blendSrcAlpha, this.blendDstAlpha = a.blendDstAlpha, this.blendEquationAlpha = a.blendEquationAlpha, this.depthFunc = a.depthFunc, this.depthTest = a.depthTest, this.depthWrite = a.depthWrite, this.colorWrite = a.colorWrite, this.precision = a.precision, this.polygonOffset = a.polygonOffset, this.polygonOffsetFactor = a.polygonOffsetFactor, this.polygonOffsetUnits = a.polygonOffsetUnits, this.dithering = a.dithering, this.alphaTest = a.alphaTest, this.premultipliedAlpha = a.premultipliedAlpha, this.overdraw = a.overdraw, this.visible = a.visible, this.userData = JSON.parse(JSON.stringify(a.userData)), this.clipShadows = a.clipShadows, this.clipIntersection = a.clipIntersection;\n      var b = a.clippingPlanes,\n          c = null;\n\n      if (null !== b) {\n        var d = b.length;\n        c = new Array(d);\n\n        for (var e = 0; e !== d; ++e) {\n          c[e] = b[e].clone();\n        }\n      }\n\n      return this.clippingPlanes = c, this;\n    },\n    dispose: function dispose() {\n      this.dispatchEvent({\n        type: \"dispose\"\n      });\n    }\n  }), $.prototype = Object.create(Z.prototype), $.prototype.constructor = $, $.prototype.isMeshDepthMaterial = !0, $.prototype.copy = function (a) {\n    return Z.prototype.copy.call(this, a), this.depthPacking = a.depthPacking, this.skinning = a.skinning, this.morphTargets = a.morphTargets, this.map = a.map, this.alphaMap = a.alphaMap, this.displacementMap = a.displacementMap, this.displacementScale = a.displacementScale, this.displacementBias = a.displacementBias, this.wireframe = a.wireframe, this.wireframeLinewidth = a.wireframeLinewidth, this;\n  }, _.prototype = Object.create(Z.prototype), _.prototype.constructor = _, _.prototype.isMeshDistanceMaterial = !0, _.prototype.copy = function (a) {\n    return Z.prototype.copy.call(this, a), this.referencePosition.copy(a.referencePosition), this.nearDistance = a.nearDistance, this.farDistance = a.farDistance, this.skinning = a.skinning, this.morphTargets = a.morphTargets, this.map = a.map, this.alphaMap = a.alphaMap, this.displacementMap = a.displacementMap, this.displacementScale = a.displacementScale, this.displacementBias = a.displacementBias, this;\n  }, Object.assign(aa.prototype, {\n    isBox3: !0,\n    set: function set(a, b) {\n      return this.min.copy(a), this.max.copy(b), this;\n    },\n    setFromArray: function setFromArray(a) {\n      for (var b = 1 / 0, c = 1 / 0, d = 1 / 0, e = -1 / 0, f = -1 / 0, g = -1 / 0, h = 0, i = a.length; h < i; h += 3) {\n        var j = a[h],\n            k = a[h + 1],\n            l = a[h + 2];\n        j < b && (b = j), k < c && (c = k), l < d && (d = l), j > e && (e = j), k > f && (f = k), l > g && (g = l);\n      }\n\n      return this.min.set(b, c, d), this.max.set(e, f, g), this;\n    },\n    setFromBufferAttribute: function setFromBufferAttribute(a) {\n      for (var b = 1 / 0, c = 1 / 0, d = 1 / 0, e = -1 / 0, f = -1 / 0, g = -1 / 0, h = 0, i = a.count; h < i; h++) {\n        var j = a.getX(h),\n            k = a.getY(h),\n            l = a.getZ(h);\n        j < b && (b = j), k < c && (c = k), l < d && (d = l), j > e && (e = j), k > f && (f = k), l > g && (g = l);\n      }\n\n      return this.min.set(b, c, d), this.max.set(e, f, g), this;\n    },\n    setFromPoints: function setFromPoints(a) {\n      this.makeEmpty();\n\n      for (var b = 0, c = a.length; b < c; b++) {\n        this.expandByPoint(a[b]);\n      }\n\n      return this;\n    },\n    setFromCenterAndSize: function () {\n      var a = new f();\n      return function (b, c) {\n        var d = a.copy(c).multiplyScalar(.5);\n        return this.min.copy(b).sub(d), this.max.copy(b).add(d), this;\n      };\n    }(),\n    setFromObject: function setFromObject(a) {\n      return this.makeEmpty(), this.expandByObject(a);\n    },\n    clone: function clone() {\n      return new this.constructor().copy(this);\n    },\n    copy: function copy(a) {\n      return this.min.copy(a.min), this.max.copy(a.max), this;\n    },\n    makeEmpty: function makeEmpty() {\n      return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;\n    },\n    isEmpty: function isEmpty() {\n      return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;\n    },\n    getCenter: function getCenter(a) {\n      var b = a || new f();\n      return this.isEmpty() ? b.set(0, 0, 0) : b.addVectors(this.min, this.max).multiplyScalar(.5);\n    },\n    getSize: function getSize(a) {\n      var b = a || new f();\n      return this.isEmpty() ? b.set(0, 0, 0) : b.subVectors(this.max, this.min);\n    },\n    expandByPoint: function expandByPoint(a) {\n      return this.min.min(a), this.max.max(a), this;\n    },\n    expandByVector: function expandByVector(a) {\n      return this.min.sub(a), this.max.add(a), this;\n    },\n    expandByScalar: function expandByScalar(a) {\n      return this.min.addScalar(-a), this.max.addScalar(a), this;\n    },\n    expandByObject: function () {\n      function a(a) {\n        var f = a.geometry;\n        if (void 0 !== f) if (f.isGeometry) {\n          var g = f.vertices;\n\n          for (c = 0, d = g.length; c < d; c++) {\n            e.copy(g[c]), e.applyMatrix4(a.matrixWorld), b.expandByPoint(e);\n          }\n        } else if (f.isBufferGeometry) {\n          var h = f.attributes.position;\n          if (void 0 !== h) for (c = 0, d = h.count; c < d; c++) {\n            e.fromBufferAttribute(h, c).applyMatrix4(a.matrixWorld), b.expandByPoint(e);\n          }\n        }\n      }\n\n      var b,\n          c,\n          d,\n          e = new f();\n      return function (c) {\n        return b = this, c.updateMatrixWorld(!0), c.traverse(a), this;\n      };\n    }(),\n    containsPoint: function containsPoint(a) {\n      return !(a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y || a.z < this.min.z || a.z > this.max.z);\n    },\n    containsBox: function containsBox(a) {\n      return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y && this.min.z <= a.min.z && a.max.z <= this.max.z;\n    },\n    getParameter: function getParameter(a, b) {\n      return (b || new f()).set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y), (a.z - this.min.z) / (this.max.z - this.min.z));\n    },\n    intersectsBox: function intersectsBox(a) {\n      return !(a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y || a.max.z < this.min.z || a.min.z > this.max.z);\n    },\n    intersectsSphere: function () {\n      var a = new f();\n      return function (b) {\n        return this.clampPoint(b.center, a), a.distanceToSquared(b.center) <= b.radius * b.radius;\n      };\n    }(),\n    intersectsPlane: function intersectsPlane(a) {\n      var b, c;\n      return a.normal.x > 0 ? (b = a.normal.x * this.min.x, c = a.normal.x * this.max.x) : (b = a.normal.x * this.max.x, c = a.normal.x * this.min.x), a.normal.y > 0 ? (b += a.normal.y * this.min.y, c += a.normal.y * this.max.y) : (b += a.normal.y * this.max.y, c += a.normal.y * this.min.y), a.normal.z > 0 ? (b += a.normal.z * this.min.z, c += a.normal.z * this.max.z) : (b += a.normal.z * this.max.z, c += a.normal.z * this.min.z), b <= a.constant && c >= a.constant;\n    },\n    clampPoint: function clampPoint(a, b) {\n      return (b || new f()).copy(a).clamp(this.min, this.max);\n    },\n    distanceToPoint: function () {\n      var a = new f();\n      return function (b) {\n        return a.copy(b).clamp(this.min, this.max).sub(b).length();\n      };\n    }(),\n    getBoundingSphere: function () {\n      var a = new f();\n      return function (b) {\n        var c = b || new ba();\n        return this.getCenter(c.center), c.radius = .5 * this.getSize(a).length(), c;\n      };\n    }(),\n    intersect: function intersect(a) {\n      return this.min.max(a.min), this.max.min(a.max), this.isEmpty() && this.makeEmpty(), this;\n    },\n    union: function union(a) {\n      return this.min.min(a.min), this.max.max(a.max), this;\n    },\n    applyMatrix4: function () {\n      var a = [new f(), new f(), new f(), new f(), new f(), new f(), new f(), new f()];\n      return function (b) {\n        return this.isEmpty() ? this : (a[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(b), a[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(b), a[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(b), a[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(b), a[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(b), a[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(b), a[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(b), a[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(b), this.setFromPoints(a), this);\n      };\n    }(),\n    translate: function translate(a) {\n      return this.min.add(a), this.max.add(a), this;\n    },\n    equals: function equals(a) {\n      return a.min.equals(this.min) && a.max.equals(this.max);\n    }\n  }), Object.assign(ba.prototype, {\n    set: function set(a, b) {\n      return this.center.copy(a), this.radius = b, this;\n    },\n    setFromPoints: function () {\n      var a = new aa();\n      return function (b, c) {\n        var d = this.center;\n        void 0 !== c ? d.copy(c) : a.setFromPoints(b).getCenter(d);\n\n        for (var e = 0, f = 0, g = b.length; f < g; f++) {\n          e = Math.max(e, d.distanceToSquared(b[f]));\n        }\n\n        return this.radius = Math.sqrt(e), this;\n      };\n    }(),\n    clone: function clone() {\n      return new this.constructor().copy(this);\n    },\n    copy: function copy(a) {\n      return this.center.copy(a.center), this.radius = a.radius, this;\n    },\n    empty: function empty() {\n      return this.radius <= 0;\n    },\n    containsPoint: function containsPoint(a) {\n      return a.distanceToSquared(this.center) <= this.radius * this.radius;\n    },\n    distanceToPoint: function distanceToPoint(a) {\n      return a.distanceTo(this.center) - this.radius;\n    },\n    intersectsSphere: function intersectsSphere(a) {\n      var b = this.radius + a.radius;\n      return a.center.distanceToSquared(this.center) <= b * b;\n    },\n    intersectsBox: function intersectsBox(a) {\n      return a.intersectsSphere(this);\n    },\n    intersectsPlane: function intersectsPlane(a) {\n      return Math.abs(a.distanceToPoint(this.center)) <= this.radius;\n    },\n    clampPoint: function clampPoint(a, b) {\n      var c = this.center.distanceToSquared(a),\n          d = b || new f();\n      return d.copy(a), c > this.radius * this.radius && (d.sub(this.center).normalize(), d.multiplyScalar(this.radius).add(this.center)), d;\n    },\n    getBoundingBox: function getBoundingBox(a) {\n      var b = a || new aa();\n      return b.set(this.center, this.center), b.expandByScalar(this.radius), b;\n    },\n    applyMatrix4: function applyMatrix4(a) {\n      return this.center.applyMatrix4(a), this.radius = this.radius * a.getMaxScaleOnAxis(), this;\n    },\n    translate: function translate(a) {\n      return this.center.add(a), this;\n    },\n    equals: function equals(a) {\n      return a.center.equals(this.center) && a.radius === this.radius;\n    }\n  }), Object.assign(ca.prototype, {\n    set: function set(a, b) {\n      return this.normal.copy(a), this.constant = b, this;\n    },\n    setComponents: function setComponents(a, b, c, d) {\n      return this.normal.set(a, b, c), this.constant = d, this;\n    },\n    setFromNormalAndCoplanarPoint: function setFromNormalAndCoplanarPoint(a, b) {\n      return this.normal.copy(a), this.constant = -b.dot(this.normal), this;\n    },\n    setFromCoplanarPoints: function () {\n      var a = new f(),\n          b = new f();\n      return function (c, d, e) {\n        var f = a.subVectors(e, d).cross(b.subVectors(c, d)).normalize();\n        return this.setFromNormalAndCoplanarPoint(f, c), this;\n      };\n    }(),\n    clone: function clone() {\n      return new this.constructor().copy(this);\n    },\n    copy: function copy(a) {\n      return this.normal.copy(a.normal), this.constant = a.constant, this;\n    },\n    normalize: function normalize() {\n      var a = 1 / this.normal.length();\n      return this.normal.multiplyScalar(a), this.constant *= a, this;\n    },\n    negate: function negate() {\n      return this.constant *= -1, this.normal.negate(), this;\n    },\n    distanceToPoint: function distanceToPoint(a) {\n      return this.normal.dot(a) + this.constant;\n    },\n    distanceToSphere: function distanceToSphere(a) {\n      return this.distanceToPoint(a.center) - a.radius;\n    },\n    projectPoint: function projectPoint(a, b) {\n      return (b || new f()).copy(this.normal).multiplyScalar(-this.distanceToPoint(a)).add(a);\n    },\n    intersectLine: function () {\n      var a = new f();\n      return function (b, c) {\n        var d = c || new f(),\n            e = b.delta(a),\n            g = this.normal.dot(e);\n\n        if (0 !== g) {\n          var h = -(b.start.dot(this.normal) + this.constant) / g;\n          if (!(h < 0 || h > 1)) return d.copy(e).multiplyScalar(h).add(b.start);\n        } else if (0 === this.distanceToPoint(b.start)) return d.copy(b.start);\n      };\n    }(),\n    intersectsLine: function intersectsLine(a) {\n      var b = this.distanceToPoint(a.start),\n          c = this.distanceToPoint(a.end);\n      return b < 0 && c > 0 || c < 0 && b > 0;\n    },\n    intersectsBox: function intersectsBox(a) {\n      return a.intersectsPlane(this);\n    },\n    intersectsSphere: function intersectsSphere(a) {\n      return a.intersectsPlane(this);\n    },\n    coplanarPoint: function coplanarPoint(a) {\n      return (a || new f()).copy(this.normal).multiplyScalar(-this.constant);\n    },\n    applyMatrix4: function () {\n      var a = new f(),\n          b = new g();\n      return function (c, d) {\n        var e = d || b.getNormalMatrix(c),\n            f = this.coplanarPoint(a).applyMatrix4(c),\n            g = this.normal.applyMatrix3(e).normalize();\n        return this.constant = -f.dot(g), this;\n      };\n    }(),\n    translate: function translate(a) {\n      return this.constant -= a.dot(this.normal), this;\n    },\n    equals: function equals(a) {\n      return a.normal.equals(this.normal) && a.constant === this.constant;\n    }\n  }), Object.assign(da.prototype, {\n    set: function set(a, b, c, d, e, f) {\n      var g = this.planes;\n      return g[0].copy(a), g[1].copy(b), g[2].copy(c), g[3].copy(d), g[4].copy(e), g[5].copy(f), this;\n    },\n    clone: function clone() {\n      return new this.constructor().copy(this);\n    },\n    copy: function copy(a) {\n      for (var b = this.planes, c = 0; c < 6; c++) {\n        b[c].copy(a.planes[c]);\n      }\n\n      return this;\n    },\n    setFromMatrix: function setFromMatrix(a) {\n      var b = this.planes,\n          c = a.elements,\n          d = c[0],\n          e = c[1],\n          f = c[2],\n          g = c[3],\n          h = c[4],\n          i = c[5],\n          j = c[6],\n          k = c[7],\n          l = c[8],\n          m = c[9],\n          n = c[10],\n          o = c[11],\n          p = c[12],\n          q = c[13],\n          r = c[14],\n          s = c[15];\n      return b[0].setComponents(g - d, k - h, o - l, s - p).normalize(), b[1].setComponents(g + d, k + h, o + l, s + p).normalize(), b[2].setComponents(g + e, k + i, o + m, s + q).normalize(), b[3].setComponents(g - e, k - i, o - m, s - q).normalize(), b[4].setComponents(g - f, k - j, o - n, s - r).normalize(), b[5].setComponents(g + f, k + j, o + n, s + r).normalize(), this;\n    },\n    intersectsObject: function () {\n      var a = new ba();\n      return function (b) {\n        var c = b.geometry;\n        return null === c.boundingSphere && c.computeBoundingSphere(), a.copy(c.boundingSphere).applyMatrix4(b.matrixWorld), this.intersectsSphere(a);\n      };\n    }(),\n    intersectsSprite: function () {\n      var a = new ba();\n      return function (b) {\n        return a.center.set(0, 0, 0), a.radius = .7071067811865476, a.applyMatrix4(b.matrixWorld), this.intersectsSphere(a);\n      };\n    }(),\n    intersectsSphere: function intersectsSphere(a) {\n      for (var b = this.planes, c = a.center, d = -a.radius, e = 0; e < 6; e++) {\n        if (b[e].distanceToPoint(c) < d) return !1;\n      }\n\n      return !0;\n    },\n    intersectsBox: function () {\n      var a = new f(),\n          b = new f();\n      return function (c) {\n        for (var d = this.planes, e = 0; e < 6; e++) {\n          var f = d[e];\n          a.x = f.normal.x > 0 ? c.min.x : c.max.x, b.x = f.normal.x > 0 ? c.max.x : c.min.x, a.y = f.normal.y > 0 ? c.min.y : c.max.y, b.y = f.normal.y > 0 ? c.max.y : c.min.y, a.z = f.normal.z > 0 ? c.min.z : c.max.z, b.z = f.normal.z > 0 ? c.max.z : c.min.z;\n          var g = f.distanceToPoint(a),\n              h = f.distanceToPoint(b);\n          if (g < 0 && h < 0) return !1;\n        }\n\n        return !0;\n      };\n    }(),\n    containsPoint: function containsPoint(a) {\n      for (var b = this.planes, c = 0; c < 6; c++) {\n        if (b[c].distanceToPoint(a) < 0) return !1;\n      }\n\n      return !0;\n    }\n  }), ga.RotationOrders = [\"XYZ\", \"YZX\", \"ZXY\", \"XZY\", \"YXZ\", \"ZYX\"], ga.DefaultOrder = \"XYZ\", Object.defineProperties(ga.prototype, {\n    x: {\n      get: function get() {\n        return this._x;\n      },\n      set: function set(a) {\n        this._x = a, this.onChangeCallback();\n      }\n    },\n    y: {\n      get: function get() {\n        return this._y;\n      },\n      set: function set(a) {\n        this._y = a, this.onChangeCallback();\n      }\n    },\n    z: {\n      get: function get() {\n        return this._z;\n      },\n      set: function set(a) {\n        this._z = a, this.onChangeCallback();\n      }\n    },\n    order: {\n      get: function get() {\n        return this._order;\n      },\n      set: function set(a) {\n        this._order = a, this.onChangeCallback();\n      }\n    }\n  }), Object.assign(ga.prototype, {\n    isEuler: !0,\n    set: function set(a, b, c, d) {\n      return this._x = a, this._y = b, this._z = c, this._order = d || this._order, this.onChangeCallback(), this;\n    },\n    clone: function clone() {\n      return new this.constructor(this._x, this._y, this._z, this._order);\n    },\n    copy: function copy(a) {\n      return this._x = a._x, this._y = a._y, this._z = a._z, this._order = a._order, this.onChangeCallback(), this;\n    },\n    setFromRotationMatrix: function setFromRotationMatrix(a, b, c) {\n      var d = yd.clamp,\n          e = a.elements,\n          f = e[0],\n          g = e[4],\n          h = e[8],\n          i = e[1],\n          j = e[5],\n          k = e[9],\n          l = e[2],\n          m = e[6],\n          n = e[10];\n      return b = b || this._order, \"XYZ\" === b ? (this._y = Math.asin(d(h, -1, 1)), Math.abs(h) < .99999 ? (this._x = Math.atan2(-k, n), this._z = Math.atan2(-g, f)) : (this._x = Math.atan2(m, j), this._z = 0)) : \"YXZ\" === b ? (this._x = Math.asin(-d(k, -1, 1)), Math.abs(k) < .99999 ? (this._y = Math.atan2(h, n), this._z = Math.atan2(i, j)) : (this._y = Math.atan2(-l, f), this._z = 0)) : \"ZXY\" === b ? (this._x = Math.asin(d(m, -1, 1)), Math.abs(m) < .99999 ? (this._y = Math.atan2(-l, n), this._z = Math.atan2(-g, j)) : (this._y = 0, this._z = Math.atan2(i, f))) : \"ZYX\" === b ? (this._y = Math.asin(-d(l, -1, 1)), Math.abs(l) < .99999 ? (this._x = Math.atan2(m, n), this._z = Math.atan2(i, f)) : (this._x = 0, this._z = Math.atan2(-g, j))) : \"YZX\" === b ? (this._z = Math.asin(d(i, -1, 1)), Math.abs(i) < .99999 ? (this._x = Math.atan2(-k, j), this._y = Math.atan2(-l, f)) : (this._x = 0, this._y = Math.atan2(h, n))) : \"XZY\" === b ? (this._z = Math.asin(-d(g, -1, 1)), Math.abs(g) < .99999 ? (this._x = Math.atan2(m, j), this._y = Math.atan2(h, f)) : (this._x = Math.atan2(-k, n), this._y = 0)) : console.warn(\"THREE.Euler: .setFromRotationMatrix() given unsupported order: \" + b), this._order = b, !1 !== c && this.onChangeCallback(), this;\n    },\n    setFromQuaternion: function () {\n      var a = new d();\n      return function (b, c, d) {\n        return a.makeRotationFromQuaternion(b), this.setFromRotationMatrix(a, c, d);\n      };\n    }(),\n    setFromVector3: function setFromVector3(a, b) {\n      return this.set(a.x, a.y, a.z, b || this._order);\n    },\n    reorder: function () {\n      var a = new e();\n      return function (b) {\n        return a.setFromEuler(this), this.setFromQuaternion(a, b);\n      };\n    }(),\n    equals: function equals(a) {\n      return a._x === this._x && a._y === this._y && a._z === this._z && a._order === this._order;\n    },\n    fromArray: function fromArray(a) {\n      return this._x = a[0], this._y = a[1], this._z = a[2], void 0 !== a[3] && (this._order = a[3]), this.onChangeCallback(), this;\n    },\n    toArray: function toArray(a, b) {\n      return void 0 === a && (a = []), void 0 === b && (b = 0), a[b] = this._x, a[b + 1] = this._y, a[b + 2] = this._z, a[b + 3] = this._order, a;\n    },\n    toVector3: function toVector3(a) {\n      return a ? a.set(this._x, this._y, this._z) : new f(this._x, this._y, this._z);\n    },\n    onChange: function onChange(a) {\n      return this.onChangeCallback = a, this;\n    },\n    onChangeCallback: function onChangeCallback() {}\n  }), Object.assign(ha.prototype, {\n    set: function set(a) {\n      this.mask = 1 << a | 0;\n    },\n    enable: function enable(a) {\n      this.mask |= 1 << a | 0;\n    },\n    toggle: function toggle(a) {\n      this.mask ^= 1 << a | 0;\n    },\n    disable: function disable(a) {\n      this.mask &= ~(1 << a | 0);\n    },\n    test: function test(a) {\n      return 0 != (this.mask & a.mask);\n    }\n  });\n  var Pf = 0;\n  ia.DefaultUp = new f(0, 1, 0), ia.DefaultMatrixAutoUpdate = !0, ia.prototype = Object.assign(Object.create(b.prototype), {\n    constructor: ia,\n    isObject3D: !0,\n    onBeforeRender: function onBeforeRender() {},\n    onAfterRender: function onAfterRender() {},\n    applyMatrix: function applyMatrix(a) {\n      this.matrix.multiplyMatrices(a, this.matrix), this.matrix.decompose(this.position, this.quaternion, this.scale);\n    },\n    applyQuaternion: function applyQuaternion(a) {\n      return this.quaternion.premultiply(a), this;\n    },\n    setRotationFromAxisAngle: function setRotationFromAxisAngle(a, b) {\n      this.quaternion.setFromAxisAngle(a, b);\n    },\n    setRotationFromEuler: function setRotationFromEuler(a) {\n      this.quaternion.setFromEuler(a, !0);\n    },\n    setRotationFromMatrix: function setRotationFromMatrix(a) {\n      this.quaternion.setFromRotationMatrix(a);\n    },\n    setRotationFromQuaternion: function setRotationFromQuaternion(a) {\n      this.quaternion.copy(a);\n    },\n    rotateOnAxis: function () {\n      var a = new e();\n      return function (b, c) {\n        return a.setFromAxisAngle(b, c), this.quaternion.multiply(a), this;\n      };\n    }(),\n    rotateOnWorldAxis: function () {\n      var a = new e();\n      return function (b, c) {\n        return a.setFromAxisAngle(b, c), this.quaternion.premultiply(a), this;\n      };\n    }(),\n    rotateX: function () {\n      var a = new f(1, 0, 0);\n      return function (b) {\n        return this.rotateOnAxis(a, b);\n      };\n    }(),\n    rotateY: function () {\n      var a = new f(0, 1, 0);\n      return function (b) {\n        return this.rotateOnAxis(a, b);\n      };\n    }(),\n    rotateZ: function () {\n      var a = new f(0, 0, 1);\n      return function (b) {\n        return this.rotateOnAxis(a, b);\n      };\n    }(),\n    translateOnAxis: function () {\n      var a = new f();\n      return function (b, c) {\n        return a.copy(b).applyQuaternion(this.quaternion), this.position.add(a.multiplyScalar(c)), this;\n      };\n    }(),\n    translateX: function () {\n      var a = new f(1, 0, 0);\n      return function (b) {\n        return this.translateOnAxis(a, b);\n      };\n    }(),\n    translateY: function () {\n      var a = new f(0, 1, 0);\n      return function (b) {\n        return this.translateOnAxis(a, b);\n      };\n    }(),\n    translateZ: function () {\n      var a = new f(0, 0, 1);\n      return function (b) {\n        return this.translateOnAxis(a, b);\n      };\n    }(),\n    localToWorld: function localToWorld(a) {\n      return a.applyMatrix4(this.matrixWorld);\n    },\n    worldToLocal: function () {\n      var a = new d();\n      return function (b) {\n        return b.applyMatrix4(a.getInverse(this.matrixWorld));\n      };\n    }(),\n    lookAt: function () {\n      var a = new d(),\n          b = new f();\n      return function (c, d, e) {\n        c.isVector3 ? b.copy(c) : b.set(c, d, e), this.isCamera ? a.lookAt(this.position, b, this.up) : a.lookAt(b, this.position, this.up), this.quaternion.setFromRotationMatrix(a);\n      };\n    }(),\n    add: function add(a) {\n      if (arguments.length > 1) {\n        for (var b = 0; b < arguments.length; b++) {\n          this.add(arguments[b]);\n        }\n\n        return this;\n      }\n\n      return a === this ? (console.error(\"THREE.Object3D.add: object can't be added as a child of itself.\", a), this) : (a && a.isObject3D ? (null !== a.parent && a.parent.remove(a), a.parent = this, a.dispatchEvent({\n        type: \"added\"\n      }), this.children.push(a)) : console.error(\"THREE.Object3D.add: object not an instance of THREE.Object3D.\", a), this);\n    },\n    remove: function remove(a) {\n      if (arguments.length > 1) {\n        for (var b = 0; b < arguments.length; b++) {\n          this.remove(arguments[b]);\n        }\n\n        return this;\n      }\n\n      var c = this.children.indexOf(a);\n      return -1 !== c && (a.parent = null, a.dispatchEvent({\n        type: \"removed\"\n      }), this.children.splice(c, 1)), this;\n    },\n    getObjectById: function getObjectById(a) {\n      return this.getObjectByProperty(\"id\", a);\n    },\n    getObjectByName: function getObjectByName(a) {\n      return this.getObjectByProperty(\"name\", a);\n    },\n    getObjectByProperty: function getObjectByProperty(a, b) {\n      if (this[a] === b) return this;\n\n      for (var c = 0, d = this.children.length; c < d; c++) {\n        var e = this.children[c],\n            f = e.getObjectByProperty(a, b);\n        if (void 0 !== f) return f;\n      }\n    },\n    getWorldPosition: function getWorldPosition(a) {\n      var b = a || new f();\n      return this.updateMatrixWorld(!0), b.setFromMatrixPosition(this.matrixWorld);\n    },\n    getWorldQuaternion: function () {\n      var a = new f(),\n          b = new f();\n      return function (c) {\n        var d = c || new e();\n        return this.updateMatrixWorld(!0), this.matrixWorld.decompose(a, d, b), d;\n      };\n    }(),\n    getWorldRotation: function () {\n      var a = new e();\n      return function (b) {\n        var c = b || new ga();\n        return this.getWorldQuaternion(a), c.setFromQuaternion(a, this.rotation.order, !1);\n      };\n    }(),\n    getWorldScale: function () {\n      var a = new f(),\n          b = new e();\n      return function (c) {\n        var d = c || new f();\n        return this.updateMatrixWorld(!0), this.matrixWorld.decompose(a, b, d), d;\n      };\n    }(),\n    getWorldDirection: function () {\n      var a = new e();\n      return function (b) {\n        var c = b || new f();\n        return this.getWorldQuaternion(a), c.set(0, 0, 1).applyQuaternion(a);\n      };\n    }(),\n    raycast: function raycast() {},\n    traverse: function traverse(a) {\n      a(this);\n\n      for (var b = this.children, c = 0, d = b.length; c < d; c++) {\n        b[c].traverse(a);\n      }\n    },\n    traverseVisible: function traverseVisible(a) {\n      if (!1 !== this.visible) {\n        a(this);\n\n        for (var b = this.children, c = 0, d = b.length; c < d; c++) {\n          b[c].traverseVisible(a);\n        }\n      }\n    },\n    traverseAncestors: function traverseAncestors(a) {\n      var b = this.parent;\n      null !== b && (a(b), b.traverseAncestors(a));\n    },\n    updateMatrix: function updateMatrix() {\n      this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;\n    },\n    updateMatrixWorld: function updateMatrixWorld(a) {\n      this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || a) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, a = !0);\n\n      for (var b = this.children, c = 0, d = b.length; c < d; c++) {\n        b[c].updateMatrixWorld(a);\n      }\n    },\n    toJSON: function toJSON(a) {\n      function b(b, c) {\n        return void 0 === b[c.uuid] && (b[c.uuid] = c.toJSON(a)), c.uuid;\n      }\n\n      function c(a) {\n        var b = [];\n\n        for (var c in a) {\n          var d = a[c];\n          delete d.metadata, b.push(d);\n        }\n\n        return b;\n      }\n\n      var d = void 0 === a || \"string\" == typeof a,\n          e = {};\n      d && (a = {\n        geometries: {},\n        materials: {},\n        textures: {},\n        images: {},\n        shapes: {}\n      }, e.metadata = {\n        version: 4.5,\n        type: \"Object\",\n        generator: \"Object3D.toJSON\"\n      });\n      var f = {};\n\n      if (f.uuid = this.uuid, f.type = this.type, \"\" !== this.name && (f.name = this.name), !0 === this.castShadow && (f.castShadow = !0), !0 === this.receiveShadow && (f.receiveShadow = !0), !1 === this.visible && (f.visible = !1), \"{}\" !== JSON.stringify(this.userData) && (f.userData = this.userData), f.matrix = this.matrix.toArray(), void 0 !== this.geometry) {\n        f.geometry = b(a.geometries, this.geometry);\n        var g = this.geometry.parameters;\n\n        if (void 0 !== g && void 0 !== g.shapes) {\n          var h = g.shapes;\n          if (Array.isArray(h)) for (var i = 0, j = h.length; i < j; i++) {\n            var k = h[i];\n            b(a.shapes, k);\n          } else b(a.shapes, h);\n        }\n      }\n\n      if (void 0 !== this.material) if (Array.isArray(this.material)) {\n        for (var l = [], i = 0, j = this.material.length; i < j; i++) {\n          l.push(b(a.materials, this.material[i]));\n        }\n\n        f.material = l;\n      } else f.material = b(a.materials, this.material);\n\n      if (this.children.length > 0) {\n        f.children = [];\n\n        for (var i = 0; i < this.children.length; i++) {\n          f.children.push(this.children[i].toJSON(a).object);\n        }\n      }\n\n      if (d) {\n        var m = c(a.geometries),\n            n = c(a.materials),\n            o = c(a.textures),\n            p = c(a.images),\n            h = c(a.shapes);\n        m.length > 0 && (e.geometries = m), n.length > 0 && (e.materials = n), o.length > 0 && (e.textures = o), p.length > 0 && (e.images = p), h.length > 0 && (e.shapes = h);\n      }\n\n      return e.object = f, e;\n    },\n    clone: function clone(a) {\n      return new this.constructor().copy(this, a);\n    },\n    copy: function copy(a, b) {\n      if (void 0 === b && (b = !0), this.name = a.name, this.up.copy(a.up), this.position.copy(a.position), this.quaternion.copy(a.quaternion), this.scale.copy(a.scale), this.matrix.copy(a.matrix), this.matrixWorld.copy(a.matrixWorld), this.matrixAutoUpdate = a.matrixAutoUpdate, this.matrixWorldNeedsUpdate = a.matrixWorldNeedsUpdate, this.layers.mask = a.layers.mask, this.visible = a.visible, this.castShadow = a.castShadow, this.receiveShadow = a.receiveShadow, this.frustumCulled = a.frustumCulled, this.renderOrder = a.renderOrder, this.userData = JSON.parse(JSON.stringify(a.userData)), !0 === b) for (var c = 0; c < a.children.length; c++) {\n        var d = a.children[c];\n        this.add(d.clone());\n      }\n      return this;\n    }\n  }), ja.prototype = Object.assign(Object.create(ia.prototype), {\n    constructor: ja,\n    isCamera: !0,\n    copy: function copy(a, b) {\n      return ia.prototype.copy.call(this, a, b), this.matrixWorldInverse.copy(a.matrixWorldInverse), this.projectionMatrix.copy(a.projectionMatrix), this;\n    },\n    getWorldDirection: function () {\n      var a = new e();\n      return function (b) {\n        var c = b || new f();\n        return this.getWorldQuaternion(a), c.set(0, 0, -1).applyQuaternion(a);\n      };\n    }(),\n    updateMatrixWorld: function updateMatrixWorld(a) {\n      ia.prototype.updateMatrixWorld.call(this, a), this.matrixWorldInverse.getInverse(this.matrixWorld);\n    },\n    clone: function clone() {\n      return new this.constructor().copy(this);\n    }\n  }), ka.prototype = Object.assign(Object.create(ja.prototype), {\n    constructor: ka,\n    isOrthographicCamera: !0,\n    copy: function copy(a, b) {\n      return ja.prototype.copy.call(this, a, b), this.left = a.left, this.right = a.right, this.top = a.top, this.bottom = a.bottom, this.near = a.near, this.far = a.far, this.zoom = a.zoom, this.view = null === a.view ? null : Object.assign({}, a.view), this;\n    },\n    setViewOffset: function setViewOffset(a, b, c, d, e, f) {\n      null === this.view && (this.view = {\n        enabled: !0,\n        fullWidth: 1,\n        fullHeight: 1,\n        offsetX: 0,\n        offsetY: 0,\n        width: 1,\n        height: 1\n      }), this.view.enabled = !0, this.view.fullWidth = a, this.view.fullHeight = b, this.view.offsetX = c, this.view.offsetY = d, this.view.width = e, this.view.height = f, this.updateProjectionMatrix();\n    },\n    clearViewOffset: function clearViewOffset() {\n      null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix();\n    },\n    updateProjectionMatrix: function updateProjectionMatrix() {\n      var a = (this.right - this.left) / (2 * this.zoom),\n          b = (this.top - this.bottom) / (2 * this.zoom),\n          c = (this.right + this.left) / 2,\n          d = (this.top + this.bottom) / 2,\n          e = c - a,\n          f = c + a,\n          g = d + b,\n          h = d - b;\n\n      if (null !== this.view && this.view.enabled) {\n        var i = this.zoom / (this.view.width / this.view.fullWidth),\n            j = this.zoom / (this.view.height / this.view.fullHeight),\n            k = (this.right - this.left) / this.view.width,\n            l = (this.top - this.bottom) / this.view.height;\n        e += k * (this.view.offsetX / i), f = e + k * (this.view.width / i), g -= l * (this.view.offsetY / j), h = g - l * (this.view.height / j);\n      }\n\n      this.projectionMatrix.makeOrthographic(e, f, g, h, this.near, this.far);\n    },\n    toJSON: function toJSON(a) {\n      var b = ia.prototype.toJSON.call(this, a);\n      return b.object.zoom = this.zoom, b.object.left = this.left, b.object.right = this.right, b.object.top = this.top, b.object.bottom = this.bottom, b.object.near = this.near, b.object.far = this.far, null !== this.view && (b.object.view = Object.assign({}, this.view)), b;\n    }\n  }), Object.assign(la.prototype, {\n    clone: function clone() {\n      return new this.constructor().copy(this);\n    },\n    copy: function copy(a) {\n      this.a = a.a, this.b = a.b, this.c = a.c, this.normal.copy(a.normal), this.color.copy(a.color), this.materialIndex = a.materialIndex;\n\n      for (var b = 0, c = a.vertexNormals.length; b < c; b++) {\n        this.vertexNormals[b] = a.vertexNormals[b].clone();\n      }\n\n      for (var b = 0, c = a.vertexColors.length; b < c; b++) {\n        this.vertexColors[b] = a.vertexColors[b].clone();\n      }\n\n      return this;\n    }\n  });\n  var Qf = 0;\n  ma.prototype = Object.assign(Object.create(b.prototype), {\n    constructor: ma,\n    isGeometry: !0,\n    applyMatrix: function applyMatrix(a) {\n      for (var b = new g().getNormalMatrix(a), c = 0, d = this.vertices.length; c < d; c++) {\n        this.vertices[c].applyMatrix4(a);\n      }\n\n      for (var c = 0, d = this.faces.length; c < d; c++) {\n        var e = this.faces[c];\n        e.normal.applyMatrix3(b).normalize();\n\n        for (var f = 0, h = e.vertexNormals.length; f < h; f++) {\n          e.vertexNormals[f].applyMatrix3(b).normalize();\n        }\n      }\n\n      return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this;\n    },\n    rotateX: function () {\n      var a = new d();\n      return function (b) {\n        return a.makeRotationX(b), this.applyMatrix(a), this;\n      };\n    }(),\n    rotateY: function () {\n      var a = new d();\n      return function (b) {\n        return a.makeRotationY(b), this.applyMatrix(a), this;\n      };\n    }(),\n    rotateZ: function () {\n      var a = new d();\n      return function (b) {\n        return a.makeRotationZ(b), this.applyMatrix(a), this;\n      };\n    }(),\n    translate: function () {\n      var a = new d();\n      return function (b, c, d) {\n        return a.makeTranslation(b, c, d), this.applyMatrix(a), this;\n      };\n    }(),\n    scale: function () {\n      var a = new d();\n      return function (b, c, d) {\n        return a.makeScale(b, c, d), this.applyMatrix(a), this;\n      };\n    }(),\n    lookAt: function () {\n      var a = new ia();\n      return function (b) {\n        a.lookAt(b), a.updateMatrix(), this.applyMatrix(a.matrix);\n      };\n    }(),\n    fromBufferGeometry: function fromBufferGeometry(a) {\n      function b(a, b, c, e) {\n        var f = void 0 !== i ? [m[a].clone(), m[b].clone(), m[c].clone()] : [],\n            g = void 0 !== j ? [d.colors[a].clone(), d.colors[b].clone(), d.colors[c].clone()] : [],\n            h = new la(a, b, c, f, g, e);\n        d.faces.push(h), void 0 !== k && d.faceVertexUvs[0].push([n[a].clone(), n[b].clone(), n[c].clone()]), void 0 !== l && d.faceVertexUvs[1].push([o[a].clone(), o[b].clone(), o[c].clone()]);\n      }\n\n      var d = this,\n          e = null !== a.index ? a.index.array : void 0,\n          g = a.attributes,\n          h = g.position.array,\n          i = void 0 !== g.normal ? g.normal.array : void 0,\n          j = void 0 !== g.color ? g.color.array : void 0,\n          k = void 0 !== g.uv ? g.uv.array : void 0,\n          l = void 0 !== g.uv2 ? g.uv2.array : void 0;\n      void 0 !== l && (this.faceVertexUvs[1] = []);\n\n      for (var m = [], n = [], o = [], p = 0, q = 0; p < h.length; p += 3, q += 2) {\n        d.vertices.push(new f(h[p], h[p + 1], h[p + 2])), void 0 !== i && m.push(new f(i[p], i[p + 1], i[p + 2])), void 0 !== j && d.colors.push(new U(j[p], j[p + 1], j[p + 2])), void 0 !== k && n.push(new c(k[q], k[q + 1])), void 0 !== l && o.push(new c(l[q], l[q + 1]));\n      }\n\n      var r = a.groups;\n      if (r.length > 0) for (var p = 0; p < r.length; p++) {\n        for (var s = r[p], t = s.start, u = s.count, q = t, v = t + u; q < v; q += 3) {\n          void 0 !== e ? b(e[q], e[q + 1], e[q + 2], s.materialIndex) : b(q, q + 1, q + 2, s.materialIndex);\n        }\n      } else if (void 0 !== e) for (var p = 0; p < e.length; p += 3) {\n        b(e[p], e[p + 1], e[p + 2]);\n      } else for (var p = 0; p < h.length / 3; p += 3) {\n        b(p, p + 1, p + 2);\n      }\n      return this.computeFaceNormals(), null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone()), null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone()), this;\n    },\n    center: function center() {\n      this.computeBoundingBox();\n      var a = this.boundingBox.getCenter().negate();\n      return this.translate(a.x, a.y, a.z), a;\n    },\n    normalize: function normalize() {\n      this.computeBoundingSphere();\n      var a = this.boundingSphere.center,\n          b = this.boundingSphere.radius,\n          c = 0 === b ? 1 : 1 / b,\n          e = new d();\n      return e.set(c, 0, 0, -c * a.x, 0, c, 0, -c * a.y, 0, 0, c, -c * a.z, 0, 0, 0, 1), this.applyMatrix(e), this;\n    },\n    computeFaceNormals: function computeFaceNormals() {\n      for (var a = new f(), b = new f(), c = 0, d = this.faces.length; c < d; c++) {\n        var e = this.faces[c],\n            g = this.vertices[e.a],\n            h = this.vertices[e.b],\n            i = this.vertices[e.c];\n        a.subVectors(i, h), b.subVectors(g, h), a.cross(b), a.normalize(), e.normal.copy(a);\n      }\n    },\n    computeVertexNormals: function computeVertexNormals(a) {\n      void 0 === a && (a = !0);\n      var b, c, d, e, g, h;\n\n      for (h = new Array(this.vertices.length), b = 0, c = this.vertices.length; b < c; b++) {\n        h[b] = new f();\n      }\n\n      if (a) {\n        var i,\n            j,\n            k,\n            l = new f(),\n            m = new f();\n\n        for (d = 0, e = this.faces.length; d < e; d++) {\n          g = this.faces[d], i = this.vertices[g.a], j = this.vertices[g.b], k = this.vertices[g.c], l.subVectors(k, j), m.subVectors(i, j), l.cross(m), h[g.a].add(l), h[g.b].add(l), h[g.c].add(l);\n        }\n      } else for (this.computeFaceNormals(), d = 0, e = this.faces.length; d < e; d++) {\n        g = this.faces[d], h[g.a].add(g.normal), h[g.b].add(g.normal), h[g.c].add(g.normal);\n      }\n\n      for (b = 0, c = this.vertices.length; b < c; b++) {\n        h[b].normalize();\n      }\n\n      for (d = 0, e = this.faces.length; d < e; d++) {\n        g = this.faces[d];\n        var n = g.vertexNormals;\n        3 === n.length ? (n[0].copy(h[g.a]), n[1].copy(h[g.b]), n[2].copy(h[g.c])) : (n[0] = h[g.a].clone(), n[1] = h[g.b].clone(), n[2] = h[g.c].clone());\n      }\n\n      this.faces.length > 0 && (this.normalsNeedUpdate = !0);\n    },\n    computeFlatVertexNormals: function computeFlatVertexNormals() {\n      var a, b, c;\n\n      for (this.computeFaceNormals(), a = 0, b = this.faces.length; a < b; a++) {\n        c = this.faces[a];\n        var d = c.vertexNormals;\n        3 === d.length ? (d[0].copy(c.normal), d[1].copy(c.normal), d[2].copy(c.normal)) : (d[0] = c.normal.clone(), d[1] = c.normal.clone(), d[2] = c.normal.clone());\n      }\n\n      this.faces.length > 0 && (this.normalsNeedUpdate = !0);\n    },\n    computeMorphNormals: function computeMorphNormals() {\n      var a, b, c, d, e;\n\n      for (c = 0, d = this.faces.length; c < d; c++) {\n        for (e = this.faces[c], e.__originalFaceNormal ? e.__originalFaceNormal.copy(e.normal) : e.__originalFaceNormal = e.normal.clone(), e.__originalVertexNormals || (e.__originalVertexNormals = []), a = 0, b = e.vertexNormals.length; a < b; a++) {\n          e.__originalVertexNormals[a] ? e.__originalVertexNormals[a].copy(e.vertexNormals[a]) : e.__originalVertexNormals[a] = e.vertexNormals[a].clone();\n        }\n      }\n\n      var g = new ma();\n\n      for (g.faces = this.faces, a = 0, b = this.morphTargets.length; a < b; a++) {\n        if (!this.morphNormals[a]) {\n          this.morphNormals[a] = {}, this.morphNormals[a].faceNormals = [], this.morphNormals[a].vertexNormals = [];\n          var h,\n              i,\n              j = this.morphNormals[a].faceNormals,\n              k = this.morphNormals[a].vertexNormals;\n\n          for (c = 0, d = this.faces.length; c < d; c++) {\n            h = new f(), i = {\n              a: new f(),\n              b: new f(),\n              c: new f()\n            }, j.push(h), k.push(i);\n          }\n        }\n\n        var l = this.morphNormals[a];\n        g.vertices = this.morphTargets[a].vertices, g.computeFaceNormals(), g.computeVertexNormals();\n        var h, i;\n\n        for (c = 0, d = this.faces.length; c < d; c++) {\n          e = this.faces[c], h = l.faceNormals[c], i = l.vertexNormals[c], h.copy(e.normal), i.a.copy(e.vertexNormals[0]), i.b.copy(e.vertexNormals[1]), i.c.copy(e.vertexNormals[2]);\n        }\n      }\n\n      for (c = 0, d = this.faces.length; c < d; c++) {\n        e = this.faces[c], e.normal = e.__originalFaceNormal, e.vertexNormals = e.__originalVertexNormals;\n      }\n    },\n    computeLineDistances: function computeLineDistances() {\n      for (var a = 0, b = this.vertices, c = 0, d = b.length; c < d; c++) {\n        c > 0 && (a += b[c].distanceTo(b[c - 1])), this.lineDistances[c] = a;\n      }\n    },\n    computeBoundingBox: function computeBoundingBox() {\n      null === this.boundingBox && (this.boundingBox = new aa()), this.boundingBox.setFromPoints(this.vertices);\n    },\n    computeBoundingSphere: function computeBoundingSphere() {\n      null === this.boundingSphere && (this.boundingSphere = new ba()), this.boundingSphere.setFromPoints(this.vertices);\n    },\n    merge: function merge(a, b, c) {\n      if (!a || !a.isGeometry) return void console.error(\"THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.\", a);\n      var d,\n          e = this.vertices.length,\n          f = this.vertices,\n          h = a.vertices,\n          i = this.faces,\n          j = a.faces,\n          k = this.faceVertexUvs[0],\n          l = a.faceVertexUvs[0],\n          m = this.colors,\n          n = a.colors;\n      void 0 === c && (c = 0), void 0 !== b && (d = new g().getNormalMatrix(b));\n\n      for (var o = 0, p = h.length; o < p; o++) {\n        var q = h[o],\n            r = q.clone();\n        void 0 !== b && r.applyMatrix4(b), f.push(r);\n      }\n\n      for (var o = 0, p = n.length; o < p; o++) {\n        m.push(n[o].clone());\n      }\n\n      for (o = 0, p = j.length; o < p; o++) {\n        var s,\n            t,\n            u,\n            v = j[o],\n            w = v.vertexNormals,\n            x = v.vertexColors;\n        s = new la(v.a + e, v.b + e, v.c + e), s.normal.copy(v.normal), void 0 !== d && s.normal.applyMatrix3(d).normalize();\n\n        for (var y = 0, z = w.length; y < z; y++) {\n          t = w[y].clone(), void 0 !== d && t.applyMatrix3(d).normalize(), s.vertexNormals.push(t);\n        }\n\n        s.color.copy(v.color);\n\n        for (var y = 0, z = x.length; y < z; y++) {\n          u = x[y], s.vertexColors.push(u.clone());\n        }\n\n        s.materialIndex = v.materialIndex + c, i.push(s);\n      }\n\n      for (o = 0, p = l.length; o < p; o++) {\n        var A = l[o],\n            B = [];\n\n        if (void 0 !== A) {\n          for (var y = 0, z = A.length; y < z; y++) {\n            B.push(A[y].clone());\n          }\n\n          k.push(B);\n        }\n      }\n    },\n    mergeMesh: function mergeMesh(a) {\n      if (!a || !a.isMesh) return void console.error(\"THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.\", a);\n      a.matrixAutoUpdate && a.updateMatrix(), this.merge(a.geometry, a.matrix);\n    },\n    mergeVertices: function mergeVertices() {\n      var a,\n          b,\n          c,\n          d,\n          e,\n          f,\n          g,\n          h,\n          i = {},\n          j = [],\n          k = [],\n          l = 4,\n          m = Math.pow(10, l);\n\n      for (c = 0, d = this.vertices.length; c < d; c++) {\n        a = this.vertices[c], b = Math.round(a.x * m) + \"_\" + Math.round(a.y * m) + \"_\" + Math.round(a.z * m), void 0 === i[b] ? (i[b] = c, j.push(this.vertices[c]), k[c] = j.length - 1) : k[c] = k[i[b]];\n      }\n\n      var n = [];\n\n      for (c = 0, d = this.faces.length; c < d; c++) {\n        e = this.faces[c], e.a = k[e.a], e.b = k[e.b], e.c = k[e.c], f = [e.a, e.b, e.c];\n\n        for (var o = 0; o < 3; o++) {\n          if (f[o] === f[(o + 1) % 3]) {\n            n.push(c);\n            break;\n          }\n        }\n      }\n\n      for (c = n.length - 1; c >= 0; c--) {\n        var p = n[c];\n\n        for (this.faces.splice(p, 1), g = 0, h = this.faceVertexUvs.length; g < h; g++) {\n          this.faceVertexUvs[g].splice(p, 1);\n        }\n      }\n\n      var q = this.vertices.length - j.length;\n      return this.vertices = j, q;\n    },\n    setFromPoints: function setFromPoints(a) {\n      this.vertices = [];\n\n      for (var b = 0, c = a.length; b < c; b++) {\n        var d = a[b];\n        this.vertices.push(new f(d.x, d.y, d.z || 0));\n      }\n\n      return this;\n    },\n    sortFacesByMaterialIndex: function sortFacesByMaterialIndex() {\n      function a(a, b) {\n        return a.materialIndex - b.materialIndex;\n      }\n\n      for (var b = this.faces, c = b.length, d = 0; d < c; d++) {\n        b[d]._id = d;\n      }\n\n      b.sort(a);\n      var e,\n          f,\n          g = this.faceVertexUvs[0],\n          h = this.faceVertexUvs[1];\n      g && g.length === c && (e = []), h && h.length === c && (f = []);\n\n      for (var d = 0; d < c; d++) {\n        var i = b[d]._id;\n        e && e.push(g[i]), f && f.push(h[i]);\n      }\n\n      e && (this.faceVertexUvs[0] = e), f && (this.faceVertexUvs[1] = f);\n    },\n    toJSON: function toJSON() {\n      function a(a, b, c) {\n        return c ? a | 1 << b : a & ~(1 << b);\n      }\n\n      function b(a) {\n        var b = a.x.toString() + a.y.toString() + a.z.toString();\n        return void 0 !== m[b] ? m[b] : (m[b] = l.length / 3, l.push(a.x, a.y, a.z), m[b]);\n      }\n\n      function c(a) {\n        var b = a.r.toString() + a.g.toString() + a.b.toString();\n        return void 0 !== o[b] ? o[b] : (o[b] = n.length, n.push(a.getHex()), o[b]);\n      }\n\n      function d(a) {\n        var b = a.x.toString() + a.y.toString();\n        return void 0 !== q[b] ? q[b] : (q[b] = p.length / 2, p.push(a.x, a.y), q[b]);\n      }\n\n      var e = {\n        metadata: {\n          version: 4.5,\n          type: \"Geometry\",\n          generator: \"Geometry.toJSON\"\n        }\n      };\n\n      if (e.uuid = this.uuid, e.type = this.type, \"\" !== this.name && (e.name = this.name), void 0 !== this.parameters) {\n        var f = this.parameters;\n\n        for (var g in f) {\n          void 0 !== f[g] && (e[g] = f[g]);\n        }\n\n        return e;\n      }\n\n      for (var h = [], i = 0; i < this.vertices.length; i++) {\n        var j = this.vertices[i];\n        h.push(j.x, j.y, j.z);\n      }\n\n      for (var k = [], l = [], m = {}, n = [], o = {}, p = [], q = {}, i = 0; i < this.faces.length; i++) {\n        var r = this.faces[i],\n            s = void 0 !== this.faceVertexUvs[0][i],\n            t = r.normal.length() > 0,\n            u = r.vertexNormals.length > 0,\n            v = 1 !== r.color.r || 1 !== r.color.g || 1 !== r.color.b,\n            w = r.vertexColors.length > 0,\n            x = 0;\n\n        if (x = a(x, 0, 0), x = a(x, 1, !0), x = a(x, 2, !1), x = a(x, 3, s), x = a(x, 4, t), x = a(x, 5, u), x = a(x, 6, v), x = a(x, 7, w), k.push(x), k.push(r.a, r.b, r.c), k.push(r.materialIndex), s) {\n          var y = this.faceVertexUvs[0][i];\n          k.push(d(y[0]), d(y[1]), d(y[2]));\n        }\n\n        if (t && k.push(b(r.normal)), u) {\n          var z = r.vertexNormals;\n          k.push(b(z[0]), b(z[1]), b(z[2]));\n        }\n\n        if (v && k.push(c(r.color)), w) {\n          var A = r.vertexColors;\n          k.push(c(A[0]), c(A[1]), c(A[2]));\n        }\n      }\n\n      return e.data = {}, e.data.vertices = h, e.data.normals = l, n.length > 0 && (e.data.colors = n), p.length > 0 && (e.data.uvs = [p]), e.data.faces = k, e;\n    },\n    clone: function clone() {\n      return new ma().copy(this);\n    },\n    copy: function copy(a) {\n      var b, c, d, e, f, g;\n      this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = a.name;\n      var h = a.vertices;\n\n      for (b = 0, c = h.length; b < c; b++) {\n        this.vertices.push(h[b].clone());\n      }\n\n      var i = a.colors;\n\n      for (b = 0, c = i.length; b < c; b++) {\n        this.colors.push(i[b].clone());\n      }\n\n      var j = a.faces;\n\n      for (b = 0, c = j.length; b < c; b++) {\n        this.faces.push(j[b].clone());\n      }\n\n      for (b = 0, c = a.faceVertexUvs.length; b < c; b++) {\n        var k = a.faceVertexUvs[b];\n\n        for (void 0 === this.faceVertexUvs[b] && (this.faceVertexUvs[b] = []), d = 0, e = k.length; d < e; d++) {\n          var l = k[d],\n              m = [];\n\n          for (f = 0, g = l.length; f < g; f++) {\n            var n = l[f];\n            m.push(n.clone());\n          }\n\n          this.faceVertexUvs[b].push(m);\n        }\n      }\n\n      var o = a.morphTargets;\n\n      for (b = 0, c = o.length; b < c; b++) {\n        var p = {};\n        if (p.name = o[b].name, void 0 !== o[b].vertices) for (p.vertices = [], d = 0, e = o[b].vertices.length; d < e; d++) {\n          p.vertices.push(o[b].vertices[d].clone());\n        }\n        if (void 0 !== o[b].normals) for (p.normals = [], d = 0, e = o[b].normals.length; d < e; d++) {\n          p.normals.push(o[b].normals[d].clone());\n        }\n        this.morphTargets.push(p);\n      }\n\n      var q = a.morphNormals;\n\n      for (b = 0, c = q.length; b < c; b++) {\n        var r = {};\n        if (void 0 !== q[b].vertexNormals) for (r.vertexNormals = [], d = 0, e = q[b].vertexNormals.length; d < e; d++) {\n          var s = q[b].vertexNormals[d],\n              t = {};\n          t.a = s.a.clone(), t.b = s.b.clone(), t.c = s.c.clone(), r.vertexNormals.push(t);\n        }\n        if (void 0 !== q[b].faceNormals) for (r.faceNormals = [], d = 0, e = q[b].faceNormals.length; d < e; d++) {\n          r.faceNormals.push(q[b].faceNormals[d].clone());\n        }\n        this.morphNormals.push(r);\n      }\n\n      var u = a.skinWeights;\n\n      for (b = 0, c = u.length; b < c; b++) {\n        this.skinWeights.push(u[b].clone());\n      }\n\n      var v = a.skinIndices;\n\n      for (b = 0, c = v.length; b < c; b++) {\n        this.skinIndices.push(v[b].clone());\n      }\n\n      var w = a.lineDistances;\n\n      for (b = 0, c = w.length; b < c; b++) {\n        this.lineDistances.push(w[b]);\n      }\n\n      var x = a.boundingBox;\n      null !== x && (this.boundingBox = x.clone());\n      var y = a.boundingSphere;\n      return null !== y && (this.boundingSphere = y.clone()), this.elementsNeedUpdate = a.elementsNeedUpdate, this.verticesNeedUpdate = a.verticesNeedUpdate, this.uvsNeedUpdate = a.uvsNeedUpdate, this.normalsNeedUpdate = a.normalsNeedUpdate, this.colorsNeedUpdate = a.colorsNeedUpdate, this.lineDistancesNeedUpdate = a.lineDistancesNeedUpdate, this.groupsNeedUpdate = a.groupsNeedUpdate, this;\n    },\n    dispose: function dispose() {\n      this.dispatchEvent({\n        type: \"dispose\"\n      });\n    }\n  }), Object.defineProperty(na.prototype, \"needsUpdate\", {\n    set: function set(a) {\n      !0 === a && this.version++;\n    }\n  }), Object.assign(na.prototype, {\n    isBufferAttribute: !0,\n    setArray: function setArray(a) {\n      if (Array.isArray(a)) throw new TypeError(\"THREE.BufferAttribute: array should be a Typed Array.\");\n      this.count = void 0 !== a ? a.length / this.itemSize : 0, this.array = a;\n    },\n    setDynamic: function setDynamic(a) {\n      return this.dynamic = a, this;\n    },\n    copy: function copy(a) {\n      return this.array = new a.array.constructor(a.array), this.itemSize = a.itemSize, this.count = a.count, this.normalized = a.normalized, this.dynamic = a.dynamic, this;\n    },\n    copyAt: function copyAt(a, b, c) {\n      a *= this.itemSize, c *= b.itemSize;\n\n      for (var d = 0, e = this.itemSize; d < e; d++) {\n        this.array[a + d] = b.array[c + d];\n      }\n\n      return this;\n    },\n    copyArray: function copyArray(a) {\n      return this.array.set(a), this;\n    },\n    copyColorsArray: function copyColorsArray(a) {\n      for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {\n        var f = a[d];\n        void 0 === f && (console.warn(\"THREE.BufferAttribute.copyColorsArray(): color is undefined\", d), f = new U()), b[c++] = f.r, b[c++] = f.g, b[c++] = f.b;\n      }\n\n      return this;\n    },\n    copyIndicesArray: function copyIndicesArray(a) {\n      for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {\n        var f = a[d];\n        b[c++] = f.a, b[c++] = f.b, b[c++] = f.c;\n      }\n\n      return this;\n    },\n    copyVector2sArray: function copyVector2sArray(a) {\n      for (var b = this.array, d = 0, e = 0, f = a.length; e < f; e++) {\n        var g = a[e];\n        void 0 === g && (console.warn(\"THREE.BufferAttribute.copyVector2sArray(): vector is undefined\", e), g = new c()), b[d++] = g.x, b[d++] = g.y;\n      }\n\n      return this;\n    },\n    copyVector3sArray: function copyVector3sArray(a) {\n      for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {\n        var g = a[d];\n        void 0 === g && (console.warn(\"THREE.BufferAttribute.copyVector3sArray(): vector is undefined\", d), g = new f()), b[c++] = g.x, b[c++] = g.y, b[c++] = g.z;\n      }\n\n      return this;\n    },\n    copyVector4sArray: function copyVector4sArray(a) {\n      for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {\n        var f = a[d];\n        void 0 === f && (console.warn(\"THREE.BufferAttribute.copyVector4sArray(): vector is undefined\", d), f = new i()), b[c++] = f.x, b[c++] = f.y, b[c++] = f.z, b[c++] = f.w;\n      }\n\n      return this;\n    },\n    set: function set(a, b) {\n      return void 0 === b && (b = 0), this.array.set(a, b), this;\n    },\n    getX: function getX(a) {\n      return this.array[a * this.itemSize];\n    },\n    setX: function setX(a, b) {\n      return this.array[a * this.itemSize] = b, this;\n    },\n    getY: function getY(a) {\n      return this.array[a * this.itemSize + 1];\n    },\n    setY: function setY(a, b) {\n      return this.array[a * this.itemSize + 1] = b, this;\n    },\n    getZ: function getZ(a) {\n      return this.array[a * this.itemSize + 2];\n    },\n    setZ: function setZ(a, b) {\n      return this.array[a * this.itemSize + 2] = b, this;\n    },\n    getW: function getW(a) {\n      return this.array[a * this.itemSize + 3];\n    },\n    setW: function setW(a, b) {\n      return this.array[a * this.itemSize + 3] = b, this;\n    },\n    setXY: function setXY(a, b, c) {\n      return a *= this.itemSize, this.array[a + 0] = b, this.array[a + 1] = c, this;\n    },\n    setXYZ: function setXYZ(a, b, c, d) {\n      return a *= this.itemSize, this.array[a + 0] = b, this.array[a + 1] = c, this.array[a + 2] = d, this;\n    },\n    setXYZW: function setXYZW(a, b, c, d, e) {\n      return a *= this.itemSize, this.array[a + 0] = b, this.array[a + 1] = c, this.array[a + 2] = d, this.array[a + 3] = e, this;\n    },\n    onUpload: function onUpload(a) {\n      return this.onUploadCallback = a, this;\n    },\n    clone: function clone() {\n      return new this.constructor(this.array, this.itemSize).copy(this);\n    }\n  }), oa.prototype = Object.create(na.prototype), oa.prototype.constructor = oa, pa.prototype = Object.create(na.prototype), pa.prototype.constructor = pa, qa.prototype = Object.create(na.prototype), qa.prototype.constructor = qa, ra.prototype = Object.create(na.prototype), ra.prototype.constructor = ra, sa.prototype = Object.create(na.prototype), sa.prototype.constructor = sa, ta.prototype = Object.create(na.prototype), ta.prototype.constructor = ta, ua.prototype = Object.create(na.prototype), ua.prototype.constructor = ua, va.prototype = Object.create(na.prototype), va.prototype.constructor = va, wa.prototype = Object.create(na.prototype), wa.prototype.constructor = wa, Object.assign(xa.prototype, {\n    computeGroups: function computeGroups(a) {\n      for (var b, c = [], d = void 0, e = a.faces, f = 0; f < e.length; f++) {\n        var g = e[f];\n        g.materialIndex !== d && (d = g.materialIndex, void 0 !== b && (b.count = 3 * f - b.start, c.push(b)), b = {\n          start: 3 * f,\n          materialIndex: d\n        });\n      }\n\n      void 0 !== b && (b.count = 3 * f - b.start, c.push(b)), this.groups = c;\n    },\n    fromGeometry: function fromGeometry(a) {\n      var b,\n          d = a.faces,\n          e = a.vertices,\n          f = a.faceVertexUvs,\n          g = f[0] && f[0].length > 0,\n          h = f[1] && f[1].length > 0,\n          i = a.morphTargets,\n          j = i.length;\n\n      if (j > 0) {\n        b = [];\n\n        for (var k = 0; k < j; k++) {\n          b[k] = [];\n        }\n\n        this.morphTargets.position = b;\n      }\n\n      var l,\n          m = a.morphNormals,\n          n = m.length;\n\n      if (n > 0) {\n        l = [];\n\n        for (var k = 0; k < n; k++) {\n          l[k] = [];\n        }\n\n        this.morphTargets.normal = l;\n      }\n\n      for (var o = a.skinIndices, p = a.skinWeights, q = o.length === e.length, r = p.length === e.length, k = 0; k < d.length; k++) {\n        var s = d[k];\n        this.vertices.push(e[s.a], e[s.b], e[s.c]);\n        var t = s.vertexNormals;\n        if (3 === t.length) this.normals.push(t[0], t[1], t[2]);else {\n          var u = s.normal;\n          this.normals.push(u, u, u);\n        }\n        var v = s.vertexColors;\n        if (3 === v.length) this.colors.push(v[0], v[1], v[2]);else {\n          var w = s.color;\n          this.colors.push(w, w, w);\n        }\n\n        if (!0 === g) {\n          var x = f[0][k];\n          void 0 !== x ? this.uvs.push(x[0], x[1], x[2]) : (console.warn(\"THREE.DirectGeometry.fromGeometry(): Undefined vertexUv \", k), this.uvs.push(new c(), new c(), new c()));\n        }\n\n        if (!0 === h) {\n          var x = f[1][k];\n          void 0 !== x ? this.uvs2.push(x[0], x[1], x[2]) : (console.warn(\"THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 \", k), this.uvs2.push(new c(), new c(), new c()));\n        }\n\n        for (var y = 0; y < j; y++) {\n          var z = i[y].vertices;\n          b[y].push(z[s.a], z[s.b], z[s.c]);\n        }\n\n        for (var y = 0; y < n; y++) {\n          var A = m[y].vertexNormals[k];\n          l[y].push(A.a, A.b, A.c);\n        }\n\n        q && this.skinIndices.push(o[s.a], o[s.b], o[s.c]), r && this.skinWeights.push(p[s.a], p[s.b], p[s.c]);\n      }\n\n      return this.computeGroups(a), this.verticesNeedUpdate = a.verticesNeedUpdate, this.normalsNeedUpdate = a.normalsNeedUpdate, this.colorsNeedUpdate = a.colorsNeedUpdate, this.uvsNeedUpdate = a.uvsNeedUpdate, this.groupsNeedUpdate = a.groupsNeedUpdate, this;\n    }\n  });\n  var Rf = 1;\n  za.prototype = Object.assign(Object.create(b.prototype), {\n    constructor: za,\n    isBufferGeometry: !0,\n    getIndex: function getIndex() {\n      return this.index;\n    },\n    setIndex: function setIndex(a) {\n      Array.isArray(a) ? this.index = new (ya(a) > 65535 ? ua : sa)(a, 1) : this.index = a;\n    },\n    addAttribute: function addAttribute(a, b) {\n      return b && b.isBufferAttribute || b && b.isInterleavedBufferAttribute ? \"index\" === a ? (console.warn(\"THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.\"), void this.setIndex(b)) : (this.attributes[a] = b, this) : (console.warn(\"THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).\"), void this.addAttribute(a, new na(arguments[1], arguments[2])));\n    },\n    getAttribute: function getAttribute(a) {\n      return this.attributes[a];\n    },\n    removeAttribute: function removeAttribute(a) {\n      return delete this.attributes[a], this;\n    },\n    addGroup: function addGroup(a, b, c) {\n      this.groups.push({\n        start: a,\n        count: b,\n        materialIndex: void 0 !== c ? c : 0\n      });\n    },\n    clearGroups: function clearGroups() {\n      this.groups = [];\n    },\n    setDrawRange: function setDrawRange(a, b) {\n      this.drawRange.start = a, this.drawRange.count = b;\n    },\n    applyMatrix: function applyMatrix(a) {\n      var b = this.attributes.position;\n      void 0 !== b && (a.applyToBufferAttribute(b), b.needsUpdate = !0);\n      var c = this.attributes.normal;\n\n      if (void 0 !== c) {\n        new g().getNormalMatrix(a).applyToBufferAttribute(c), c.needsUpdate = !0;\n      }\n\n      return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this;\n    },\n    rotateX: function () {\n      var a = new d();\n      return function (b) {\n        return a.makeRotationX(b), this.applyMatrix(a), this;\n      };\n    }(),\n    rotateY: function () {\n      var a = new d();\n      return function (b) {\n        return a.makeRotationY(b), this.applyMatrix(a), this;\n      };\n    }(),\n    rotateZ: function () {\n      var a = new d();\n      return function (b) {\n        return a.makeRotationZ(b), this.applyMatrix(a), this;\n      };\n    }(),\n    translate: function () {\n      var a = new d();\n      return function (b, c, d) {\n        return a.makeTranslation(b, c, d), this.applyMatrix(a), this;\n      };\n    }(),\n    scale: function () {\n      var a = new d();\n      return function (b, c, d) {\n        return a.makeScale(b, c, d), this.applyMatrix(a), this;\n      };\n    }(),\n    lookAt: function () {\n      var a = new ia();\n      return function (b) {\n        a.lookAt(b), a.updateMatrix(), this.applyMatrix(a.matrix);\n      };\n    }(),\n    center: function center() {\n      this.computeBoundingBox();\n      var a = this.boundingBox.getCenter().negate();\n      return this.translate(a.x, a.y, a.z), a;\n    },\n    setFromObject: function setFromObject(a) {\n      var b = a.geometry;\n\n      if (a.isPoints || a.isLine) {\n        var c = new va(3 * b.vertices.length, 3),\n            d = new va(3 * b.colors.length, 3);\n\n        if (this.addAttribute(\"position\", c.copyVector3sArray(b.vertices)), this.addAttribute(\"color\", d.copyColorsArray(b.colors)), b.lineDistances && b.lineDistances.length === b.vertices.length) {\n          var e = new va(b.lineDistances.length, 1);\n          this.addAttribute(\"lineDistance\", e.copyArray(b.lineDistances));\n        }\n\n        null !== b.boundingSphere && (this.boundingSphere = b.boundingSphere.clone()), null !== b.boundingBox && (this.boundingBox = b.boundingBox.clone());\n      } else a.isMesh && b && b.isGeometry && this.fromGeometry(b);\n\n      return this;\n    },\n    setFromPoints: function setFromPoints(a) {\n      for (var b = [], c = 0, d = a.length; c < d; c++) {\n        var e = a[c];\n        b.push(e.x, e.y, e.z || 0);\n      }\n\n      return this.addAttribute(\"position\", new va(b, 3)), this;\n    },\n    updateFromObject: function updateFromObject(a) {\n      var b = a.geometry;\n\n      if (a.isMesh) {\n        var c = b.__directGeometry;\n        if (!0 === b.elementsNeedUpdate && (c = void 0, b.elementsNeedUpdate = !1), void 0 === c) return this.fromGeometry(b);\n        c.verticesNeedUpdate = b.verticesNeedUpdate, c.normalsNeedUpdate = b.normalsNeedUpdate, c.colorsNeedUpdate = b.colorsNeedUpdate, c.uvsNeedUpdate = b.uvsNeedUpdate, c.groupsNeedUpdate = b.groupsNeedUpdate, b.verticesNeedUpdate = !1, b.normalsNeedUpdate = !1, b.colorsNeedUpdate = !1, b.uvsNeedUpdate = !1, b.groupsNeedUpdate = !1, b = c;\n      }\n\n      var d;\n      return !0 === b.verticesNeedUpdate && (d = this.attributes.position, void 0 !== d && (d.copyVector3sArray(b.vertices), d.needsUpdate = !0), b.verticesNeedUpdate = !1), !0 === b.normalsNeedUpdate && (d = this.attributes.normal, void 0 !== d && (d.copyVector3sArray(b.normals), d.needsUpdate = !0), b.normalsNeedUpdate = !1), !0 === b.colorsNeedUpdate && (d = this.attributes.color, void 0 !== d && (d.copyColorsArray(b.colors), d.needsUpdate = !0), b.colorsNeedUpdate = !1), b.uvsNeedUpdate && (d = this.attributes.uv, void 0 !== d && (d.copyVector2sArray(b.uvs), d.needsUpdate = !0), b.uvsNeedUpdate = !1), b.lineDistancesNeedUpdate && (d = this.attributes.lineDistance, void 0 !== d && (d.copyArray(b.lineDistances), d.needsUpdate = !0), b.lineDistancesNeedUpdate = !1), b.groupsNeedUpdate && (b.computeGroups(a.geometry), this.groups = b.groups, b.groupsNeedUpdate = !1), this;\n    },\n    fromGeometry: function fromGeometry(a) {\n      return a.__directGeometry = new xa().fromGeometry(a), this.fromDirectGeometry(a.__directGeometry);\n    },\n    fromDirectGeometry: function fromDirectGeometry(a) {\n      var b = new Float32Array(3 * a.vertices.length);\n\n      if (this.addAttribute(\"position\", new na(b, 3).copyVector3sArray(a.vertices)), a.normals.length > 0) {\n        var c = new Float32Array(3 * a.normals.length);\n        this.addAttribute(\"normal\", new na(c, 3).copyVector3sArray(a.normals));\n      }\n\n      if (a.colors.length > 0) {\n        var d = new Float32Array(3 * a.colors.length);\n        this.addAttribute(\"color\", new na(d, 3).copyColorsArray(a.colors));\n      }\n\n      if (a.uvs.length > 0) {\n        var e = new Float32Array(2 * a.uvs.length);\n        this.addAttribute(\"uv\", new na(e, 2).copyVector2sArray(a.uvs));\n      }\n\n      if (a.uvs2.length > 0) {\n        var f = new Float32Array(2 * a.uvs2.length);\n        this.addAttribute(\"uv2\", new na(f, 2).copyVector2sArray(a.uvs2));\n      }\n\n      if (a.indices.length > 0) {\n        var g = ya(a.indices) > 65535 ? Uint32Array : Uint16Array,\n            h = new g(3 * a.indices.length);\n        this.setIndex(new na(h, 1).copyIndicesArray(a.indices));\n      }\n\n      this.groups = a.groups;\n\n      for (var i in a.morphTargets) {\n        for (var j = [], k = a.morphTargets[i], l = 0, m = k.length; l < m; l++) {\n          var n = k[l],\n              o = new va(3 * n.length, 3);\n          j.push(o.copyVector3sArray(n));\n        }\n\n        this.morphAttributes[i] = j;\n      }\n\n      if (a.skinIndices.length > 0) {\n        var p = new va(4 * a.skinIndices.length, 4);\n        this.addAttribute(\"skinIndex\", p.copyVector4sArray(a.skinIndices));\n      }\n\n      if (a.skinWeights.length > 0) {\n        var q = new va(4 * a.skinWeights.length, 4);\n        this.addAttribute(\"skinWeight\", q.copyVector4sArray(a.skinWeights));\n      }\n\n      return null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone()), null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone()), this;\n    },\n    computeBoundingBox: function computeBoundingBox() {\n      null === this.boundingBox && (this.boundingBox = new aa());\n      var a = this.attributes.position;\n      void 0 !== a ? this.boundingBox.setFromBufferAttribute(a) : this.boundingBox.makeEmpty(), (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this);\n    },\n    computeBoundingSphere: function () {\n      var a = new aa(),\n          b = new f();\n      return function () {\n        null === this.boundingSphere && (this.boundingSphere = new ba());\n        var c = this.attributes.position;\n\n        if (c) {\n          var d = this.boundingSphere.center;\n          a.setFromBufferAttribute(c), a.getCenter(d);\n\n          for (var e = 0, f = 0, g = c.count; f < g; f++) {\n            b.x = c.getX(f), b.y = c.getY(f), b.z = c.getZ(f), e = Math.max(e, d.distanceToSquared(b));\n          }\n\n          this.boundingSphere.radius = Math.sqrt(e), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this);\n        }\n      };\n    }(),\n    computeFaceNormals: function computeFaceNormals() {},\n    computeVertexNormals: function computeVertexNormals() {\n      var a = this.index,\n          b = this.attributes,\n          c = this.groups;\n\n      if (b.position) {\n        var d = b.position.array;\n        if (void 0 === b.normal) this.addAttribute(\"normal\", new na(new Float32Array(d.length), 3));else for (var e = b.normal.array, g = 0, h = e.length; g < h; g++) {\n          e[g] = 0;\n        }\n        var i,\n            j,\n            k,\n            l = b.normal.array,\n            m = new f(),\n            n = new f(),\n            o = new f(),\n            p = new f(),\n            q = new f();\n\n        if (a) {\n          var r = a.array;\n          0 === c.length && this.addGroup(0, r.length);\n\n          for (var s = 0, t = c.length; s < t; ++s) {\n            for (var u = c[s], v = u.start, w = u.count, g = v, h = v + w; g < h; g += 3) {\n              i = 3 * r[g + 0], j = 3 * r[g + 1], k = 3 * r[g + 2], m.fromArray(d, i), n.fromArray(d, j), o.fromArray(d, k), p.subVectors(o, n), q.subVectors(m, n), p.cross(q), l[i] += p.x, l[i + 1] += p.y, l[i + 2] += p.z, l[j] += p.x, l[j + 1] += p.y, l[j + 2] += p.z, l[k] += p.x, l[k + 1] += p.y, l[k + 2] += p.z;\n            }\n          }\n        } else for (var g = 0, h = d.length; g < h; g += 9) {\n          m.fromArray(d, g), n.fromArray(d, g + 3), o.fromArray(d, g + 6), p.subVectors(o, n), q.subVectors(m, n), p.cross(q), l[g] = p.x, l[g + 1] = p.y, l[g + 2] = p.z, l[g + 3] = p.x, l[g + 4] = p.y, l[g + 5] = p.z, l[g + 6] = p.x, l[g + 7] = p.y, l[g + 8] = p.z;\n        }\n\n        this.normalizeNormals(), b.normal.needsUpdate = !0;\n      }\n    },\n    merge: function merge(a, b) {\n      if (!a || !a.isBufferGeometry) return void console.error(\"THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.\", a);\n      void 0 === b && (b = 0);\n      var c = this.attributes;\n\n      for (var d in c) {\n        if (void 0 !== a.attributes[d]) for (var e = c[d], f = e.array, g = a.attributes[d], h = g.array, i = g.itemSize, j = 0, k = i * b; j < h.length; j++, k++) {\n          f[k] = h[j];\n        }\n      }\n\n      return this;\n    },\n    normalizeNormals: function () {\n      var a = new f();\n      return function () {\n        for (var b = this.attributes.normal, c = 0, d = b.count; c < d; c++) {\n          a.x = b.getX(c), a.y = b.getY(c), a.z = b.getZ(c), a.normalize(), b.setXYZ(c, a.x, a.y, a.z);\n        }\n      };\n    }(),\n    toNonIndexed: function toNonIndexed() {\n      if (null === this.index) return console.warn(\"THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.\"), this;\n      var a = new za(),\n          b = this.index.array,\n          c = this.attributes;\n\n      for (var d in c) {\n        for (var e = c[d], f = e.array, g = e.itemSize, h = new f.constructor(b.length * g), i = 0, j = 0, k = 0, l = b.length; k < l; k++) {\n          i = b[k] * g;\n\n          for (var m = 0; m < g; m++) {\n            h[j++] = f[i++];\n          }\n        }\n\n        a.addAttribute(d, new na(h, g));\n      }\n\n      return a;\n    },\n    toJSON: function toJSON() {\n      var a = {\n        metadata: {\n          version: 4.5,\n          type: \"BufferGeometry\",\n          generator: \"BufferGeometry.toJSON\"\n        }\n      };\n\n      if (a.uuid = this.uuid, a.type = this.type, \"\" !== this.name && (a.name = this.name), void 0 !== this.parameters) {\n        var b = this.parameters;\n\n        for (var c in b) {\n          void 0 !== b[c] && (a[c] = b[c]);\n        }\n\n        return a;\n      }\n\n      a.data = {\n        attributes: {}\n      };\n      var d = this.index;\n\n      if (null !== d) {\n        var e = Array.prototype.slice.call(d.array);\n        a.data.index = {\n          type: d.array.constructor.name,\n          array: e\n        };\n      }\n\n      var f = this.attributes;\n\n      for (var c in f) {\n        var g = f[c],\n            e = Array.prototype.slice.call(g.array);\n        a.data.attributes[c] = {\n          itemSize: g.itemSize,\n          type: g.array.constructor.name,\n          array: e,\n          normalized: g.normalized\n        };\n      }\n\n      var h = this.groups;\n      h.length > 0 && (a.data.groups = JSON.parse(JSON.stringify(h)));\n      var i = this.boundingSphere;\n      return null !== i && (a.data.boundingSphere = {\n        center: i.center.toArray(),\n        radius: i.radius\n      }), a;\n    },\n    clone: function clone() {\n      return new za().copy(this);\n    },\n    copy: function copy(a) {\n      var b, c, d;\n      this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.name = a.name;\n      var e = a.index;\n      null !== e && this.setIndex(e.clone());\n      var f = a.attributes;\n\n      for (b in f) {\n        var g = f[b];\n        this.addAttribute(b, g.clone());\n      }\n\n      var h = a.morphAttributes;\n\n      for (b in h) {\n        var i = [],\n            j = h[b];\n\n        for (c = 0, d = j.length; c < d; c++) {\n          i.push(j[c].clone());\n        }\n\n        this.morphAttributes[b] = i;\n      }\n\n      var k = a.groups;\n\n      for (c = 0, d = k.length; c < d; c++) {\n        var l = k[c];\n        this.addGroup(l.start, l.count, l.materialIndex);\n      }\n\n      var m = a.boundingBox;\n      null !== m && (this.boundingBox = m.clone());\n      var n = a.boundingSphere;\n      return null !== n && (this.boundingSphere = n.clone()), this.drawRange.start = a.drawRange.start, this.drawRange.count = a.drawRange.count, this;\n    },\n    dispose: function dispose() {\n      this.dispatchEvent({\n        type: \"dispose\"\n      });\n    }\n  }), Aa.prototype = Object.create(ma.prototype), Aa.prototype.constructor = Aa, Ba.prototype = Object.create(za.prototype), Ba.prototype.constructor = Ba, Ca.prototype = Object.create(ma.prototype), Ca.prototype.constructor = Ca, Da.prototype = Object.create(za.prototype), Da.prototype.constructor = Da, Ea.prototype = Object.create(Z.prototype), Ea.prototype.constructor = Ea, Ea.prototype.isMeshBasicMaterial = !0, Ea.prototype.copy = function (a) {\n    return Z.prototype.copy.call(this, a), this.color.copy(a.color), this.map = a.map, this.lightMap = a.lightMap, this.lightMapIntensity = a.lightMapIntensity, this.aoMap = a.aoMap, this.aoMapIntensity = a.aoMapIntensity, this.specularMap = a.specularMap, this.alphaMap = a.alphaMap, this.envMap = a.envMap, this.combine = a.combine, this.reflectivity = a.reflectivity, this.refractionRatio = a.refractionRatio, this.wireframe = a.wireframe, this.wireframeLinewidth = a.wireframeLinewidth, this.wireframeLinecap = a.wireframeLinecap, this.wireframeLinejoin = a.wireframeLinejoin, this.skinning = a.skinning, this.morphTargets = a.morphTargets, this;\n  }, Fa.prototype = Object.create(Z.prototype), Fa.prototype.constructor = Fa, Fa.prototype.isShaderMaterial = !0, Fa.prototype.copy = function (a) {\n    return Z.prototype.copy.call(this, a), this.fragmentShader = a.fragmentShader, this.vertexShader = a.vertexShader, this.uniforms = Jd.clone(a.uniforms), this.defines = a.defines, this.wireframe = a.wireframe, this.wireframeLinewidth = a.wireframeLinewidth, this.lights = a.lights, this.clipping = a.clipping, this.skinning = a.skinning, this.morphTargets = a.morphTargets, this.morphNormals = a.morphNormals, this.extensions = a.extensions, this;\n  }, Fa.prototype.toJSON = function (a) {\n    var b = Z.prototype.toJSON.call(this, a);\n    return b.uniforms = this.uniforms, b.vertexShader = this.vertexShader, b.fragmentShader = this.fragmentShader, b;\n  }, Object.assign(Ga.prototype, {\n    set: function set(a, b) {\n      return this.origin.copy(a), this.direction.copy(b), this;\n    },\n    clone: function clone() {\n      return new this.constructor().copy(this);\n    },\n    copy: function copy(a) {\n      return this.origin.copy(a.origin), this.direction.copy(a.direction), this;\n    },\n    at: function at(a, b) {\n      return (b || new f()).copy(this.direction).multiplyScalar(a).add(this.origin);\n    },\n    lookAt: function lookAt(a) {\n      return this.direction.copy(a).sub(this.origin).normalize(), this;\n    },\n    recast: function () {\n      var a = new f();\n      return function (b) {\n        return this.origin.copy(this.at(b, a)), this;\n      };\n    }(),\n    closestPointToPoint: function closestPointToPoint(a, b) {\n      var c = b || new f();\n      c.subVectors(a, this.origin);\n      var d = c.dot(this.direction);\n      return d < 0 ? c.copy(this.origin) : c.copy(this.direction).multiplyScalar(d).add(this.origin);\n    },\n    distanceToPoint: function distanceToPoint(a) {\n      return Math.sqrt(this.distanceSqToPoint(a));\n    },\n    distanceSqToPoint: function () {\n      var a = new f();\n      return function (b) {\n        var c = a.subVectors(b, this.origin).dot(this.direction);\n        return c < 0 ? this.origin.distanceToSquared(b) : (a.copy(this.direction).multiplyScalar(c).add(this.origin), a.distanceToSquared(b));\n      };\n    }(),\n    distanceSqToSegment: function () {\n      var a = new f(),\n          b = new f(),\n          c = new f();\n      return function (d, e, f, g) {\n        a.copy(d).add(e).multiplyScalar(.5), b.copy(e).sub(d).normalize(), c.copy(this.origin).sub(a);\n        var h,\n            i,\n            j,\n            k,\n            l = .5 * d.distanceTo(e),\n            m = -this.direction.dot(b),\n            n = c.dot(this.direction),\n            o = -c.dot(b),\n            p = c.lengthSq(),\n            q = Math.abs(1 - m * m);\n        if (q > 0) {\n          if (h = m * o - n, i = m * n - o, k = l * q, h >= 0) {\n            if (i >= -k) {\n              if (i <= k) {\n                var r = 1 / q;\n                h *= r, i *= r, j = h * (h + m * i + 2 * n) + i * (m * h + i + 2 * o) + p;\n              } else i = l, h = Math.max(0, -(m * i + n)), j = -h * h + i * (i + 2 * o) + p;\n            } else i = -l, h = Math.max(0, -(m * i + n)), j = -h * h + i * (i + 2 * o) + p;\n          } else i <= -k ? (h = Math.max(0, -(-m * l + n)), i = h > 0 ? -l : Math.min(Math.max(-l, -o), l), j = -h * h + i * (i + 2 * o) + p) : i <= k ? (h = 0, i = Math.min(Math.max(-l, -o), l), j = i * (i + 2 * o) + p) : (h = Math.max(0, -(m * l + n)), i = h > 0 ? l : Math.min(Math.max(-l, -o), l), j = -h * h + i * (i + 2 * o) + p);\n        } else i = m > 0 ? -l : l, h = Math.max(0, -(m * i + n)), j = -h * h + i * (i + 2 * o) + p;\n        return f && f.copy(this.direction).multiplyScalar(h).add(this.origin), g && g.copy(b).multiplyScalar(i).add(a), j;\n      };\n    }(),\n    intersectSphere: function () {\n      var a = new f();\n      return function (b, c) {\n        a.subVectors(b.center, this.origin);\n        var d = a.dot(this.direction),\n            e = a.dot(a) - d * d,\n            f = b.radius * b.radius;\n        if (e > f) return null;\n        var g = Math.sqrt(f - e),\n            h = d - g,\n            i = d + g;\n        return h < 0 && i < 0 ? null : h < 0 ? this.at(i, c) : this.at(h, c);\n      };\n    }(),\n    intersectsSphere: function intersectsSphere(a) {\n      return this.distanceToPoint(a.center) <= a.radius;\n    },\n    distanceToPlane: function distanceToPlane(a) {\n      var b = a.normal.dot(this.direction);\n      if (0 === b) return 0 === a.distanceToPoint(this.origin) ? 0 : null;\n      var c = -(this.origin.dot(a.normal) + a.constant) / b;\n      return c >= 0 ? c : null;\n    },\n    intersectPlane: function intersectPlane(a, b) {\n      var c = this.distanceToPlane(a);\n      return null === c ? null : this.at(c, b);\n    },\n    intersectsPlane: function intersectsPlane(a) {\n      var b = a.distanceToPoint(this.origin);\n      return 0 === b || a.normal.dot(this.direction) * b < 0;\n    },\n    intersectBox: function intersectBox(a, b) {\n      var c,\n          d,\n          e,\n          f,\n          g,\n          h,\n          i = 1 / this.direction.x,\n          j = 1 / this.direction.y,\n          k = 1 / this.direction.z,\n          l = this.origin;\n      return i >= 0 ? (c = (a.min.x - l.x) * i, d = (a.max.x - l.x) * i) : (c = (a.max.x - l.x) * i, d = (a.min.x - l.x) * i), j >= 0 ? (e = (a.min.y - l.y) * j, f = (a.max.y - l.y) * j) : (e = (a.max.y - l.y) * j, f = (a.min.y - l.y) * j), c > f || e > d ? null : ((e > c || c !== c) && (c = e), (f < d || d !== d) && (d = f), k >= 0 ? (g = (a.min.z - l.z) * k, h = (a.max.z - l.z) * k) : (g = (a.max.z - l.z) * k, h = (a.min.z - l.z) * k), c > h || g > d ? null : ((g > c || c !== c) && (c = g), (h < d || d !== d) && (d = h), d < 0 ? null : this.at(c >= 0 ? c : d, b)));\n    },\n    intersectsBox: function () {\n      var a = new f();\n      return function (b) {\n        return null !== this.intersectBox(b, a);\n      };\n    }(),\n    intersectTriangle: function () {\n      var a = new f(),\n          b = new f(),\n          c = new f(),\n          d = new f();\n      return function (e, f, g, h, i) {\n        b.subVectors(f, e), c.subVectors(g, e), d.crossVectors(b, c);\n        var j,\n            k = this.direction.dot(d);\n\n        if (k > 0) {\n          if (h) return null;\n          j = 1;\n        } else {\n          if (!(k < 0)) return null;\n          j = -1, k = -k;\n        }\n\n        a.subVectors(this.origin, e);\n        var l = j * this.direction.dot(c.crossVectors(a, c));\n        if (l < 0) return null;\n        var m = j * this.direction.dot(b.cross(a));\n        if (m < 0) return null;\n        if (l + m > k) return null;\n        var n = -j * a.dot(d);\n        return n < 0 ? null : this.at(n / k, i);\n      };\n    }(),\n    applyMatrix4: function applyMatrix4(a) {\n      return this.origin.applyMatrix4(a), this.direction.transformDirection(a), this;\n    },\n    equals: function equals(a) {\n      return a.origin.equals(this.origin) && a.direction.equals(this.direction);\n    }\n  }), Object.assign(Ha.prototype, {\n    set: function set(a, b) {\n      return this.start.copy(a), this.end.copy(b), this;\n    },\n    clone: function clone() {\n      return new this.constructor().copy(this);\n    },\n    copy: function copy(a) {\n      return this.start.copy(a.start), this.end.copy(a.end), this;\n    },\n    getCenter: function getCenter(a) {\n      return (a || new f()).addVectors(this.start, this.end).multiplyScalar(.5);\n    },\n    delta: function delta(a) {\n      return (a || new f()).subVectors(this.end, this.start);\n    },\n    distanceSq: function distanceSq() {\n      return this.start.distanceToSquared(this.end);\n    },\n    distance: function distance() {\n      return this.start.distanceTo(this.end);\n    },\n    at: function at(a, b) {\n      var c = b || new f();\n      return this.delta(c).multiplyScalar(a).add(this.start);\n    },\n    closestPointToPointParameter: function () {\n      var a = new f(),\n          b = new f();\n      return function (c, d) {\n        a.subVectors(c, this.start), b.subVectors(this.end, this.start);\n        var e = b.dot(b),\n            f = b.dot(a),\n            g = f / e;\n        return d && (g = yd.clamp(g, 0, 1)), g;\n      };\n    }(),\n    closestPointToPoint: function closestPointToPoint(a, b, c) {\n      var d = this.closestPointToPointParameter(a, b),\n          e = c || new f();\n      return this.delta(e).multiplyScalar(d).add(this.start);\n    },\n    applyMatrix4: function applyMatrix4(a) {\n      return this.start.applyMatrix4(a), this.end.applyMatrix4(a), this;\n    },\n    equals: function equals(a) {\n      return a.start.equals(this.start) && a.end.equals(this.end);\n    }\n  }), Object.assign(Ia, {\n    normal: function () {\n      var a = new f();\n      return function (b, c, d, e) {\n        var g = e || new f();\n        g.subVectors(d, c), a.subVectors(b, c), g.cross(a);\n        var h = g.lengthSq();\n        return h > 0 ? g.multiplyScalar(1 / Math.sqrt(h)) : g.set(0, 0, 0);\n      };\n    }(),\n    barycoordFromPoint: function () {\n      var a = new f(),\n          b = new f(),\n          c = new f();\n      return function (d, e, g, h, i) {\n        a.subVectors(h, e), b.subVectors(g, e), c.subVectors(d, e);\n        var j = a.dot(a),\n            k = a.dot(b),\n            l = a.dot(c),\n            m = b.dot(b),\n            n = b.dot(c),\n            o = j * m - k * k,\n            p = i || new f();\n        if (0 === o) return p.set(-2, -1, -1);\n        var q = 1 / o,\n            r = (m * l - k * n) * q,\n            s = (j * n - k * l) * q;\n        return p.set(1 - r - s, s, r);\n      };\n    }(),\n    containsPoint: function () {\n      var a = new f();\n      return function (b, c, d, e) {\n        var f = Ia.barycoordFromPoint(b, c, d, e, a);\n        return f.x >= 0 && f.y >= 0 && f.x + f.y <= 1;\n      };\n    }()\n  }), Object.assign(Ia.prototype, {\n    set: function set(a, b, c) {\n      return this.a.copy(a), this.b.copy(b), this.c.copy(c), this;\n    },\n    setFromPointsAndIndices: function setFromPointsAndIndices(a, b, c, d) {\n      return this.a.copy(a[b]), this.b.copy(a[c]), this.c.copy(a[d]), this;\n    },\n    clone: function clone() {\n      return new this.constructor().copy(this);\n    },\n    copy: function copy(a) {\n      return this.a.copy(a.a), this.b.copy(a.b), this.c.copy(a.c), this;\n    },\n    area: function () {\n      var a = new f(),\n          b = new f();\n      return function () {\n        return a.subVectors(this.c, this.b), b.subVectors(this.a, this.b), .5 * a.cross(b).length();\n      };\n    }(),\n    midpoint: function midpoint(a) {\n      return (a || new f()).addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);\n    },\n    normal: function normal(a) {\n      return Ia.normal(this.a, this.b, this.c, a);\n    },\n    plane: function plane(a) {\n      return (a || new ca()).setFromCoplanarPoints(this.a, this.b, this.c);\n    },\n    barycoordFromPoint: function barycoordFromPoint(a, b) {\n      return Ia.barycoordFromPoint(a, this.a, this.b, this.c, b);\n    },\n    containsPoint: function containsPoint(a) {\n      return Ia.containsPoint(a, this.a, this.b, this.c);\n    },\n    closestPointToPoint: function () {\n      var a = new ca(),\n          b = [new Ha(), new Ha(), new Ha()],\n          c = new f(),\n          d = new f();\n      return function (e, g) {\n        var h = g || new f(),\n            i = 1 / 0;\n        if (a.setFromCoplanarPoints(this.a, this.b, this.c), a.projectPoint(e, c), !0 === this.containsPoint(c)) h.copy(c);else {\n          b[0].set(this.a, this.b), b[1].set(this.b, this.c), b[2].set(this.c, this.a);\n\n          for (var j = 0; j < b.length; j++) {\n            b[j].closestPointToPoint(c, !0, d);\n            var k = c.distanceToSquared(d);\n            k < i && (i = k, h.copy(d));\n          }\n        }\n        return h;\n      };\n    }(),\n    equals: function equals(a) {\n      return a.a.equals(this.a) && a.b.equals(this.b) && a.c.equals(this.c);\n    }\n  }), Ja.prototype = Object.assign(Object.create(ia.prototype), {\n    constructor: Ja,\n    isMesh: !0,\n    setDrawMode: function setDrawMode(a) {\n      this.drawMode = a;\n    },\n    copy: function copy(a) {\n      return ia.prototype.copy.call(this, a), this.drawMode = a.drawMode, void 0 !== a.morphTargetInfluences && (this.morphTargetInfluences = a.morphTargetInfluences.slice()), void 0 !== a.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, a.morphTargetDictionary)), this;\n    },\n    updateMorphTargets: function updateMorphTargets() {\n      var a,\n          b,\n          c,\n          d = this.geometry;\n\n      if (d.isBufferGeometry) {\n        var e = d.morphAttributes,\n            f = Object.keys(e);\n\n        if (f.length > 0) {\n          var g = e[f[0]];\n          if (void 0 !== g) for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, a = 0, b = g.length; a < b; a++) {\n            c = g[a].name || String(a), this.morphTargetInfluences.push(0), this.morphTargetDictionary[c] = a;\n          }\n        }\n      } else {\n        var h = d.morphTargets;\n        if (void 0 !== h && h.length > 0) for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, a = 0, b = h.length; a < b; a++) {\n          c = h[a].name || String(a), this.morphTargetInfluences.push(0), this.morphTargetDictionary[c] = a;\n        }\n      }\n    },\n    raycast: function () {\n      function a(a, b, c, d, e, f, g) {\n        return Ia.barycoordFromPoint(a, b, c, d, s), e.multiplyScalar(s.x), f.multiplyScalar(s.y), g.multiplyScalar(s.z), e.add(f).add(g), e.clone();\n      }\n\n      function b(a, b, c, d, e, f, g, h) {\n        if (null === (b.side === Hb ? d.intersectTriangle(g, f, e, !0, h) : d.intersectTriangle(e, f, g, b.side !== Ib, h))) return null;\n        u.copy(h), u.applyMatrix4(a.matrixWorld);\n        var i = c.ray.origin.distanceTo(u);\n        return i < c.near || i > c.far ? null : {\n          distance: i,\n          point: u.clone(),\n          object: a\n        };\n      }\n\n      function e(c, d, e, f, g, h, i, m) {\n        j.fromBufferAttribute(f, h), k.fromBufferAttribute(f, i), l.fromBufferAttribute(f, m);\n        var n = b(c, c.material, d, e, j, k, l, t);\n        return n && (g && (p.fromBufferAttribute(g, h), q.fromBufferAttribute(g, i), r.fromBufferAttribute(g, m), n.uv = a(t, j, k, l, p, q, r)), n.face = new la(h, i, m, Ia.normal(j, k, l)), n.faceIndex = h), n;\n      }\n\n      var g = new d(),\n          h = new Ga(),\n          i = new ba(),\n          j = new f(),\n          k = new f(),\n          l = new f(),\n          m = new f(),\n          n = new f(),\n          o = new f(),\n          p = new c(),\n          q = new c(),\n          r = new c(),\n          s = new f(),\n          t = new f(),\n          u = new f();\n      return function (c, d) {\n        var f = this.geometry,\n            s = this.material,\n            u = this.matrixWorld;\n\n        if (void 0 !== s && (null === f.boundingSphere && f.computeBoundingSphere(), i.copy(f.boundingSphere), i.applyMatrix4(u), !1 !== c.ray.intersectsSphere(i) && (g.getInverse(u), h.copy(c.ray).applyMatrix4(g), null === f.boundingBox || !1 !== h.intersectsBox(f.boundingBox)))) {\n          var v;\n\n          if (f.isBufferGeometry) {\n            var w,\n                x,\n                y,\n                z,\n                A,\n                B = f.index,\n                C = f.attributes.position,\n                D = f.attributes.uv;\n            if (null !== B) for (z = 0, A = B.count; z < A; z += 3) {\n              w = B.getX(z), x = B.getX(z + 1), y = B.getX(z + 2), (v = e(this, c, h, C, D, w, x, y)) && (v.faceIndex = Math.floor(z / 3), d.push(v));\n            } else if (void 0 !== C) for (z = 0, A = C.count; z < A; z += 3) {\n              w = z, x = z + 1, y = z + 2, (v = e(this, c, h, C, D, w, x, y)) && (v.index = w, d.push(v));\n            }\n          } else if (f.isGeometry) {\n            var E,\n                F,\n                G,\n                H,\n                I = Array.isArray(s),\n                J = f.vertices,\n                K = f.faces,\n                L = f.faceVertexUvs[0];\n            L.length > 0 && (H = L);\n\n            for (var M = 0, N = K.length; M < N; M++) {\n              var O = K[M],\n                  P = I ? s[O.materialIndex] : s;\n\n              if (void 0 !== P) {\n                if (E = J[O.a], F = J[O.b], G = J[O.c], !0 === P.morphTargets) {\n                  var Q = f.morphTargets,\n                      R = this.morphTargetInfluences;\n                  j.set(0, 0, 0), k.set(0, 0, 0), l.set(0, 0, 0);\n\n                  for (var S = 0, T = Q.length; S < T; S++) {\n                    var U = R[S];\n\n                    if (0 !== U) {\n                      var V = Q[S].vertices;\n                      j.addScaledVector(m.subVectors(V[O.a], E), U), k.addScaledVector(n.subVectors(V[O.b], F), U), l.addScaledVector(o.subVectors(V[O.c], G), U);\n                    }\n                  }\n\n                  j.add(E), k.add(F), l.add(G), E = j, F = k, G = l;\n                }\n\n                if (v = b(this, P, c, h, E, F, G, t)) {\n                  if (H && H[M]) {\n                    var W = H[M];\n                    p.copy(W[0]), q.copy(W[1]), r.copy(W[2]), v.uv = a(t, E, F, G, p, q, r);\n                  }\n\n                  v.face = O, v.faceIndex = M, d.push(v);\n                }\n              }\n            }\n          }\n        }\n      };\n    }(),\n    clone: function clone() {\n      return new this.constructor(this.geometry, this.material).copy(this);\n    }\n  });\n  var Sf = 0;\n  ob.prototype = Object.assign(Object.create(ja.prototype), {\n    constructor: ob,\n    isPerspectiveCamera: !0,\n    copy: function copy(a, b) {\n      return ja.prototype.copy.call(this, a, b), this.fov = a.fov, this.zoom = a.zoom, this.near = a.near, this.far = a.far, this.focus = a.focus, this.aspect = a.aspect, this.view = null === a.view ? null : Object.assign({}, a.view), this.filmGauge = a.filmGauge, this.filmOffset = a.filmOffset, this;\n    },\n    setFocalLength: function setFocalLength(a) {\n      var b = .5 * this.getFilmHeight() / a;\n      this.fov = 2 * yd.RAD2DEG * Math.atan(b), this.updateProjectionMatrix();\n    },\n    getFocalLength: function getFocalLength() {\n      var a = Math.tan(.5 * yd.DEG2RAD * this.fov);\n      return .5 * this.getFilmHeight() / a;\n    },\n    getEffectiveFOV: function getEffectiveFOV() {\n      return 2 * yd.RAD2DEG * Math.atan(Math.tan(.5 * yd.DEG2RAD * this.fov) / this.zoom);\n    },\n    getFilmWidth: function getFilmWidth() {\n      return this.filmGauge * Math.min(this.aspect, 1);\n    },\n    getFilmHeight: function getFilmHeight() {\n      return this.filmGauge / Math.max(this.aspect, 1);\n    },\n    setViewOffset: function setViewOffset(a, b, c, d, e, f) {\n      this.aspect = a / b, null === this.view && (this.view = {\n        enabled: !0,\n        fullWidth: 1,\n        fullHeight: 1,\n        offsetX: 0,\n        offsetY: 0,\n        width: 1,\n        height: 1\n      }), this.view.enabled = !0, this.view.fullWidth = a, this.view.fullHeight = b, this.view.offsetX = c, this.view.offsetY = d, this.view.width = e, this.view.height = f, this.updateProjectionMatrix();\n    },\n    clearViewOffset: function clearViewOffset() {\n      null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix();\n    },\n    updateProjectionMatrix: function updateProjectionMatrix() {\n      var a = this.near,\n          b = a * Math.tan(.5 * yd.DEG2RAD * this.fov) / this.zoom,\n          c = 2 * b,\n          d = this.aspect * c,\n          e = -.5 * d,\n          f = this.view;\n\n      if (null !== this.view && this.view.enabled) {\n        var g = f.fullWidth,\n            h = f.fullHeight;\n        e += f.offsetX * d / g, b -= f.offsetY * c / h, d *= f.width / g, c *= f.height / h;\n      }\n\n      var i = this.filmOffset;\n      0 !== i && (e += a * i / this.getFilmWidth()), this.projectionMatrix.makePerspective(e, e + d, b, b - c, a, this.far);\n    },\n    toJSON: function toJSON(a) {\n      var b = ia.prototype.toJSON.call(this, a);\n      return b.object.fov = this.fov, b.object.zoom = this.zoom, b.object.near = this.near, b.object.far = this.far, b.object.focus = this.focus, b.object.aspect = this.aspect, null !== this.view && (b.object.view = Object.assign({}, this.view)), b.object.filmGauge = this.filmGauge, b.object.filmOffset = this.filmOffset, b;\n    }\n  }), pb.prototype = Object.assign(Object.create(ob.prototype), {\n    constructor: pb,\n    isArrayCamera: !0\n  }), vb.prototype = Object.assign(Object.create(ia.prototype), {\n    constructor: vb,\n    copy: function copy(a, b) {\n      return ia.prototype.copy.call(this, a, b), null !== a.background && (this.background = a.background.clone()), null !== a.fog && (this.fog = a.fog.clone()), null !== a.overrideMaterial && (this.overrideMaterial = a.overrideMaterial.clone()), this.autoUpdate = a.autoUpdate, this.matrixAutoUpdate = a.matrixAutoUpdate, this;\n    },\n    toJSON: function toJSON(a) {\n      var b = ia.prototype.toJSON.call(this, a);\n      return null !== this.background && (b.object.background = this.background.toJSON(a)), null !== this.fog && (b.object.fog = this.fog.toJSON()), b;\n    }\n  });\n  var Tf = {\n    enabled: !1,\n    files: {},\n    add: function add(a, b) {\n      !1 !== this.enabled && (this.files[a] = b);\n    },\n    get: function get(a) {\n      if (!1 !== this.enabled) return this.files[a];\n    },\n    remove: function remove(a) {\n      delete this.files[a];\n    },\n    clear: function clear() {\n      this.files = {};\n    }\n  },\n      Uf = new wb();\n  Object.assign(xb.prototype, {\n    crossOrigin: \"Anonymous\",\n    load: function load(a, b, c, d) {\n      void 0 === a && (a = \"\"), void 0 !== this.path && (a = this.path + a), a = this.manager.resolveURL(a);\n      var e = this,\n          f = Tf.get(a);\n      if (void 0 !== f) return e.manager.itemStart(a), setTimeout(function () {\n        b && b(f), e.manager.itemEnd(a);\n      }, 0), f;\n      var g = document.createElementNS(\"http://www.w3.org/1999/xhtml\", \"img\");\n      return g.addEventListener(\"load\", function () {\n        Tf.add(a, this), b && b(this), e.manager.itemEnd(a);\n      }, !1), g.addEventListener(\"error\", function (b) {\n        d && d(b), e.manager.itemEnd(a), e.manager.itemError(a);\n      }, !1), \"data:\" !== a.substr(0, 5) && void 0 !== this.crossOrigin && (g.crossOrigin = this.crossOrigin), e.manager.itemStart(a), g.src = a, g;\n    },\n    setCrossOrigin: function setCrossOrigin(a) {\n      return this.crossOrigin = a, this;\n    },\n    setPath: function setPath(a) {\n      return this.path = a, this;\n    }\n  }), Object.assign(yb.prototype, {\n    crossOrigin: \"Anonymous\",\n    load: function load(a, b, c, d) {\n      var e = new h(),\n          f = new xb(this.manager);\n      return f.setCrossOrigin(this.crossOrigin), f.setPath(this.path), f.load(a, function (c) {\n        e.image = c;\n        var d = a.search(/\\.(jpg|jpeg)$/) > 0 || 0 === a.search(/^data\\:image\\/jpeg/);\n        e.format = d ? Zc : $c, e.needsUpdate = !0, void 0 !== b && b(e);\n      }, c, d), e;\n    },\n    setCrossOrigin: function setCrossOrigin(a) {\n      return this.crossOrigin = a, this;\n    },\n    setPath: function setPath(a) {\n      return this.path = a, this;\n    }\n  }), a.WebGLRenderTarget = j, a.WebGLRenderer = ub, a.Scene = vb, a.Mesh = Ja, a.DataTexture = k, a.PlaneGeometry = Ca, a.ShaderMaterial = Fa, a.MeshBasicMaterial = Ea, a.Material = Z, a.TextureLoader = yb, a.OrthographicCamera = ka, a.ClampToEdgeWrapping = Ec, a.FloatType = Sc, a.LinearFilter = Jc, a.NearestFilter = Gc, a.NearestMipMapNearestFilter = Hc, a.RepeatWrapping = Dc, a.RGBAFormat = $c, a.UnsignedByteType = Mc, Object.defineProperty(a, \"__esModule\", {\n    value: !0\n  });\n}), require = function () {\n  function a(b, c, d) {\n    function e(g, h) {\n      if (!c[g]) {\n        if (!b[g]) {\n          var i = \"function\" == typeof require && require;\n          if (!h && i) return i(g, !0);\n          if (f) return f(g, !0);\n          var j = new Error(\"Cannot find module '\" + g + \"'\");\n          throw j.code = \"MODULE_NOT_FOUND\", j;\n        }\n\n        var k = c[g] = {\n          exports: {}\n        };\n        b[g][0].call(k.exports, function (a) {\n          return e(b[g][1][a] || a);\n        }, k, k.exports, a, b, c, d);\n      }\n\n      return c[g].exports;\n    }\n\n    for (var f = \"function\" == typeof require && require, g = 0; g < d.length; g++) {\n      e(d[g]);\n    }\n\n    return e;\n  }\n\n  return a;\n}()({\n  1: [function (a, b, c) {\n    (function (b) {\n      (function () {\n        b.THREE = a(\"three\"), THREE = {\n          ClampToEdgeWrapping: THREE.ClampToEdgeWrapping,\n          DataTexture: THREE.DataTexture,\n          FloatType: THREE.FloatType,\n          LinearFilter: THREE.LinearFilter,\n          Material: THREE.Material,\n          Mesh: THREE.Mesh,\n          MeshBasicMaterial: THREE.MeshBasicMaterial,\n          NearestFilter: THREE.NearestFilter,\n          NearestMipMapNearestFilter: THREE.NearestMipMapNearestFilter,\n          OrthographicCamera: THREE.OrthographicCamera,\n          PlaneGeometry: THREE.PlaneGeometry,\n          RepeatWrapping: THREE.RepeatWrapping,\n          RGBAFormat: THREE.RGBAFormat,\n          Scene: THREE.Scene,\n          ShaderMaterial: THREE.ShaderMaterial,\n          TextureLoader: THREE.TextureLoader,\n          UnsignedByteType: THREE.UnsignedByteType,\n          WebGLRenderer: THREE.WebGLRenderer,\n          WebGLRenderTarget: THREE.WebGLRenderTarget\n        };\n      }).call(this);\n    }).call(this, \"undefined\" != typeof global ? global : \"undefined\" != typeof self ? self : \"undefined\" != typeof window ? window : {});\n  }, {\n    three: \"three\"\n  }],\n  three: [function (a, b, c) {\n    b.exports = window.THREE;\n  }, {}]\n}, {}, [1]);\nvar Detector = {\n  canvas: !!window.CanvasRenderingContext2D,\n  webgl: function () {\n    try {\n      var a = document.createElement(\"canvas\");\n      return !(!window.WebGLRenderingContext || !a.getContext(\"webgl\") && !a.getContext(\"experimental-webgl\"));\n    } catch (a) {\n      return !1;\n    }\n  }(),\n  workers: !!window.Worker,\n  fileapi: window.File && window.FileReader && window.FileList && window.Blob,\n  getWebGLErrorMessage: function getWebGLErrorMessage() {\n    var a = document.createElement(\"div\");\n    return a.id = \"webgl-error-message\", a.style.fontFamily = \"monospace\", a.style.fontSize = \"13px\", a.style.fontWeight = \"normal\", a.style.textAlign = \"center\", a.style.background = \"#fff\", a.style.color = \"#000\", a.style.padding = \"1.5em\", a.style.width = \"400px\", a.style.margin = \"5em auto 0\", this.webgl || (a.innerHTML = window.WebGLRenderingContext ? ['Your graphics card does not seem to support <a href=\"http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation\" style=\"color:#000\">WebGL</a>.<br />', 'Find out how to get it <a href=\"http://get.webgl.org/\" style=\"color:#000\">here</a>.'].join(\"\\n\") : ['Your browser does not seem to support <a href=\"http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation\" style=\"color:#000\">WebGL</a>.<br/>', 'Find out how to get it <a href=\"http://get.webgl.org/\" style=\"color:#000\">here</a>.'].join(\"\\n\")), a;\n  },\n  addGetWebGLMessage: function addGetWebGLMessage(a) {\n    var b, c, d;\n    a = a || {}, b = void 0 !== a.parent ? a.parent : document.body, c = void 0 !== a.id ? a.id : \"oldie\", d = Detector.getWebGLErrorMessage(), d.id = c, b.appendChild(d);\n  }\n};\n\"object\" == (typeof module === \"undefined\" ? \"undefined\" : _typeof(module)) && (module.exports = Detector), function (a, b) {\n  \"use strict\";\n\n  function c() {\n    if (a.postMessage && !a.importScripts) {\n      var b = !0,\n          c = a.onmessage;\n      return a.onmessage = function () {\n        b = !1;\n      }, a.postMessage(\"\", \"*\"), a.onmessage = c, b;\n    }\n  }\n\n  function d() {\n    return a.navigator && /Trident/.test(a.navigator.userAgent);\n  }\n\n  if (!d() && (a.msSetImmediate || a.setImmediate)) return void (a.setImmediate || (a.setImmediate = a.msSetImmediate, a.clearImmediate = a.msClearImmediate));\n  var e = a.document,\n      f = Array.prototype.slice,\n      g = Object.prototype.toString,\n      h = {};\n  h.polifill = {}, h.nextId = 1, h.tasks = {}, h.lock = !1, h.run = function (b) {\n    if (h.lock) a.setTimeout(h.wrap(h.run, b), 0);else {\n      var c = h.tasks[b];\n\n      if (c) {\n        h.lock = !0;\n\n        try {\n          c();\n        } finally {\n          h.clear(b), h.lock = !1;\n        }\n      }\n    }\n  }, h.wrap = function (a) {\n    var c = f.call(arguments, 1);\n    return function () {\n      a.apply(b, c);\n    };\n  }, h.create = function (a) {\n    return h.tasks[h.nextId] = h.wrap.apply(b, a), h.nextId++;\n  }, h.clear = function (a) {\n    delete h.tasks[a];\n  }, h.polifill.messageChannel = function () {\n    var b = new a.MessageChannel();\n    return b.port1.onmessage = function (a) {\n      h.run(Number(a.data));\n    }, function () {\n      var a = h.create(arguments);\n      return b.port2.postMessage(a), a;\n    };\n  }, h.polifill.nextTick = function () {\n    return function () {\n      var b = h.create(arguments);\n      return a.process.nextTick(h.wrap(h.run, b)), b;\n    };\n  }, h.polifill.postMessage = function () {\n    var b = \"setImmediate$\" + Math.random() + \"$\",\n        c = function c(_c2) {\n      _c2.source === a && \"string\" == typeof _c2.data && 0 === _c2.data.indexOf(b) && h.run(Number(_c2.data.slice(b.length)));\n    };\n\n    return a.addEventListener ? a.addEventListener(\"message\", c, !1) : a.attachEvent(\"onmessage\", c), function () {\n      var c = h.create(arguments);\n      return a.postMessage(b + c, \"*\"), c;\n    };\n  }, h.polifill.readyStateChange = function () {\n    var a = e.documentElement;\n    return function () {\n      var b = h.create(arguments),\n          c = e.createElement(\"script\");\n      return c.onreadystatechange = function () {\n        h.run(b), c.onreadystatechange = null, a.removeChild(c), c = null;\n      }, a.appendChild(c), b;\n    };\n  }, h.polifill.setTimeout = function () {\n    return function () {\n      var b = h.create(arguments);\n      return a.setTimeout(h.wrap(h.run, b), 0), b;\n    };\n  };\n  var i;\n  i = d() ? \"setTimeout\" : \"[object process]\" === g.call(a.process) ? \"nextTick\" : c() ? \"postMessage\" : a.MessageChannel ? \"messageChannel\" : e && \"onreadystatechange\" in e.createElement(\"script\") ? \"readyStateChange\" : \"setTimeout\";\n  var j = Object.getPrototypeOf && Object.getPrototypeOf(a);\n  j = j && j.setTimeout ? j : a, j.setImmediate = h.polifill[i](), j.setImmediate.usePolifill = i, j.msSetImmediate = j.setImmediate, j.clearImmediate = h.clear, j.msClearImmediate = h.clear;\n}(function () {\n  return this || (0, eval)(\"this\");\n}()), function () {\n  \"use strict\";\n\n  function a() {}\n\n  function b(a, b) {\n    for (var c = a.length; c--;) {\n      if (a[c].listener === b) return c;\n    }\n\n    return -1;\n  }\n\n  function c(a) {\n    return function () {\n      return this[a].apply(this, arguments);\n    };\n  }\n\n  var d = a.prototype,\n      e = this,\n      f = e.EventEmitter;\n  d.getListeners = function (a) {\n    var b,\n        c,\n        d = this._getEvents();\n\n    if (a instanceof RegExp) {\n      b = {};\n\n      for (c in d) {\n        d.hasOwnProperty(c) && a.test(c) && (b[c] = d[c]);\n      }\n    } else b = d[a] || (d[a] = []);\n\n    return b;\n  }, d.flattenListeners = function (a) {\n    var b,\n        c = [];\n\n    for (b = 0; b < a.length; b += 1) {\n      c.push(a[b].listener);\n    }\n\n    return c;\n  }, d.getListenersAsObject = function (a) {\n    var b,\n        c = this.getListeners(a);\n    return c instanceof Array && (b = {}, b[a] = c), b || c;\n  }, d.addListener = function (a, c) {\n    var d,\n        e = this.getListenersAsObject(a),\n        f = \"object\" == _typeof(c);\n\n    for (d in e) {\n      e.hasOwnProperty(d) && -1 === b(e[d], c) && e[d].push(f ? c : {\n        listener: c,\n        once: !1\n      });\n    }\n\n    return this;\n  }, d.on = c(\"addListener\"), d.addOnceListener = function (a, b) {\n    return this.addListener(a, {\n      listener: b,\n      once: !0\n    });\n  }, d.once = c(\"addOnceListener\"), d.defineEvent = function (a) {\n    return this.getListeners(a), this;\n  }, d.defineEvents = function (a) {\n    for (var b = 0; b < a.length; b += 1) {\n      this.defineEvent(a[b]);\n    }\n\n    return this;\n  }, d.removeListener = function (a, c) {\n    var d,\n        e,\n        f = this.getListenersAsObject(a);\n\n    for (e in f) {\n      f.hasOwnProperty(e) && -1 !== (d = b(f[e], c)) && f[e].splice(d, 1);\n    }\n\n    return this;\n  }, d.off = c(\"removeListener\"), d.addListeners = function (a, b) {\n    return this.manipulateListeners(!1, a, b);\n  }, d.removeListeners = function (a, b) {\n    return this.manipulateListeners(!0, a, b);\n  }, d.manipulateListeners = function (a, b, c) {\n    var d,\n        e,\n        f = a ? this.removeListener : this.addListener,\n        g = a ? this.removeListeners : this.addListeners;\n    if (\"object\" != _typeof(b) || b instanceof RegExp) for (d = c.length; d--;) {\n      f.call(this, b, c[d]);\n    } else for (d in b) {\n      b.hasOwnProperty(d) && (e = b[d]) && (\"function\" == typeof e ? f.call(this, d, e) : g.call(this, d, e));\n    }\n    return this;\n  }, d.removeEvent = function (a) {\n    var b,\n        c = _typeof(a),\n        d = this._getEvents();\n\n    if (\"string\" === c) delete d[a];else if (a instanceof RegExp) for (b in d) {\n      d.hasOwnProperty(b) && a.test(b) && delete d[b];\n    } else delete this._events;\n    return this;\n  }, d.removeAllListeners = c(\"removeEvent\"), d.emitEvent = function (a, b) {\n    var c,\n        d,\n        e,\n        f,\n        g = this.getListenersAsObject(a);\n\n    for (f in g) {\n      if (g.hasOwnProperty(f)) for (c = g[f].slice(0), e = c.length; e--;) {\n        d = c[e], !0 === d.once && this.removeListener(a, d.listener), d.listener.apply(this, b || []) === this._getOnceReturnValue() && this.removeListener(a, d.listener);\n      }\n    }\n\n    return this;\n  }, d.trigger = c(\"emitEvent\"), d.emit = function (a) {\n    var b = Array.prototype.slice.call(arguments, 1);\n    return this.emitEvent(a, b);\n  }, d.setOnceReturnValue = function (a) {\n    return this._onceReturnValue = a, this;\n  }, d._getOnceReturnValue = function () {\n    return !this.hasOwnProperty(\"_onceReturnValue\") || this._onceReturnValue;\n  }, d._getEvents = function () {\n    return this._events || (this._events = {});\n  }, a.noConflict = function () {\n    return e.EventEmitter = f, a;\n  }, \"function\" == typeof define && define.amd ? define(function () {\n    return a;\n  }) : \"object\" == (typeof module === \"undefined\" ? \"undefined\" : _typeof(module)) && module.exports ? module.exports = a : e.EventEmitter = a;\n}.call(this), GrowingPacker = function GrowingPacker() {}, GrowingPacker.prototype = {\n  fit: function fit(a) {\n    var b,\n        c,\n        d,\n        e = a.length,\n        f = e > 0 ? a[0].w : 0,\n        g = e > 0 ? a[0].h : 0;\n\n    for (this.root = {\n      x: 0,\n      y: 0,\n      w: f,\n      h: g\n    }, b = 0; b < e; b++) {\n      d = a[b], (c = this.findNode(this.root, d.w, d.h)) ? d.fit = this.splitNode(c, d.w, d.h) : d.fit = this.growNode(d.w, d.h);\n    }\n  },\n  findNode: function findNode(a, b, c) {\n    return a.used ? this.findNode(a.right, b, c) || this.findNode(a.down, b, c) : b <= a.w && c <= a.h ? a : null;\n  },\n  splitNode: function splitNode(a, b, c) {\n    return a.used = !0, a.down = {\n      x: a.x,\n      y: a.y + c,\n      w: a.w,\n      h: a.h - c\n    }, a.right = {\n      x: a.x + b,\n      y: a.y,\n      w: a.w - b,\n      h: c\n    }, a;\n  },\n  growNode: function growNode(a, b) {\n    var c = a <= this.root.w,\n        d = b <= this.root.h,\n        e = d && this.root.h >= this.root.w + a,\n        f = c && this.root.w >= this.root.h + b;\n    return e ? this.growRight(a, b) : f ? this.growDown(a, b) : d ? this.growRight(a, b) : c ? this.growDown(a, b) : null;\n  },\n  growRight: function growRight(a, b) {\n    this.root = {\n      used: !0,\n      x: 0,\n      y: 0,\n      w: this.root.w + a,\n      h: this.root.h,\n      down: this.root,\n      right: {\n        x: this.root.w,\n        y: 0,\n        w: a,\n        h: this.root.h\n      }\n    };\n    var c = this.findNode(this.root, a, b);\n    return c ? this.splitNode(c, a, b) : null;\n  },\n  growDown: function growDown(a, b) {\n    this.root = {\n      used: !0,\n      x: 0,\n      y: 0,\n      w: this.root.w,\n      h: this.root.h + b,\n      down: {\n        x: 0,\n        y: this.root.h,\n        w: this.root.w,\n        h: b\n      },\n      right: this.root\n    };\n    var c = this.findNode(this.root, a, b);\n    return c ? this.splitNode(c, a, b) : null;\n  }\n}, function () {\n  function a(a, d) {\n    var e = new Date().getTime(),\n        f = Math.max(0, 16 - (e - c)),\n        g = b.setTimeout(function () {\n      a(e + f);\n    }, f);\n    return c = e + f, g;\n  }\n\n  for (var b = this, c = 0, d = [\"ms\", \"moz\", \"webkit\", \"o\"], e = 0; e < d.length && !b.requestAnimationFrame; ++e) {\n    b.requestAnimationFrame = b[d[e] + \"RequestAnimationFrame\"], b.cancelAnimationFrame = b[d[e] + \"CancelAnimationFrame\"] || b[d[e] + \"CancelRequestAnimationFrame\"];\n  }\n\n  b.requestAnimationFrame || (b.requestAnimationFrame = a), b.cancelAnimationFrame || (b.cancelAnimationFrame = function (a) {\n    clearTimeout(a);\n  }), \"undefined\" != typeof exports ? (\"undefined\" != typeof module && module.exports && (exports = module.exports = b.requestAnimationFrame), exports.requestAnimationFrame = b.requestAnimationFrame) : b.requestAnimationFrame = b.requestAnimationFrame, \"function\" == typeof define && define.amd && define(\"requestAnimationFrame\", [], function () {\n    return b.requestAnimationFrame;\n  });\n}(), function (a, b, c, d, e) {\n  var f = this,\n      g = f.Blotter = a = function a(_a2, b) {\n    d.webgl || g.Messaging.throwError(\"Blotter\", !1, \"device does not support webgl\"), this._texts = [], this._textEventBindings = {}, this._scopes = {}, this._scopeEventBindings = {}, this._renderer = new g.Renderer(), this._startTime = 0, this._lastDrawTime = 0, this.init.apply(this, arguments);\n  };\n\n  g.prototype = function () {\n    function a() {\n      var a = Date.now();\n      this._material.uniforms.uTimeDelta.value = (a - (this._lastDrawTime || a)) / 1e3, this._material.uniforms.uGlobalTime.value = (a - this._startTime) / 1e3, this._lastDrawTime = a;\n    }\n\n    function c() {\n      a.call(this), b.each(this._scopes, b.bind(function (a) {\n        a.playing && a.render(), this.trigger(\"render\");\n      }, this));\n    }\n\n    function d(a) {\n      if (this.mappingMaterial) {\n        var b = this._material.uniforms[a].value;\n        this.mappingMaterial.uniformInterface[a].value = b;\n      }\n    }\n\n    function e(a, b) {\n      if (this.mappingMaterial) {\n        var c = this._scopes[a],\n            d = c.material.uniforms[b].value;\n        this.mappingMaterial.textUniformInterface[a][b].value = d;\n      }\n    }\n\n    function f() {\n      var a, c, d;\n      a = b.bind(function () {\n        return b.bind(function (a) {\n          g.MappingBuilder.build(this._texts, b.bind(function (b) {\n            this._mapping = b, this._mapping.ratio = this.ratio, a();\n          }, this));\n        }, this);\n      }, this), c = b.bind(function () {\n        return b.bind(function (a) {\n          g.MappingMaterialBuilder.build(this._mapping, this._material, b.bind(function (b) {\n            this.mappingMaterial = b, a();\n          }, this));\n        }, this);\n      }, this), d = [a(), c()], b(d).reduceRight(b.wrap, b.bind(function () {\n        this._renderer.stop(), b.each(this._scopes, b.bind(function (a, b) {\n          a.mappingMaterial = this.mappingMaterial, a.needsUpdate = !0;\n        }, this)), this._renderer.material = this.mappingMaterial.shaderMaterial, this._renderer.width = this._mapping.width, this._renderer.height = this._mapping.height, this.autostart && this.start(), this.trigger(this.lastUpdated ? \"update\" : \"ready\"), this.lastUpdated = Date.now();\n      }, this))();\n    }\n\n    return {\n      constructor: g,\n\n      get needsUpdate() {},\n\n      set needsUpdate(a) {\n        !0 === a && f.call(this);\n      },\n\n      get material() {\n        return this._material;\n      },\n\n      set material(a) {\n        this.setMaterial(a);\n      },\n\n      get texts() {\n        return this._texts;\n      },\n\n      set texts(a) {\n        this.removeTexts(this._texts), this.addTexts(a);\n      },\n\n      get imageData() {\n        return this._renderer.imageData;\n      },\n\n      init: function init(a, d) {\n        d = d || {}, b.defaults(this, d, {\n          ratio: g.CanvasUtils.pixelRatio,\n          autobuild: !0,\n          autostart: !0,\n          autoplay: !0\n        }), this.setMaterial(a), this.addTexts(d.texts), this._renderer.on(\"render\", b.bind(c, this)), this.autobuild && (this.needsUpdate = !0), this.autostart && this.start();\n      },\n      start: function start() {\n        this.autostart = !0, this._startTime = Date.now(), this._renderer.start();\n      },\n      stop: function stop() {\n        this.autostart = !1, this._renderer.stop();\n      },\n      teardown: function teardown() {\n        this._renderer.teardown();\n      },\n      setMaterial: function setMaterial(a) {\n        g.Messaging.ensureInstanceOf(a, g.Material, \"Blotter.Material\", \"Blotter\", \"setMaterial\"), this._material = a, this._materialEventBinding && this._materialEventBinding.unsetEventCallbacks(), this._materialEventBinding = new g.ModelEventBinding(a, {\n          update: b.bind(function () {\n            f.call(this);\n          }, this),\n          updateUniform: b.bind(function (a) {\n            d.call(this, a);\n          }, this)\n        }), a.on(\"update\", this._materialEventBinding.eventCallbacks.update), a.on(\"update:uniform\", this._materialEventBinding.eventCallbacks.updateUniform);\n      },\n      addText: function addText(a) {\n        this.addTexts(a);\n      },\n      addTexts: function addTexts(a) {\n        var c = g.TextUtils.filterTexts(a),\n            d = b.difference(c, this._texts);\n        b.each(d, b.bind(function (a) {\n          this._texts.push(a), this._textEventBindings[a.id] = new g.ModelEventBinding(a, {\n            update: b.bind(function () {\n              f.call(this);\n            }, this)\n          }), a.on(\"update\", this._textEventBindings[a.id].eventCallbacks.update), this._scopes[a.id] = new g.RenderScope(a, this), this._scopeEventBindings[a.id] = new g.ModelEventBinding(this._scopes[a.id], {\n            updateUniform: b.bind(function (b) {\n              e.call(this, a.id, b);\n            }, this)\n          }), this._scopes[a.id].on(\"update:uniform\", this._scopeEventBindings[a.id].eventCallbacks.updateUniform);\n        }, this));\n      },\n      removeText: function removeText(a) {\n        this.removeTexts(a);\n      },\n      removeTexts: function removeTexts(a) {\n        var c = g.TextUtils.filterTexts(a),\n            d = b.intersection(this._texts, c);\n        b.each(d, b.bind(function (a) {\n          this._texts = b.without(this._texts, a), this._textEventBindings[a.id].unsetEventCallbacks(), this._scopeEventBindings[a.id].unsetEventCallbacks(), delete this._textEventBindings[a.id], delete this._scopeEventBindings[a.id], delete this._scopes[a.id];\n        }, this));\n      },\n      forText: function forText(a) {\n        return g.Messaging.ensureInstanceOf(a, g.Text, \"Blotter.Text\", \"Blotter\", \"forText\"), this._scopes[a.id] ? this._scopes[a.id] : void g.Messaging.logError(\"Blotter\", \"forText\", \"Blotter.Text object not found in blotter\");\n      },\n      boundsForText: function boundsForText(a) {\n        return g.Messaging.ensureInstanceOf(a, g.Text, \"Blotter.Text\", \"Blotter\", \"boundsForText\"), this._scopes[a.id] ? this._mapping ? this.mappingMaterial.boundsForText(a) : void 0 : void g.Messaging.logError(\"Blotter\", \"boundsForText\", \"Blotter.Text object not found in blotter\");\n      }\n    };\n  }(), b.extend(g.prototype, e.prototype), g.Version = \"v0.1.0\", g.webglRenderer = g.webglRenderer || new c.WebGLRenderer({\n    antialias: !0,\n    alpha: !0,\n    premultipliedAlpha: !1\n  }), g.Assets = g.Assets || {}, g.Assets.Shaders = g.Assets.Shaders || {};\n}(this.Blotter, this._, this.THREE, this.Detector, this.EventEmitter), function (a) {\n  a.Math = {\n    generateUUID: function () {\n      for (var a = [], b = 0; b < 256; b++) {\n        a[b] = (b < 16 ? \"0\" : \"\") + b.toString(16).toUpperCase();\n      }\n\n      return function () {\n        var b = 4294967295 * Math.random() | 0,\n            c = 4294967295 * Math.random() | 0,\n            d = 4294967295 * Math.random() | 0,\n            e = 4294967295 * Math.random() | 0;\n        return a[255 & b] + a[b >> 8 & 255] + a[b >> 16 & 255] + a[b >> 24 & 255] + \"-\" + a[255 & c] + a[c >> 8 & 255] + \"-\" + a[c >> 16 & 15 | 64] + a[c >> 24 & 255] + \"-\" + a[63 & d | 128] + a[d >> 8 & 255] + \"-\" + a[d >> 16 & 255] + a[d >> 24 & 255] + a[255 & e] + a[e >> 8 & 255] + a[e >> 16 & 255] + a[e >> 24 & 255];\n      };\n    }()\n  };\n}(this.Blotter), function (a) {\n  a.Messaging = function () {\n    function a(a, b, c) {\n      return a + (b ? \"#\" + b : \"\") + \": \" + c;\n    }\n\n    return {\n      ensureInstanceOf: function ensureInstanceOf(a, b, c, d, e) {\n        if (!(a instanceof b)) return void this.logError(d, e, \"argument must be instanceof \" + c);\n      },\n      logError: function logError(b, c, d) {\n        var e = a(b, c, d);\n        console.error(e);\n      },\n      logWarning: function logWarning(b, c, d) {\n        var e = a(b, c, d);\n        console.warn(e);\n      },\n      throwError: function throwError(b, c, d) {\n        throw a(b, c, d);\n      }\n    };\n  }();\n}(this.Blotter), function (a, b) {\n  a._extendWithGettersSetters = function (a) {\n    return b.each(Array.prototype.slice.call(arguments, 1), function (b) {\n      if (b) for (var c in b) {\n        a[c] && Object.getOwnPropertyDescriptor(a, c) && Object.getOwnPropertyDescriptor(a, c).set ? Object.getOwnPropertyDescriptor(a, c).set(b[c]) : a[c] = b[c];\n      }\n    }), a;\n  };\n}(this.Blotter, this._), function (a) {\n  a.VendorPrefixes = [\"ms\", \"moz\", \"webkit\", \"o\"];\n}(this.Blotter), function (a, b) {\n  a.ModelEventBinding = function (a, b) {\n    this.model = a, this.eventCallbacks = b || {};\n  }, a.ModelEventBinding.prototype = {\n    constructor: a.ModelEventBinding,\n    unsetEventCallbacks: function unsetEventCallbacks() {\n      b.each(this.eventCallbacks, b.bind(function (a, b) {\n        this.model.off(b, a);\n      }, this));\n    }\n  };\n}(this.Blotter, this._), function (a) {\n  a.CanvasUtils = {\n    canvas: function canvas(a, b, c) {\n      c = c || {};\n      var d = document.createElement(\"canvas\");\n      return d.className = c.class, d.innerHTML = c.html, d.width = a, d.height = b, d;\n    },\n    hiDpiCanvas: function hiDpiCanvas(a, b, c, d) {\n      c = c || this.pixelRatio, d = d || {};\n      var e = document.createElement(\"canvas\");\n      return e.className = d.class, e.innerHTML = d.html, this.updateCanvasSize(e, a, b, c), e;\n    },\n    updateCanvasSize: function updateCanvasSize(a, b, c, d) {\n      d = d || 1, a.width = b * d, a.height = c * d, a.style.width = b + \"px\", a.style.height = c + \"px\", a.getContext(\"2d\").setTransform(d, 0, 0, d, 0, 0);\n    },\n    pixelRatio: function () {\n      for (var b = document.createElement(\"canvas\").getContext(\"2d\"), c = window.devicePixelRatio || 1, d = b.backingStorePixelRatio, e = 0; e < a.VendorPrefixes.length && !d; ++e) {\n        d = b[a.VendorPrefixes[e] + \"BackingStorePixelRatio\"];\n      }\n\n      return d = d || 1, c / d;\n    }(),\n    mousePosition: function mousePosition(a, b) {\n      var c = a.getBoundingClientRect();\n      return {\n        x: b.clientX - c.left,\n        y: b.clientY - c.top\n      };\n    },\n    normalizedMousePosition: function normalizedMousePosition(a, b) {\n      var c = a.getBoundingClientRect(),\n          d = this.mousePosition(a, b);\n      return {\n        x: d.x / c.width,\n        y: d.y / c.height\n      };\n    }\n  };\n}(this.Blotter), function (a, b) {\n  a.PropertyDefaults = {\n    family: \"sans-serif\",\n    size: 12,\n    leading: 1.5,\n    fill: \"#000\",\n    style: \"normal\",\n    weight: 400,\n    padding: 0,\n    paddingTop: 0,\n    paddingRight: 0,\n    paddingBottom: 0,\n    paddingLeft: 0\n  }, a.TextUtils = {\n    Properties: b.keys(a.PropertyDefaults),\n    ensurePropertyValues: function ensurePropertyValues(c) {\n      return c = b.defaults(c || {}, a.PropertyDefaults);\n    },\n    filterTexts: function filterTexts(c) {\n      return c = c instanceof a.Text ? [c] : b.toArray(c), b.filter(c, b.bind(function (b) {\n        var c = b instanceof a.Text;\n        return c || a.Messaging.logWarning(\"Blotter.TextUtils\", \"filterTexts\", \"object must be instance of Blotter.Text\"), c;\n      }, this));\n    },\n    stringifiedPadding: function stringifiedPadding(a) {\n      var b = a || this.ensurePropertyValues();\n      return (a.paddingTop || b.padding) + \"px \" + (b.paddingRight || b.padding) + \"px \" + (b.paddingBottom || b.padding) + \"px \" + (b.paddingLeft || b.padding) + \"px\";\n    },\n    sizeForText: function sizeForText(a, b) {\n      var c,\n          d = document.createElement(\"span\");\n      return b = this.ensurePropertyValues(b), d.innerHTML = a, d.style.display = \"inline-block\", d.style.fontFamily = b.family, d.style.fontSize = b.size + \"px\", d.style.fontWeight = b.weight, d.style.fontStyle = b.style, d.style.lineHeight = b.leading, d.style.maxWidth = \"none\", d.style.padding = this.stringifiedPadding(b), d.style.position = \"absolute\", d.style.width = \"auto\", d.style.visibility = \"hidden\", document.body.appendChild(d), c = {\n        w: d.offsetWidth,\n        h: d.offsetHeight\n      }, document.body.removeChild(d), c;\n    }\n  };\n}(this.Blotter, this._), function (a, b) {\n  a.UniformUtils = {\n    UniformTypes: [\"1f\", \"2f\", \"3f\", \"4f\"],\n    defaultUniforms: {\n      uResolution: {\n        type: \"2f\",\n        value: [0, 0]\n      },\n      uGlobalTime: {\n        type: \"1f\",\n        value: 0\n      },\n      uTimeDelta: {\n        type: \"1f\",\n        value: 0\n      },\n      uBlendColor: {\n        type: \"4f\",\n        value: [1, 1, 1, 1]\n      },\n      uPixelRatio: {\n        type: \"1f\",\n        value: a.CanvasUtils.pixelRatio\n      }\n    },\n    validValueForUniformType: function validValueForUniformType(a, c) {\n      var d = !1,\n          e = function e(a) {\n        return !isNaN(a);\n      };\n\n      switch (a) {\n        case \"1f\":\n          d = !isNaN(c) && [c].every(e);\n          break;\n\n        case \"2f\":\n          d = b.isArray(c) && 2 == c.length && c.every(e);\n          break;\n\n        case \"3f\":\n          d = b.isArray(c) && 3 == c.length && c.every(e);\n          break;\n\n        case \"4f\":\n          d = b.isArray(c) && 4 == c.length && c.every(e);\n      }\n\n      return d;\n    },\n    glslDataTypeForUniformType: function glslDataTypeForUniformType(a) {\n      var b;\n\n      switch (a) {\n        case \"1f\":\n          b = \"float\";\n          break;\n\n        case \"2f\":\n          b = \"vec2\";\n          break;\n\n        case \"3f\":\n          b = \"vec3\";\n          break;\n\n        case \"4f\":\n          b = \"vec4\";\n      }\n\n      return b;\n    },\n    fullSwizzleStringForUniformType: function fullSwizzleStringForUniformType(a) {\n      var b;\n\n      switch (a) {\n        case \"1f\":\n          b = \"x\";\n          break;\n\n        case \"2f\":\n          b = \"xy\";\n          break;\n\n        case \"3f\":\n          b = \"xyz\";\n          break;\n\n        case \"4f\":\n          b = \"xyzw\";\n      }\n\n      return b;\n    },\n    extractValidUniforms: function extractValidUniforms(c) {\n      return c = c || {}, b.reduce(c, function (c, d, e) {\n        return -1 == a.UniformUtils.UniformTypes.indexOf(d.type) ? (a.Messaging.logError(\"Blotter.UniformUtils\", \"extractValidUniforms\", \"uniforms must be one of type: \" + a.UniformUtils.UniformTypes.join(\", \")), c) : a.UniformUtils.validValueForUniformType(d.type, d.value) ? (c[e] = b.pick(d, \"type\", \"value\"), c) : (a.Messaging.logError(\"Blotter.UniformUtils\", \"extractValidUniforms\", \"uniform value for \" + e + \" is incorrect for type: \" + d.type), c);\n      }, {});\n    },\n    ensureHasRequiredDefaultUniforms: function ensureHasRequiredDefaultUniforms(b, c, d) {\n      if (!a.UniformUtils.hasRequiredDefaultUniforms(b)) return void this.logError(c, d, \"uniforms object is missing required default uniforms defined in Blotter.UniformUtils.defaultUniforms\");\n    },\n    hasRequiredDefaultUniforms: function hasRequiredDefaultUniforms(c) {\n      return !b.difference(b.allKeys(a.UniformUtils.defaultUniforms), b.allKeys(c)).length;\n    }\n  };\n}(this.Blotter, this._), function (a, b, c, d) {\n  a.Text = function (b, c) {\n    this.id = a.Math.generateUUID(), this.value = b, this.properties = c;\n  }, a.Text.prototype = {\n    constructor: a.Text,\n\n    get needsUpdate() {},\n\n    set needsUpdate(a) {\n      !0 === a && this.trigger(\"update\");\n    },\n\n    get properties() {\n      return this._properties;\n    },\n\n    set properties(b) {\n      this._properties = a.TextUtils.ensurePropertyValues(b);\n    }\n\n  }, a._extendWithGettersSetters(a.Text.prototype, d.prototype);\n}(this.Blotter, this._, this.THREE, this.EventEmitter), function (a, b) {\n  a.Assets.Shaders.Blending = [\"//\", \"// Author : Bradley Griffith\", \"// License : Distributed under the MIT License.\", \"//\", \"\", \"// Returns the resulting blend color by blending a top color over a base color\", \"highp vec4 normalBlend(highp vec4 topColor, highp vec4 baseColor) {\", \"  highp vec4 blend = vec4(0.0);\", \"  // HACK\", \"  // Cant divide by 0 (see the 'else' alpha) and after a lot of attempts\", \"  // this simply seems like the only solution Im going to be able to come up with to get alpha back.\", \"  if (baseColor.a == 1.0) {\", \"    baseColor.a = 0.9999999;\", \"  };\", \"  if (topColor.a >= 1.0) {\", \"    blend.a = topColor.a;\", \"    blend.r = topColor.r;\", \"    blend.g = topColor.g;\", \"    blend.b = topColor.b;\", \"  } else if (topColor.a == 0.0) {\", \"    blend.a = baseColor.a;\", \"    blend.r = baseColor.r;\", \"    blend.g = baseColor.g;\", \"    blend.b = baseColor.b;\", \"  } else {\", \"    blend.a = 1.0 - (1.0 - topColor.a) * (1.0 - baseColor.a); // alpha\", \"    blend.r = (topColor.r * topColor.a / blend.a) + (baseColor.r * baseColor.a * (1.0 - topColor.a) / blend.a);\", \"    blend.g = (topColor.g * topColor.a / blend.a) + (baseColor.g * baseColor.a * (1.0 - topColor.a) / blend.a);\", \"    blend.b = (topColor.b * topColor.a / blend.a) + (baseColor.b * baseColor.a * (1.0 - topColor.a) / blend.a);\", \"  }\", \"  return blend;\", \"}\", \"// Returns a vec4 representing the original top color that would have been needed to blend\", \"//  against a passed in base color in order to result in the passed in blend color.\", \"highp vec4 normalUnblend(highp vec4 blendColor, highp vec4 baseColor) {\", \"  highp vec4 unblend = vec4(0.0);\", \"  // HACKY\", \"  // Cant divide by 0 (see alpha) and after a lot of attempts\", \"  // this simply seems like the only solution Im going to be able to come up with to get alpha back.\", \"  if (baseColor.a == 1.0) {\", \"    baseColor.a = 0.9999999;\", \"  }\", \"  unblend.a = 1.0 - ((1.0 - blendColor.a) / (1.0 - baseColor.a));\", \"  // Round to two decimal places\", \"  unblend.a = (sign(100.0 * unblend.a) * floor(abs(100.0 * unblend.a) + 0.5)) / 100.0;\", \"  if (unblend.a >= 1.0) {\", \"    unblend.r = blendColor.r;\", \"    unblend.g = blendColor.g;\", \"    unblend.b = blendColor.b;\", \"  } else if (unblend.a == 0.0) {\", \"    unblend.r = baseColor.r;\", \"    unblend.g = baseColor.g;\", \"    unblend.b = baseColor.b;\", \"  } else {\", \"    unblend.r = (blendColor.r - (baseColor.r * baseColor.a * (1.0 - unblend.a) / blendColor.a)) / (unblend.a / blendColor.a);\", \"    unblend.g = (blendColor.g - (baseColor.g * baseColor.a * (1.0 - unblend.a) / blendColor.a)) / (unblend.a / blendColor.a);\", \"    unblend.b = (blendColor.b - (baseColor.b * baseColor.a * (1.0 - unblend.a) / blendColor.a)) / (unblend.a / blendColor.a);\", \"  }\", \"  return unblend;\", \"}\"].join(\"\\n\");\n}(this.Blotter, this._), function (a, b) {\n  a.Assets.Shaders.Inf = [\"//\", \"// Author : Bradley Griffith\", \"// License : Distributed under the MIT License.\", \"//\", \"bool isinf(float val) {\", \"    return (val != 0.0 && val * 2.0 == val) ? true : false;\", \"}\"].join(\"\\n\");\n}(this.Blotter, this._), function (a, b) {\n  a.Assets.Shaders.LineMath = [a.Assets.Shaders.Inf, \"\", \"//\", \"// Author : Bradley Griffith\", \"// License : Distributed under the MIT License.\", \"//\", \"\", \"// Returns the slope of a line given the degrees of the angle on which that line is rotated;\", \"float slopeForDegrees(float deg) {\", \"    // Ensure degrees stay withing 0.0 - 360.0\", \"    deg = mod(deg, 360.0);\", \"    float radians = deg * (PI / 180.0);\", \"    return tan(radians);\", \"}\", \"// Given x, a slope, and another point, find y for x.\", \"float yForXOnSlope(float x, float slope, vec2 p2) {\", \"    return -1.0 * ((slope * (p2.x - x)) - p2.y);\", \"}\", \"// Given y, a slope, and another point, find x for y.\", \"float xForYOnSlope(float y, float slope, vec2 p2) {\", \"    return ((y - p2.y) + (slope * p2.x)) / slope;\", \"}\", \"// Returns slope adjusted for screen ratio.\", \"float normalizedSlope(float slope, vec2 resolution) {\", \"    vec2 p = vec2(1.0) / resolution;\", \"    return ((slope * 100.0) / p.x) / (100.0 / p.x);\", \"}\", \"// Returns offsets (+/-) for any coordinate at distance given slope.\", \"//   Note: This function does not normalize distance.\", \"//   Note: This function does not adjust slope for screen ratio.\", \"vec2 offsetsForCoordAtDistanceOnSlope(float d, float slope) {\", \"    return vec2(\", \"        (d * cos(atan(slope))),\", \"        (d * sin(atan(slope)))\", \"    );\", \"}\", \"// Returns a boolean designating whether or not an infinite line intersects with an infinite line, and sets an `out` variable for the intersection point if it is found.\", \"//   Note: This function does not adjust slope for screen ratio.\", \"bool lineLineIntersection (out vec2 intersect, in vec2 p1, in float m1, in vec2 p2, in float m2) {\", \"    // See: http://gamedev.stackexchange.com/questions/44720/line-intersection-from-parametric-equation\", \"    //      http://stackoverflow.com/questions/41687083/formula-to-determine-if-an-infinite-line-and-a-line-segment-intersect/41687904#41687904\", \"    bool isIntersecting = false;\", \"    float dx = 1.0;\", \"    float dy = m1;\", \"    float dxx = 1.0;\", \"    float dyy = m2;\", \"    float denominator = ((dxx * dy) - (dyy * dx));\", \"    if (denominator == 0.0) {\", \"        // Lines are parallel\", \"        return isIntersecting;\", \"    }\", \"    if (isinf(dy)) {\", \"        float y = yForXOnSlope(p1.x, m2, p2);\", \"        isIntersecting = true;\", \"        intersect = vec2(p1.x, y);\", \"        return isIntersecting;\", \"    }\", \"    if (isinf(dyy)) {\", \"        float y = yForXOnSlope(p2.x, m1, p1);\", \"        isIntersecting = true;\", \"        intersect = vec2(p2.x, y);\", \"        return isIntersecting;\", \"    }\", \"    float u = ((dx * (p2.y - p1.y)) + (dy * (p1.x - p2.x))) / denominator;\", \"    isIntersecting = true;\", \"    intersect = p2 + (u * vec2(dxx, dyy));\", \"    return isIntersecting;\", \"}\", \"// Returns a boolean designating whether or not an infinite line intersects with a line segment, and sets an `out` variable for the intersection point if it is found.\", \"//   Note: This function does not adjust slope for screen ratio.\", \"bool lineLineSegmentIntersection (out vec2 intersect, in vec2 point, in float m, in vec2 pA, in vec2 pB) {\", \"    // See: http://gamedev.stackexchange.com/questions/44720/line-intersection-from-parametric-equation\", \"    //      http://stackoverflow.com/questions/41687083/formula-to-determine-if-an-infinite-line-and-a-line-segment-intersect/41687904#41687904\", \"    bool isIntersecting = false;\", \"    float dx = 1.0;\", \"    float dy = m;\", \"    float dxx = pB.x - pA.x;\", \"    float dyy = pB.y - pA.y;\", \"    float denominator = ((dxx * dy) - (dyy * dx));\", \"    if (denominator == 0.0 || (isinf(dyy / dxx) && isinf(dy))) {\", \"        // Lines are parallel\", \"        return isIntersecting;\", \"    }\", \"    if (isinf(dy)) {\", \"        float m2 = dyy / dxx;\", \"        float y = yForXOnSlope(point.x, m2, pB);\", \"        isIntersecting = true;\", \"        intersect = vec2(point.x, y);\", \"        return isIntersecting;\", \"    }\", \"    float u = ((dx * (pA.y - point.y)) + (dy * (point.x - pA.x))) / denominator;\", \"    if (u >= 0.0 && u <= 1.0) {\", \"        // Intersection occured on line segment\", \"        isIntersecting = true;\", \"        intersect = pA + (u * vec2(dxx, dyy));\", \"    }\", \"    return isIntersecting;\", \"}\", \"// Dev Note: Terrible code. Needs refactor. Just trying to find \", \"//   which two edges of the rect the intersections occur at.\", \"void intersectsOnRectForLine(out vec2 iA, out vec2 iB, in vec2 rMinXY, in vec2 rMaxXY, in vec2 point, in float slope) {\", \"    bool firstIntersectFound = false;\", \"    vec2 intersectLeft = vec2(0.0);\", \"    vec2 intersectTop = vec2(0.0);\", \"    vec2 intersectRight = vec2(0.0);\", \"    vec2 intersectBottom = vec2(0.0);\", \"    bool intersectsLeft = lineLineSegmentIntersection(intersectLeft, point, slope, rMinXY, vec2(rMinXY.x, rMaxXY.y));\", \"    bool intersectsTop = lineLineSegmentIntersection(intersectTop, point, slope, vec2(rMinXY.x, rMaxXY.y), rMaxXY);\", \"    bool intersectsRight = lineLineSegmentIntersection(intersectRight, point, slope, rMaxXY, vec2(rMaxXY.x, rMinXY.y));\", \"    bool intersectsBottom = lineLineSegmentIntersection(intersectBottom, point, slope, rMinXY, vec2(rMaxXY.x, rMinXY.y));\", \"    if (intersectsLeft) {\", \"        if (firstIntersectFound) {\", \"            iB = intersectLeft;\", \"        }\", \"        else {\", \"            iA = intersectLeft;\", \"            firstIntersectFound = true;\", \"        }\", \"    }\", \"    if (intersectsTop) {\", \"        if (firstIntersectFound) {\", \"            iB = intersectTop;\", \"        }\", \"        else {\", \"            iA = intersectTop;\", \"            firstIntersectFound = true;\", \"        }\", \"    }\", \"    if (intersectsRight) {\", \"        if (firstIntersectFound) {\", \"            iB = intersectRight;\", \"        }\", \"        else {\", \"            iA = intersectRight;\", \"            firstIntersectFound = true;\", \"        }\", \"    }\", \"    if (intersectsBottom) {\", \"        if (firstIntersectFound) {\", \"            iB = intersectBottom;\", \"        }\", \"        else {\", \"            iA = intersectBottom;\", \"        }\", \"    }\", \"}\"].join(\"\\n\");\n}(this.Blotter, this._), function (a, b) {\n  a.Assets.Shaders.BlinnPhongSpecular = [\"//\", \"// Author : Reza Ali\", \"// License : Distributed under the MIT License.\", \"//\", \"\", \"float blinnPhongSpecular( vec3 lightDirection, vec3 viewDirection, vec3 surfaceNormal, float shininess ) {\", \"\", \"  //Calculate Blinn-Phong power\", \"  vec3 H = normalize(viewDirection + lightDirection);\", \"  return pow(max(0.0, dot(surfaceNormal, H)), shininess);\", \"}\"].join(\"\\n\");\n}(this.Blotter, this._), function (a, b) {\n  a.Assets.Shaders.Easing = [\"//\", \"// Author : Reza Ali\", \"// License : Distributed under the MIT License.\", \"//\", \"\", \"float linear( float t, float b, float c, float d )\", \"{\", \"    return t * ( c / d ) + b;\", \"}\", \"\", \"float linear( float t )\", \"{\", \"    return t;\", \"}\", \"\", \"float inQuad( float t, float b, float c, float d )\", \"{\", \"    return c * ( t /= d ) * t + b;\", \"}\", \"\", \"float inQuad( float t )\", \"{\", \"    return t * t;\", \"}\", \"\", \"float outQuad( float t, float b, float c, float d )\", \"{\", \"    return -c * ( t /= d ) * ( t - 2.0 ) + b;\", \"}\", \"\", \"float outQuad( float t )\", \"{\", \"    return - ( t -= 1.0 ) * t + 1.0;\", \"}\", \"\", \"float inOutQuad( float t, float b, float c, float d )\", \"{\", \"    if( ( t /= d / 2.0 ) < 1.0 ) {\", \"      return c / 2.0 * t * t + b;\", \"    }\", \"    return - c / 2.0 * ( ( --t ) * ( t - 2.0 ) - 1.0 ) + b;\", \"}\", \"\", \"float inOutQuad( float t )\", \"{\", \"    if( ( t /= 0.5 ) < 1.0 ) return 0.5 * t * t;\", \"    return -0.5 * ( ( --t ) * ( t-2 ) - 1 );\", \"}\", \"\", \"float inCubic( float t, float b, float c, float d )\", \"{\", \"    return c * ( t /= d ) * t * t + b;\", \"}\", \"\", \"float inCubic( float t )\", \"{\", \"    return t * t * t;\", \"}\", \"\", \"float outCubic( float t, float b, float c, float d )\", \"{\", \"    return c * ( ( t = t/d - 1.0 ) * t * t + 1.0 ) + b;\", \"}\", \"\", \"float outCubic( float t )\", \"{\", \"    return ( ( --t ) * t * t + 1.0 );\", \"}\", \"\", \"float inOutCubic( float t, float b, float c, float d )\", \"{\", \"    if( ( t /= d / 2.0 ) < 1.0 ) return  c / 2.0 * t * t * t + b;\", \"    return c / 2.0 * ( ( t -= 2.0 ) * t * t + 2.0 ) + b;\", \"}\", \"\", \"float inOutCubic( float t )\", \"{\", \"    if( ( t /= 0.5 ) < 1.0 ) return 0.5 * t * t * t;\", \"    return 0.5 * ( ( t -= 2.0 ) * t * t + 2.0 );\", \"}\", \"\", \"float inQuart( float t, float b, float c, float d )\", \"{\", \"    return c * ( t /= d ) * t * t * t + b;\", \"}\", \"\", \"float inQuart( float t )\", \"{\", \"    return t * t * t * t;\", \"}\", \"\", \"float outQuart( float t, float b, float c, float d )\", \"{\", \"    return -c * ( ( t = t/d - 1.0 ) * t * t * t - 1.0 ) + b;\", \"}\", \"\", \"float outQuart( float t )\", \"{\", \"    return - ( ( --t ) * t * t * t - 1.0 );\", \"}\", \"\", \"float inOutQuart( float t, float b, float c, float d )\", \"{\", \"    if ( ( t /= d / 2.0 ) < 1.0 ) return c / 2.0 * t * t * t * t + b;\", \"    return -c / 2.0 * ( ( t -= 2.0 ) * t * t * t - 2.0 ) + b;\", \"}\", \"\", \"float inOutQuart( float t )\", \"{\", \"    if ( (t /= 0.5 ) < 1.0 ) return 0.5 * t * t * t * t;\", \"    return -0.5 * ( ( t -= 2.0 ) * t * t * t - 2.0 );\", \"}\", \"\", \"float inQuint( float t, float b, float c, float d )\", \"{\", \"    return c * ( t /= d ) * t * t * t * t + b;\", \"}\", \"\", \"float inQuint( float t )\", \"{\", \"    return t * t * t * t * t;\", \"}\", \"\", \"float outQuint( float t, float b, float c, float d )\", \"{\", \"    return c * ( ( t = t/d - 1.0) * t * t * t * t + 1.0 ) + b;\", \"}\", \"\", \"float outQuint( float t )\", \"{\", \"    return ( ( --t ) * t * t * t * t + 1.0 );\", \"}\", \"\", \"float inOutQuint( float t, float b, float c, float d )\", \"{\", \"    if( ( t /= d /2.0 ) < 1.0 ) return  c / 2.0 * t * t * t * t * t + b;\", \"    return c / 2.0 * ( ( t -= 2.0 ) * t * t * t * t + 2.0) + b;\", \"}\", \"\", \"float inOutQuint( float t )\", \"{\", \"    if ( ( t /= 0.5 ) < 1.0 ) return 0.5 * t * t * t * t * t;\", \"    return 0.5 * ( ( t -= 2 ) * t * t * t * t + 2.0 );\", \"}\", \"\", \"float inSine( float t, float b, float c, float d )\", \"{\", \"    return -c * cos( t / d * ( 1.5707963268 ) ) + c + b;\", \"}\", \"\", \"float inSine( float t )\", \"{\", \"    return -1.0 * cos( t * ( 1.5707963268 ) ) + 1.0;\", \"}\", \"\", \"float outSine( float t, float b, float c, float d )\", \"{\", \"    return c * sin( t / d * ( 1.5707963268 ) ) + b;\", \"}\", \"\", \"float outSine( float t )\", \"{\", \"    return sin( t * ( 1.5707963268 ) );\", \"}\", \"\", \"float inOutSine( float t, float b, float c, float d )\", \"{\", \"    return - c / 2.0 * ( cos( 3.1415926536 * t / d ) - 1.0 ) + b;\", \"}\", \"\", \"float inOutSine( float t )\", \"{\", \"    return -0.5 * ( cos( 3.1415926536 * t ) - 1.0 );\", \"}\", \"\", \"float inExpo( float t, float b, float c, float d )\", \"{\", \"    return ( t == 0.0 ) ? b : c * pow( 2.0, 10.0 * ( t / d - 1.0 ) ) + b;\", \"}\", \"\", \"float inExpo( float t )\", \"{\", \"    return ( t == 0 ) ? 0.0 : pow( 2.0, 10.0 * ( t - 1.0 ) );\", \"}\", \"\", \"float outExpo( float t, float b, float c, float d )\", \"{\", \"    return ( t == d ) ? b + c : c * ( - pow( 2.0, -10.0 * t / d ) + 1.0 ) + b;\", \"}\", \"\", \"float outExpo( float t )\", \"{\", \"    return ( t == 1.0 ) ? 1.0 : ( - pow( 2.0, -10.0 * t ) + 1.0 );\", \"}\", \"\", \"float inOutExpo( float t, float b, float c, float d )\", \"{\", \"    if( t == 0 ) return b;\", \"    if( t == d ) return b + c;\", \"    if(( t /= d / 2.0 ) < 1.0 ) return c / 2.0 * pow( 2.0, 10.0 * ( t - 1.0 ) ) + b;\", \"    return c / 2.0 * ( - pow( 2.0, -10.0 * --t ) + 2.0 ) + b;\", \"}\", \"\", \"float inOutExpo( float t )\", \"{\", \"    if( t == 0.0 ) return 0.0;\", \"    if( t == 1.0 ) return 1.0;\", \"    if( ( t /= 0.5 ) < 1.0 ) return 0.5 * pow( 2.0, 10.0 * ( t - 1.0 ) );\", \"    return 0.5 * ( - pow( 2.0, -10.0 * --t ) + 2.0 );\", \"}\", \"\", \"float inCirc( float t, float b, float c, float d )\", \"{\", \"    return -c * ( sqrt( 1.0 - (t/=d)*t) - 1) + b;\", \"}\", \"\", \"float inCirc( float t )\", \"{\", \"    return - ( sqrt( 1.0 - t*t) - 1);\", \"}\", \"\", \"float outCirc( float t, float b, float c, float d )\", \"{\", \"    return c * sqrt( 1.0 - (t=t/d-1)*t) + b;\", \"}\", \"\", \"float outCirc( float t )\", \"{\", \"    return sqrt( 1.0 - (--t)*t);\", \"}\", \"\", \"float inOutCirc( float t, float b, float c, float d )\", \"{\", \"    if ( ( t /= d / 2.0 ) < 1 ) return - c / 2.0 * ( sqrt( 1.0 - t * t ) - 1.0 ) + b;\", \"    return c / 2.0 * ( sqrt( 1.0 - ( t -= 2.0 ) * t ) + 1.0 ) + b;\", \"}\", \"\", \"float inOutCirc( float t )\", \"{\", \"    if( ( t /= 0.5 ) < 1.0 ) return -0.5 * ( sqrt( 1.0 - t * t ) - 1.0 );\", \"    return 0.5 * ( sqrt( 1.0 - ( t -= 2.0 ) * t ) + 1.0 );\", \"}\", \"\", \"float inElastic( float t, float b, float c, float d )\", \"{\", \"    float s = 1.70158; float p = 0.0; float a = c;\", \"    if( t == 0 ) return b;  if( ( t /= d ) == 1 ) return b + c;\", \"    p = d * 0.3;\", \"    if( a < abs( c ) ) { a = c; float s = p / 4.0; }\", \"    else s = 0.1591549431 * p / ( 6.2831853072 ) * asin( c / a );\", \"    return -( a * pow( 2.0, 10.0 * ( t -= 1.0 ) ) * sin( ( t * d - s ) * ( 6.2831853072 ) / p ) )  + b;\", \"}\", \"\", \"float inElastic( float t )\", \"{\", \"    float s = 1.70158; float p = 0.0; float a = 1.0;\", \"    if( t == 0.0 ) return 0.0;\", \"    if( t == 1.0 ) return 1.0;\", \"    p = 0.3;\", \"    s = p / ( 6.2831853072 ) * asin( 1.0 / a );\", \"    return -( a * pow( 2.0, 10.0 * ( t -= 1.0 ) ) * sin( ( t - s ) * ( 6.2831853072 ) / p ) );\", \"}\", \"\", \"float outElastic( float t, float b, float c, float d )\", \"{\", \"    float s = 1.70158; float p = 0.0; float a = c;\", \"    if( t == 0.0 ) return b;\", \"    if( (t /= d ) == 1.0 ) return b + c;\", \"    p = d * 0.3;\", \"    if( a < abs( c ) ) { a = c; s = p / 4.0; }\", \"    else { s = p / ( 6.2831853072 ) * asin( c / a ); }\", \"    return a * pow( 2.0, -10.0 * t ) * sin( ( t * d - s ) * ( 6.2831853072 ) / p ) + c + b;\", \"}\", \"\", \"float outElastic( float t )\", \"{\", \"    float s = 1.70158; float p = 0.0 ; float a = 1.0;\", \"    if( t == 0.0 ) return 0.0;  if( t == 1.0 ) return 1.0;\", \"    p = 0.3;\", \"    s = p / ( 6.2831853072 ) * asin( 1.0 / a );\", \"    return a * pow( 2.0, -10.0 * t ) * sin( ( t - s ) * ( 6.2831853072 ) / p ) + 1.0;\", \"}\", \"\", \"float inOutElastic( float t, float b, float c, float d )\", \"{\", \"    float s = 1.70158; float p = 0.0; float a = c;\", \"    if( t == 0.0 ) return b;\", \"    if( ( t /= d / 2.0 ) == 2.0 ) return b + c;\", \"    p = d * ( 0.3 * 1.5 );\", \"    if( a < abs( c ) ) { a = c; s = p / 4.0; }\", \"    else { s = p / ( 6.2831853072 ) * asin( c / a ); }\", \"    if( t < 1.0 ) return -0.5 * ( a * pow( 2.0, 10.0 * ( t -= 1.0 ) ) * sin( ( t * d - s ) * ( 6.2831853072 ) / p ) ) + b;\", \"    return a * pow( 2.0, -10.0 * ( t -= 1.0 ) ) * sin( ( t * d - s ) * ( 6.2831853072 ) / p ) * 0.5 + c + b;\", \"}\", \"\", \"float inOutElastic( float t )\", \"{\", \"    float s = 1.70158; float p = 0; float a = 1.0;\", \"    if( t == 0 ) return 0.0;\", \"    if( ( t /= 0.5 ) == 2.0 ) return 1.0;\", \"    p = ( 0.3 * 1.5 );\", \"    s = p / ( 6.2831853072 ) * asin( 1.0 / a );\", \"    if( t < 1.0 ) return -0.5 * ( a * pow( 2.0, 10.0 * ( t -= 1.0 ) ) * sin( ( t - s ) * ( 6.2831853072 ) / p ) );\", \"    return a * pow( 2.0, -10.0 * ( t -= 1.0 ) ) * sin( ( t - s ) * ( 6.2831853072 ) / p ) * 0.5 + 1.0;\", \"}\", \"\", \"float inBack( float t, float b, float c, float d )\", \"{\", \"    float s = 1.70158;\", \"    return c * ( t /= d ) * t * ( ( s + 1.0 ) * t - s ) + b;\", \"}\", \"\", \"float inBack( float t )\", \"{\", \"    float s = 1.70158;\", \"    return t * t * ( ( s + 1.0 ) * t - s);\", \"}\", \"\", \"float outBack( float t,  float b,  float c,  float d )\", \"{\", \"    float s = 1.70158;\", \"    return c * ( ( t = t / d - 1.0 ) * t * ( ( s + 1.0 ) * t + s ) + 1.0 ) + b;\", \"}\", \"\", \"float outBack( float t )\", \"{\", \"    float s = 1.70158;\", \"    return ( ( --t ) * t * ( ( s + 1.0 ) * t + s ) + 1.0);\", \"}\", \"\", \"float inOutBack( float t, float b, float c, float d )\", \"{\", \"    float s = 1.70158;\", \"    if( ( t /= d / 2.0 ) < 1.0 ) return c / 2.0 * ( t * t * ( ( ( s *= 1.525 ) + 1.0 ) * t - s ) ) + b;\", \"    return c / 2.0 * ( ( t -= 2.0 ) * t * ( ( ( s *= ( 1.525 ) ) + 1.0 ) * t + s ) + 2.0 ) + b;\", \"}\", \"\", \"float inOutBack( float t )\", \"{\", \"    float s = 1.70158;\", \"    if( ( t /= 0.5 ) < 1.0 ) return 0.5 * ( t * t * ( ( ( s *= 1.525 ) + 1.0 ) * t - s ) );\", \"    return 0.5 * ( ( t -= 2 ) * t * ( ( ( s *= ( 1.525 ) ) + 1.0 ) * t + s ) + 2.0 );\", \"}\", \"\", \"float outBounce( float t, float b, float c, float d )\", \"{\", \"    if( ( t /= d ) < ( 1.0 / 2.75 ) ) {\", \"        return c * ( 7.5625 * t * t ) + b;\", \"    } else if ( t < ( 2.0 / 2.75 ) ) {\", \"        return c * ( 7.5625 * ( t -= ( 1.5 / 2.75 ) ) * t + 0.75 ) + b;\", \"    } else if ( t < ( 2.5 / 2.75 ) ) {\", \"        return c * ( 7.5625 * ( t -= ( 2.25 / 2.75 ) ) * t + 0.9375 ) + b;\", \"    } else {\", \"        return c * ( 7.5625 * ( t -= ( 2.625 / 2.75 ) ) * t + 0.984375 ) + b;\", \"    }\", \"}\", \"\", \"float outBounce( float t )\", \"{\", \"    if( t < ( 1.0 / 2.75 ) ) {\", \"        return ( 7.5625 * t * t );\", \"    } else if ( t < ( 2.0 / 2.75 ) ) {\", \"        return ( 7.5625 * ( t-= ( 1.5 / 2.75 ) ) * t + .75 );\", \"    } else if ( t < ( 2.5 / 2.75 ) ) {\", \"        return ( 7.5625 * ( t -= ( 2.25 / 2.75 ) ) * t + 0.9375 );\", \"    } else {\", \"        return ( 7.5625 * ( t -= ( 2.625 / 2.75 ) ) * t + 0.984375 );\", \"    }\", \"}\", \"\", \"float inBounce( float t, float b, float c, float d )\", \"{\", \"    return c - outBounce( d - t, 0.0, c, d ) + b;\", \"}\", \"\", \"float inBounce( float t )\", \"{\", \"    return 1.0 - outBounce( 1.0 - t);\", \"}\", \"\", \"float inOutBounce( float t, float b, float c, float d )\", \"{\", \"    if ( t < d /2.0 ) return inBounce ( t * 2.0, 0.0, c, d ) * 0.5 + b;\", \"    return outBounce ( t * 2.0 - d, 0, c, d ) * 0.5 + c * 0.5 + b;\", \"}\", \"\", \"float inOutBounce( float t )\", \"{\", \"    if ( t < 0.5 ) return inBounce( t * 2.0 ) * 0.5;\", \"    return outBounce( t * 2.0 - 1.0 ) * 0.5 + 0.5;\", \"}\"].join(\"\\n\");\n}(this.Blotter, this._), function (a, b) {\n  a.Assets.Shaders.Gamma = [\"//\", \"// Author : Reza Ali\", \"// License : Distributed under the MIT License.\", \"//\", \"\", \"const vec3 cGammaCorrection = vec3( 0.4545454545 );\", \"\", \"vec3 gamma( in vec3 color )\", \"{\", \"  return pow( color, cGammaCorrection );\", \"}\", \"\", \"vec4 gamma( in vec4 color )\", \"{\", \"  return vec4( gamma( color.rgb ), color.a );\", \"}\"].join(\"\\n\");\n}(this.Blotter, this._), function (a, b) {\n  a.Assets.Shaders.Map = [\"//\", \"// Author : Reza Ali\", \"// License : Distributed under the MIT License.\", \"//\", \"\", \"float map( float value, float inMin, float inMax, float outMin, float outMax )\", \"{\", \"    return ( (value - inMin) / ( inMax - inMin ) * ( outMax - outMin ) ) + outMin;\", \"}\"].join(\"\\n\");\n}(this.Blotter, this._), function (a, b) {\n  a.Assets.Shaders.Noise = [\"//\", \"// Author : Patricio Gonzalez Vivo and Jen Lowe\", \"// License : Distributed under the MIT License.\", \"// Source : https://github.com/patriciogonzalezvivo/thebookofshaders\", \"//\", \"float random (in float _x) {\", \"    return fract(sin(_x)*1e4);\", \"}\", \"\", \"float random (in vec2 co) {\", \"    return fract(sin(dot(co.xy,vec2(12.9898,78.233)))*43758.5453);\", \"}\", \"\", \"float noise (in float _x) {\", \"    float i = floor(_x);\", \"    float f = fract(_x);\", \"    float u = f * f * (3.0 - 2.0 * f);\", \"    return mix(random(i), random(i + 1.0), u);\", \"}\", \"\", \"float noise (in vec2 _st) {\", \"    vec2 i = floor(_st);\", \"    vec2 f = fract(_st);\", \"    // Four corners in 2D of a tile\", \"    float a = random(i);\", \"    float b = random(i + vec2(1.0, 0.0));\", \"    float c = random(i + vec2(0.0, 1.0));\", \"    float d = random(i + vec2(1.0, 1.0));\", \"    vec2 u = f * f * (3.0 - 2.0 * f);\", \"    return mix(a, b, u.x) + \", \"            (c - a)* u.y * (1.0 - u.x) + \", \"            (d - b) * u.x * u.y;\", \"}\"].join(\"\\n\");\n}(this.Blotter, this._), function (a, b) {\n  a.Assets.Shaders.Noise2D = [\"//\", \"// Description : Array and textureless GLSL 2D simplex noise function.\", \"//      Author : Ian McEwan, Ashima Arts.\", \"//  Maintainer : ijm\", \"//     Lastmod : 20110822 (ijm)\", \"//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\", \"//               Distributed under the MIT License. See LICENSE file.\", \"//               https://github.com/ashima/webgl-noise\", \"//\", \"\", \"vec2 n2mod289(vec2 x) {\", \"  return x - floor(x * (1.0 / 289.0)) * 289.0;\", \"}\", \"\", \"vec3 n2mod289(vec3 x) {\", \"  return x - floor(x * (1.0 / 289.0)) * 289.0;\", \"}\", \"\", \"vec4 n2mod289(vec4 x) {\", \"  return x - floor(x * (1.0 / 289.0)) * 289.0;\", \"}\", \"\", \"vec3 permute(vec3 x) {\", \"  return n2mod289(((x*34.0)+1.0)*x);\", \"}\", \"\", \"float snoise(vec2 v)\", \"  {\", \"  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\", \"                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\", \"                     -0.577350269189626,  // -1.0 + 2.0 * C.x\", \"                      0.024390243902439); // 1.0 / 41.0\", \"// First corner\", \"  vec2 i  = floor(v + dot(v, C.yy) );\", \"  vec2 x0 = v -   i + dot(i, C.xx);\", \"\", \"// Other corners\", \"  vec2 i1;\", \"  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\", \"  //i1.y = 1.0 - i1.x;\", \"  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\", \"  // x0 = x0 - 0.0 + 0.0 * C.xx ;\", \"  // x1 = x0 - i1 + 1.0 * C.xx ;\", \"  // x2 = x0 - 1.0 + 2.0 * C.xx ;\", \"  vec4 x12 = x0.xyxy + C.xxzz;\", \"  x12.xy -= i1;\", \"\", \"// Permutations\", \"  i = n2mod289(i); // Avoid truncation effects in permutation\", \"  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\", \"   + i.x + vec3(0.0, i1.x, 1.0 ));\", \"\", \"  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\", \"  m = m*m ;\", \"  m = m*m ;\", \"\", \"// Gradients: 41 points uniformly over a line, mapped onto a diamond.\", \"// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\", \"\", \"  vec3 x = 2.0 * fract(p * C.www) - 1.0;\", \"  vec3 h = abs(x) - 0.5;\", \"  vec3 ox = floor(x + 0.5);\", \"  vec3 a0 = x - ox;\", \"\", \"// Normalise gradients implicitly by scaling m\", \"// Approximation of: m *= inversesqrt( a0*a0 + h*h );\", \"  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\", \"\", \"// Compute final noise value at P\", \"  vec3 g;\", \"  g.x  = a0.x  * x0.x  + h.x  * x0.y;\", \"  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\", \"  return 130.0 * dot(m, g);\", \"}\"].join(\"\\n\");\n}(this.Blotter, this._), function (a, b) {\n  a.Assets.Shaders.Noise3D = [\"//\", \"// Description : Array and textureless GLSL 2D/3D/4D simplex\", \"//               noise functions.\", \"//      Author : Ian McEwan, Ashima Arts.\", \"//  Maintainer : ijm\", \"//     Lastmod : 20110822 (ijm)\", \"//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\", \"//               Distributed under the MIT License. See LICENSE file.\", \"//               https://github.com/ashima/webgl-noise\", \"//\", \"\", \"vec2 n3mod289(vec2 x) {\", \"  return x - floor(x * (1.0 / 289.0)) * 289.0;\", \"}\", \"\", \"vec3 n3mod289(vec3 x) {\", \"  return x - floor(x * (1.0 / 289.0)) * 289.0;\", \"}\", \"\", \"vec4 n3mod289(vec4 x) {\", \"  return x - floor(x * (1.0 / 289.0)) * 289.0;\", \"}\", \"\", \"vec4 permute(vec4 x) {\", \"     return n3mod289(((x*34.0)+1.0)*x);\", \"}\", \"\", \"vec4 taylorInvSqrt(vec4 r)\", \"{\", \"  return 1.79284291400159 - 0.85373472095314 * r;\", \"}\", \"\", \"float snoise(vec3 v)\", \"  {\", \"  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\", \"  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\", \"\", \"// First corner\", \"  vec3 i  = floor(v + dot(v, C.yyy) );\", \"  vec3 x0 =   v - i + dot(i, C.xxx) ;\", \"\", \"// Other corners\", \"  vec3 g = step(x0.yzx, x0.xyz);\", \"  vec3 l = 1.0 - g;\", \"  vec3 i1 = min( g.xyz, l.zxy );\", \"  vec3 i2 = max( g.xyz, l.zxy );\", \"\", \"  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\", \"  //   x1 = x0 - i1  + 1.0 * C.xxx;\", \"  //   x2 = x0 - i2  + 2.0 * C.xxx;\", \"  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\", \"  vec3 x1 = x0 - i1 + C.xxx;\", \"  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\", \"  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\", \"\", \"// Permutations\", \"  i = n3mod289(i);\", \"  vec4 p = permute( permute( permute(\", \"             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\", \"           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\", \"           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\", \"\", \"// Gradients: 7x7 points over a square, mapped onto an octahedron.\", \"// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\", \"  float n_ = 0.142857142857; // 1.0/7.0\", \"  vec3  ns = n_ * D.wyz - D.xzx;\", \"\", \"  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\", \"\", \"  vec4 x_ = floor(j * ns.z);\", \"  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\", \"\", \"  vec4 x = x_ *ns.x + ns.yyyy;\", \"  vec4 y = y_ *ns.x + ns.yyyy;\", \"  vec4 h = 1.0 - abs(x) - abs(y);\", \"\", \"  vec4 b0 = vec4( x.xy, y.xy );\", \"  vec4 b1 = vec4( x.zw, y.zw );\", \"\", \"  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\", \"  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\", \"  vec4 s0 = floor(b0)*2.0 + 1.0;\", \"  vec4 s1 = floor(b1)*2.0 + 1.0;\", \"  vec4 sh = -step(h, vec4(0.0));\", \"\", \"  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\", \"  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\", \"\", \"  vec3 p0 = vec3(a0.xy,h.x);\", \"  vec3 p1 = vec3(a0.zw,h.y);\", \"  vec3 p2 = vec3(a1.xy,h.z);\", \"  vec3 p3 = vec3(a1.zw,h.w);\", \"\", \"//Normalise gradients\", \"  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\", \"  p0 *= norm.x;\", \"  p1 *= norm.y;\", \"  p2 *= norm.z;\", \"  p3 *= norm.w;\", \"\", \"// Mix final noise value\", \"  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\", \"  m = m * m;\", \"  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\", \"                                dot(p2,x2), dot(p3,x3) ) );\", \"  }\"].join(\"\\n\");\n}(this.Blotter, this._), function (a, b) {\n  a.Assets.Shaders.Noise4D = [\"//\", \"// Description : Array and textureless GLSL 2D/3D/4D simplex\", \"//               noise functions.\", \"//      Author : Ian McEwan, Ashima Arts.\", \"//  Maintainer : ijm\", \"//     Lastmod : 20110822 (ijm)\", \"//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\", \"//               Distributed under the MIT License. See LICENSE file.\", \"//               https://github.com/ashima/webgl-noise\", \"//\", \"\", \"vec4 mod289(vec4 x) {\", \"  return x - floor(x * (1.0 / 289.0)) * 289.0; }\", \"\", \"float mod289(float x) {\", \"  return x - floor(x * (1.0 / 289.0)) * 289.0; }\", \"\", \"vec4 permute(vec4 x) {\", \"     return mod289(((x*34.0)+1.0)*x);\", \"}\", \"\", \"float permute(float x) {\", \"     return mod289(((x*34.0)+1.0)*x);\", \"}\", \"\", \"vec4 taylorInvSqrt(vec4 r)\", \"{\", \"  return 1.79284291400159 - 0.85373472095314 * r;\", \"}\", \"\", \"float taylorInvSqrt(float r)\", \"{\", \"  return 1.79284291400159 - 0.85373472095314 * r;\", \"}\", \"\", \"vec4 grad4(float j, vec4 ip)\", \"  {\", \"  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\", \"  vec4 p,s;\", \"\", \"  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\", \"  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\", \"  s = vec4(lessThan(p, vec4(0.0)));\", \"  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\", \"\", \"  return p;\", \"  }\", \"\", \"// (sqrt(5) - 1)/4 = F4, used once below\", \"#define F4 0.309016994374947451\", \"\", \"float snoise(vec4 v)\", \"  {\", \"  const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\", \"                        0.276393202250021,  // 2 * G4\", \"                        0.414589803375032,  // 3 * G4\", \"                       -0.447213595499958); // -1 + 4 * G4\", \"\", \"// First corner\", \"  vec4 i  = floor(v + dot(v, vec4(F4)) );\", \"  vec4 x0 = v -   i + dot(i, C.xxxx);\", \"\", \"// Other corners\", \"\", \"// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\", \"  vec4 i0;\", \"  vec3 isX = step( x0.yzw, x0.xxx );\", \"  vec3 isYZ = step( x0.zww, x0.yyz );\", \"//  i0.x = dot( isX, vec3( 1.0 ) );\", \"  i0.x = isX.x + isX.y + isX.z;\", \"  i0.yzw = 1.0 - isX;\", \"//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\", \"  i0.y += isYZ.x + isYZ.y;\", \"  i0.zw += 1.0 - isYZ.xy;\", \"  i0.z += isYZ.z;\", \"  i0.w += 1.0 - isYZ.z;\", \"\", \"  // i0 now contains the unique values 0,1,2,3 in each channel\", \"  vec4 i3 = clamp( i0, 0.0, 1.0 );\", \"  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\", \"  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\", \"\", \"  //  x0 = x0 - 0.0 + 0.0 * C.xxxx\", \"  //  x1 = x0 - i1  + 1.0 * C.xxxx\", \"  //  x2 = x0 - i2  + 2.0 * C.xxxx\", \"  //  x3 = x0 - i3  + 3.0 * C.xxxx\", \"  //  x4 = x0 - 1.0 + 4.0 * C.xxxx\", \"  vec4 x1 = x0 - i1 + C.xxxx;\", \"  vec4 x2 = x0 - i2 + C.yyyy;\", \"  vec4 x3 = x0 - i3 + C.zzzz;\", \"  vec4 x4 = x0 + C.wwww;\", \"\", \"// Permutations\", \"  i = mod289(i);\", \"  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\", \"  vec4 j1 = permute( permute( permute( permute (\", \"             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\", \"           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\", \"           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\", \"           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\", \"\", \"// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\", \"// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\", \"  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\", \"\", \"  vec4 p0 = grad4(j0,   ip);\", \"  vec4 p1 = grad4(j1.x, ip);\", \"  vec4 p2 = grad4(j1.y, ip);\", \"  vec4 p3 = grad4(j1.z, ip);\", \"  vec4 p4 = grad4(j1.w, ip);\", \"\", \"// Normalise gradients\", \"  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\", \"  p0 *= norm.x;\", \"  p1 *= norm.y;\", \"  p2 *= norm.z;\", \"  p3 *= norm.w;\", \"  p4 *= taylorInvSqrt(dot(p4,p4));\", \"\", \"// Mix contributions from the five corners\", \"  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\", \"  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\", \"  m0 = m0 * m0;\", \"  m1 = m1 * m1;\", \"  return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\", \"               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\", \"\", \"  }\"].join(\"\\n\");\n}(this.Blotter, this._), function (a, b) {\n  a.Assets.Shaders.PI = [\"//\", \"// Author : Reza Ali\", \"// License : Distributed under the MIT License.\", \"//\", \"\", \"#define TWO_PI 6.2831853072\", \"#define PI 3.14159265359\", \"#define HALF_PI 1.57079632679\"].join(\"\\n\");\n}(this.Blotter, this._), function (a, b) {\n  a.Assets.Shaders.Random = [\"//\", \"// Author : Patricio Gonzalez Vivo and Jen Lowe\", \"// License : Distributed under the MIT License.\", \"// Source : https://github.com/patriciogonzalezvivo/thebookofshaders\", \"//\", \"\", \"float random (in float _x) {\", \"    return fract(sin(_x)*1e4);\", \"}\", \"\", \"float random (in vec2 co) {\", \"    return fract(sin(dot(co.xy,vec2(12.9898,78.233)))*43758.5453);\", \"}\"].join(\"\\n\");\n}(this.Blotter, this._), function (a, b) {\n  a.Mapping = function (a, b, c, d) {\n    this.texts = a, this._textBounds = b, this._width = c, this._height = d, this._ratio = 1;\n  }, a.Mapping.prototype = function () {\n    function c(b, c) {\n      return c = c || a.TextUtils.ensurePropertyValues().leading, isNaN(c) ? -1 !== c.toString().indexOf(\"px\") ? c = parseInt(c) : -1 !== c.toString().indexOf(\"%\") && (c = parseInt(c) / 100 * b) : c *= b, c;\n    }\n\n    return {\n      constructor: a.Mapping,\n\n      get ratio() {\n        return this._ratio;\n      },\n\n      set ratio(a) {\n        this._ratio = a || 1;\n      },\n\n      get width() {\n        return this._width * this._ratio;\n      },\n\n      get height() {\n        return this._height * this._ratio;\n      },\n\n      boundsForText: function boundsForText(b) {\n        a.Messaging.ensureInstanceOf(b, a.Text, \"Blotter.Text\", \"Blotter.Mapping\", \"boundsForText\");\n        var c = this._textBounds[b.id];\n        return c && (c = {\n          w: c.w * this._ratio,\n          h: c.h * this._ratio,\n          x: c.x * this._ratio,\n          y: c.y * this._ratio\n        }), c;\n      },\n      toCanvas: function toCanvas(d) {\n        var e = a.CanvasUtils.hiDpiCanvas(this._width, this._height, this._ratio),\n            f = e.getContext(\"2d\", {\n          alpha: !1\n        }),\n            g = new Image();\n        f.textBaseline = \"middle\";\n\n        for (var h = 0; h < this.texts.length; h++) {\n          var i = this.texts[h],\n              j = this._textBounds[i.id],\n              k = c.call(this, i.properties.size, i.properties.leading) / 2;\n          f.font = i.properties.style + \" \" + i.properties.weight + \" \" + i.properties.size + \"px \" + i.properties.family, f.save(), f.translate(j.x + i.properties.paddingLeft, this._height - (j.y + j.h) + i.properties.paddingTop), f.fillStyle = i.properties.fill, f.fillText(i.value, 0, Math.round(k)), f.restore();\n        }\n\n        g.onload = b.bind(function () {\n          f.save(), f.scale(1, -1), f.clearRect(0, -1 * this._height, this._width, this._height), f.drawImage(g, 0, -1 * this._height, this._width, this._height), f.restore(), d(e);\n        }, this), g.src = e.toDataURL(\"image/png\");\n      }\n    };\n  }();\n}(this.Blotter, this._), function (a, b, c) {\n  a.MappingMaterial = function (a, b, c, d) {\n    this.mapping = a, this.material = b, this.shaderMaterial = c, this._userUniformDataTextureObjects = d, this.init.apply(this, arguments);\n  }, a.MappingMaterial.prototype = function () {\n    function d(a, b, c, d) {\n      var e = d.type;\n      \"1f\" == e ? (c[4 * b] = a, c[4 * b + 1] = 0, c[4 * b + 2] = 0, c[4 * b + 3] = 0) : \"2f\" == e ? (c[4 * b] = a[0], c[4 * b + 1] = a[1], c[4 * b + 2] = 0, c[4 * b + 3] = 0) : \"3f\" == e ? (c[4 * b] = a[0], c[4 * b + 1] = a[1], c[4 * b + 2] = a[2], c[4 * b + 3] = 0) : \"4f\" == e ? (c[4 * b] = a[0], c[4 * b + 1] = a[1], c[4 * b + 2] = a[2], c[4 * b + 3] = a[3]) : (c[4 * b] = 0, c[4 * b + 1] = 0, c[4 * b + 2] = 0, c[4 * b + 3] = 0);\n    }\n\n    function e(d) {\n      var e = {\n        _type: d.userUniform.type,\n        _value: d.userUniform.value,\n\n        get value() {\n          return this._value;\n        },\n\n        set value(b) {\n          if (!a.UniformUtils.validValueForUniformType(this._type, b)) return void a.Messaging.logError(\"Blotter.MappingMaterial\", !1, \"uniform value not valid for uniform type: \" + this._type);\n          this._value = b, this.trigger(\"update\");\n        }\n\n      };\n      return b.extend(e, c.prototype), e;\n    }\n\n    function f(a, c) {\n      return b.reduce(a.texts, function (a, f, g) {\n        return a[f.id] = b.reduce(c.userUniforms, function (a, b, f) {\n          var h = b.position + g;\n          return a[f] = e(b), a[f].on(\"update\", function () {\n            d(a[f].value, h, c.data, b.userUniform), c.texture.needsUpdate = !0;\n          }), a[f].value = b.userUniform.value, a;\n        }, {}), a;\n      }, {});\n    }\n\n    function g(a, c, d) {\n      return b.reduce(c.userUniforms, function (f, g, h) {\n        return f[h] = e(g), f[h].on(\"update\", function () {\n          b.each(a.texts, function (a) {\n            d[a.id][h].value = f[h].value;\n          }), c.texture.needsUpdate = !0;\n        }), f;\n      }, {});\n    }\n\n    return {\n      constructor: a.MappingMaterial,\n\n      get uniforms() {\n        return this.material.uniforms;\n      },\n\n      get mainImage() {\n        return this.material.mainImage;\n      },\n\n      get width() {\n        return this.mapping.width;\n      },\n\n      get height() {\n        return this.mapping.height;\n      },\n\n      get ratio() {\n        return this.mapping.ratio;\n      },\n\n      init: function init(a, b, c, d) {\n        this.textUniformInterface = f(this.mapping, this._userUniformDataTextureObjects), this.uniformInterface = g(this.mapping, this._userUniformDataTextureObjects, this.textUniformInterface);\n      },\n      boundsForText: function boundsForText(b) {\n        return a.Messaging.ensureInstanceOf(b, a.Text, \"Blotter.Text\", \"Blotter.MappingMaterial\", \"boundsForText\"), this.mapping.boundsForText(b);\n      }\n    };\n  }();\n}(this.Blotter, this._, this.EventEmitter), function (a, b, c) {\n  a.Material = function () {\n    this.init.apply(this, arguments);\n  }, a.Material.prototype = function () {\n    function d() {\n      return [\"void mainImage( out vec4 mainImage, in vec2 fragCoord ) {\", \"mainImage = textTexture(fragCoord / uResolution);\", \"}\"].join(\"\\n\");\n    }\n\n    function e(d) {\n      var e = {\n        _type: d.type,\n        _value: d.value,\n\n        get type() {\n          return this._type;\n        },\n\n        set type(a) {\n          this._type = a;\n        },\n\n        get value() {\n          return this._value;\n        },\n\n        set value(b) {\n          if (!a.UniformUtils.validValueForUniformType(this._type, b)) return void a.Messaging.logError(\"Blotter.Material\", !1, \"uniform value not valid for uniform type: \" + this._type);\n          this._value = b, this.trigger(\"update\");\n        }\n\n      };\n      return b.extend(e, c.prototype), e;\n    }\n\n    function f(a) {\n      return b.reduce(a, b.bind(function (a, c, d) {\n        return a[d] = e(c), a[d].on(\"update\", b.bind(function () {\n          this.trigger(\"update:uniform\", [d]);\n        }, this)), a;\n      }, this), {});\n    }\n\n    return {\n      constructor: a.Material,\n\n      get needsUpdate() {},\n\n      set needsUpdate(a) {\n        !0 === a && this.trigger(\"update\");\n      },\n\n      get mainImage() {\n        return this._mainImage;\n      },\n\n      set mainImage(a) {\n        this._mainImage = a || d();\n      },\n\n      get uniforms() {\n        return this._uniforms;\n      },\n\n      set uniforms(c) {\n        this._uniforms = f.call(this, a.UniformUtils.extractValidUniforms(b.extend(c, a.UniformUtils.defaultUniforms)));\n      },\n\n      init: function init() {\n        this.mainImage = d(), this.uniforms = {};\n      }\n    };\n  }(), a._extendWithGettersSetters(a.Material.prototype, c.prototype);\n}(this.Blotter, this._, this.EventEmitter), function (a, b) {\n  a.ShaderMaterial = function (b, c) {\n    a.Material.apply(this, arguments);\n  }, a.ShaderMaterial.prototype = Object.create(a.Material.prototype), a._extendWithGettersSetters(a.ShaderMaterial.prototype, function () {\n    return {\n      constructor: a.ShaderMaterial,\n      init: function init(a, c) {\n        b.defaults(this, c), this.mainImage = a;\n      }\n    };\n  }());\n}(this.Blotter, this._), function (a, b, c) {\n  a.RenderScope = function (b, c) {\n    this.text = b, this.blotter = c, this.material = {\n      mainImage: this.blotter.material.mainImage\n    }, this._mappingMaterial = c.mappingMaterial, this.playing = this.blotter.autoplay, this.timeDelta = 0, this.lastDrawTime = !1, this.frameCount = 0, this.domElement = a.CanvasUtils.hiDpiCanvas(0, 0, this.blotter.ratio, {\n      class: \"b-canvas\",\n      html: b.value\n    }), this.context = this.domElement.getContext(\"2d\");\n  }, a.RenderScope.prototype = function () {\n    function d() {\n      function b(b) {\n        c.domElement.addEventListener(b, function (d) {\n          var e = a.CanvasUtils.normalizedMousePosition(c.domElement, d);\n          c.emit(b, e);\n        }, !1);\n      }\n\n      for (var c = this, d = [\"mousedown\", \"mouseup\", \"mousemove\", \"mouseenter\", \"mouseleave\"], e = 0; e < d.length; e++) {\n        b(d[e]);\n      }\n    }\n\n    function e(a, b) {\n      var c = a.boundsForText(b);\n      if (c) return {\n        w: c.w,\n        h: c.h,\n        x: -1 * Math.floor(c.x),\n        y: -1 * Math.floor(a.height - (c.y + c.h))\n      };\n    }\n\n    function f(a, c) {\n      b.each(a, function (a, b) {\n        var d = c[b];\n\n        if (d) {\n          var e = d.type == a.type,\n              f = d.value == a.value;\n          e && !f && (d.value = a.value);\n        }\n      });\n    }\n\n    function g(d) {\n      var e = {\n        _type: d.type,\n        _value: d.value,\n\n        get type() {\n          return this._type;\n        },\n\n        set type(b) {\n          a.Messaging.logError(\"Blotter.RenderScope\", !1, \"uniform types may not be updated through a text scope\");\n        },\n\n        get value() {\n          return this._value;\n        },\n\n        set value(b) {\n          if (!a.UniformUtils.validValueForUniformType(this._type, b)) return void a.Messaging.logError(\"Blotter.RenderScope\", !1, \"uniform value not valid for uniform type: \" + this._type);\n          this._value = b, this.trigger(\"update\");\n        }\n\n      };\n      return b.extend(e, c.prototype), e;\n    }\n\n    function h(a) {\n      return b.reduce(a, b.bind(function (a, c, d) {\n        return a[d] = g(c), a[d].on(\"update\", b.bind(function () {\n          this.trigger(\"update:uniform\", [d]);\n        }, this)), a;\n      }, this), {});\n    }\n\n    function i() {\n      var b = this._mappingMaterial,\n          c = b && e(b, this.text),\n          d = this.material.uniforms;\n      b && c && (a.CanvasUtils.updateCanvasSize(this.domElement, c.w / this.blotter.ratio, c.h / this.blotter.ratio, this.blotter.ratio), this.domElement.innerHTML = this.text.value, this.bounds = c, this.material.uniforms = h.call(this, b.uniforms), this.material.mainImage = b.mainImage, d && f(d, this.material.uniforms), this.trigger(this.lastUpdated ? \"update\" : \"ready\"), this.lastUpdated = Date.now());\n    }\n\n    return {\n      constructor: a.RenderScope,\n\n      get needsUpdate() {},\n\n      set needsUpdate(a) {\n        !0 === a && i.call(this);\n      },\n\n      get mappingMaterial() {},\n\n      set mappingMaterial(a) {\n        this._mappingMaterial = a;\n      },\n\n      play: function play() {\n        this.playing = !0;\n      },\n      pause: function pause() {\n        this.playing = !1;\n      },\n      render: function render() {\n        if (this.bounds) {\n          var a = Date.now();\n          this.frameCount += 1, this.timeDelta = (a - (this.lastDrawTime || a)) / 1e3, this.lastDrawTime = a, this.context.clearRect(0, 0, this.domElement.width, this.domElement.height), this.context.putImageData(this.blotter.imageData, this.bounds.x, this.bounds.y), this.trigger(\"render\", [this.frameCount]);\n        }\n      },\n      appendTo: function appendTo(a) {\n        return \"function\" == typeof a.append ? a.append(this.domElement) : a.appendChild(this.domElement), d.call(this), this;\n      }\n    };\n  }(), a._extendWithGettersSetters(a.RenderScope.prototype, c.prototype);\n}(this.Blotter, this._, this.EventEmitter), function (a, b, c, d) {\n  var e = this;\n  a.Renderer = function () {\n    this._currentAnimationLoop = !1, this._scene = new c.Scene(), this._plane = new c.PlaneGeometry(1, 1), this._material = new c.MeshBasicMaterial(), this._mesh = new c.Mesh(this._plane, this._material), this._scene.add(this._mesh), this._camera = new c.OrthographicCamera(.5, .5, .5, .5, 0, 100), this.init.apply(this, arguments);\n  }, a.Renderer.prototype = function () {\n    function d(a, b) {\n      var d = new c.WebGLRenderTarget(a, b, {\n        minFilter: c.LinearFilter,\n        magFilter: c.LinearFilter,\n        format: c.RGBAFormat,\n        type: c.UnsignedByteType\n      });\n      return d.texture.generateMipmaps = !1, d.width = a, d.height = b, d;\n    }\n\n    function f() {\n      a.webglRenderer.render(this._scene, this._camera, this._renderTarget), a.webglRenderer.readRenderTargetPixels(this._renderTarget, 0, 0, this._renderTarget.width, this._renderTarget.height, this._imageDataArray), this.trigger(\"render\"), this._currentAnimationLoop = e.requestAnimationFrame(b.bind(f, this));\n    }\n\n    return {\n      constructor: a.Renderer,\n\n      get material() {},\n\n      set material(a) {\n        a instanceof c.Material && (this._material = a, this._mesh.material = a);\n      },\n\n      get width() {\n        return this._width;\n      },\n\n      set width(a) {\n        this.setSize(a, this._height);\n      },\n\n      get height() {\n        return this._height;\n      },\n\n      set height(a) {\n        this.setSize(this._width, a);\n      },\n\n      init: function init() {\n        this.setSize(1, 1);\n      },\n      start: function start() {\n        this._currentAnimationLoop || f.call(this);\n      },\n      stop: function stop() {\n        this._currentAnimationLoop && (e.cancelAnimationFrame(this._currentAnimationLoop), this._currentAnimationLoop = void 0);\n      },\n      setSize: function setSize(a, b) {\n        this._width = Math.trunc(a) || 1, this._height = Math.trunc(b) || 1, this._mesh.scale.set(this._width, this._height, 1), this._camera.left = this._width / -2, this._camera.right = this._width / 2, this._camera.top = this._height / 2, this._camera.bottom = this._height / -2, this._camera.updateProjectionMatrix(), this._renderTarget = d(this._width, this._height), this._viewBuffer = new ArrayBuffer(this._width * this._height * 4), this._imageDataArray = new Uint8Array(this._viewBuffer), this._clampedImageDataArray = new Uint8ClampedArray(this._viewBuffer), this.imageData = new ImageData(this._clampedImageDataArray, this._width, this._height);\n      },\n      teardown: function teardown() {\n        this.stop();\n      }\n    };\n  }(), a._extendWithGettersSetters(a.Renderer.prototype, d.prototype);\n}(this.Blotter, this._, this.THREE, this.EventEmitter), function (a, b, c, d) {\n  a.BoundsDataTextureBuilder = function () {\n    function a(a) {\n      for (var b = a.texts, c = new Float32Array(4 * b.length), d = 0; d < b.length; d++) {\n        var e = b[d],\n            f = a.boundsForText(e);\n        c[4 * d] = f.x, c[4 * d + 1] = a.height - (f.y + f.h), c[4 * d + 2] = f.w, c[4 * d + 3] = f.h;\n      }\n\n      return c;\n    }\n\n    return {\n      build: function build(b, e) {\n        d(function () {\n          var d = a(b),\n              f = new c.DataTexture(d, b.texts.length, 1, c.RGBAFormat, c.FloatType);\n          f.needsUpdate = !0, e(f);\n        });\n      }\n    };\n  }();\n}(this.Blotter, this._, this.THREE, this.setImmediate), function (a, b, c, d) {\n  a.IndicesDataTextureBuilder = function () {\n    function a(a, b, c, d) {\n      for (var e = a.ratio, f = new Float32Array(c * b * 4), g = b % 1, h = 1 / a.texts.length / 2, i = 1; i < f.length / 4; i++) {\n        for (var j = Math.ceil(i / (b - g)), k = i - (b - g) * (j - 1), l = 0, m = 0, n = 0, o = 0; o < a.texts.length; o++) {\n          var p = a.texts[o],\n              q = a.boundsForText(p),\n              r = q.w / e * d,\n              s = q.h / e * d,\n              t = q.x / e * d,\n              u = q.y / e * d;\n\n          if (j >= u && j <= u + s && k >= t && k <= t + r) {\n            l = o / a.texts.length + h, n = 1;\n            break;\n          }\n        }\n\n        var v = i - 1;\n        f[4 * v + 0] = l, f[4 * v + 1] = m, f[4 * v + 2] = m, f[4 * v + 3] = n;\n      }\n\n      return f;\n    }\n\n    return {\n      build: function build(b, e) {\n        var f = .5;\n        d(function () {\n          var d = b.width / b.ratio * f,\n              g = b.height / b.ratio * f,\n              h = a(b, d, g, f),\n              i = new c.DataTexture(h, d, g, c.RGBAFormat, c.FloatType);\n          i.flipY = !0, i.needsUpdate = !0, e(i);\n        });\n      }\n    };\n  }();\n}(this.Blotter, this._, this.THREE, this.setImmediate), function (a, b, c) {\n  a.TextTextureBuilder = function () {\n    return {\n      build: function build(a, d) {\n        var e,\n            f = new c.TextureLoader();\n        a.toCanvas(b.bind(function (a) {\n          e = a.toDataURL(), f.load(e, b.bind(function (a) {\n            a.minFilter = c.LinearFilter, a.magFilter = c.LinearFilter, a.generateMipmaps = !0, a.needsUpdate = !0, d(a);\n          }, this));\n        }, this));\n      }\n    };\n  }();\n}(this.Blotter, this._, this.THREE), function (a, b, c, d, e) {\n  a.MappingBuilder = function () {\n    function c(a, b) {\n      var c = a.w * a.h;\n      return b.w * b.h - c;\n    }\n\n    function f(c) {\n      return b.reduce(c, function (b, c) {\n        var d = a.TextUtils.sizeForText(c.value, c.properties);\n        return b[c.id] = d, b;\n      }, []);\n    }\n\n    return {\n      build: function build(b, g) {\n        e(function () {\n          var e = a.TextUtils.filterTexts(b),\n              h = f(e),\n              i = new d(),\n              j = [],\n              k = {};\n\n          for (var l in h) {\n            if (h.hasOwnProperty(l)) {\n              var m = h[l];\n              m.referenceId = l, j.push(m);\n            }\n          }\n\n          i.fit(j.sort(c));\n\n          for (var n = 0; n < j.length; n++) {\n            var o = j[n];\n            k[o.referenceId] = {\n              w: o.w,\n              h: o.h,\n              x: o.fit.x,\n              y: i.root.h - (o.fit.y + o.h)\n            };\n          }\n\n          g(new a.Mapping(e, k, i.root.w, i.root.h));\n        });\n      }\n    };\n  }();\n}(this.Blotter, this._, this.THREE, this.GrowingPacker, this.setImmediate), function (a, b, c) {\n  a.MappingMaterialBuilder = function () {\n    function d() {\n      return [\"varying vec2 _vTexCoord;\", \"void main() {\", \"  _vTexCoord = uv;\", \"  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\", \"}\"].join(\"\\n\");\n    }\n\n    function e(c, d, e) {\n      var f,\n          g = {\n        publicUniformDeclarations: \"\",\n        publicUniformDefinitions: \"\"\n      },\n          h = (1 / c.data.length / 2).toFixed(20),\n          i = c.texture.image.width.toFixed(1);\n      return b.reduce(c.userUniforms, function (b, c, e) {\n        var f = a.UniformUtils.fullSwizzleStringForUniformType(c.userUniform.type),\n            g = a.UniformUtils.glslDataTypeForUniformType(c.userUniform.type),\n            j = \"((\" + c.position.toFixed(1) + \" + ((textIndex - ((1.0 / \" + d.toFixed(1) + \") / 2.0)) * \" + d.toFixed(1) + \")) / \" + i + \") + \" + h;\n        return b.publicUniformDeclarations += g + \" \" + e + \";\\n\", b.publicUniformDefinitions += \"   \" + e + \" = texture2D(_userUniformsTexture, vec2(\" + j + \", 0.5)).\" + f + \";\\n\", b;\n      }, g), f = [a.Assets.Shaders.Blending, a.Assets.Shaders.TextTexture, \"uniform sampler2D _uSampler;\", \"uniform vec2 _uCanvasResolution;\", \"uniform sampler2D _uTextIndicesTexture;\", \"uniform sampler2D _uTextBoundsTexture;\", \"varying vec2 _vTexCoord;\", \"vec4 _textBounds;\", \"uniform sampler2D _userUniformsTexture;\", g.publicUniformDeclarations, \"// Helper function used by user programs to retrieve texel color information within the bounds of\", \"// any given text. This is to be used instead of `texture2D` in the fragment sources for all Blotter materials.\", \"vec4 textTexture(vec2 coord) {\", \"   vec2 adjustedFragCoord = _textBounds.xy + vec2((_textBounds.z * coord.x), (_textBounds.w * coord.y));\", \"   vec2 uv = adjustedFragCoord.xy / _uCanvasResolution;\", \"   //  If adjustedFragCoord falls outside the bounds of the current texel's text, return `vec4(0.0)`.\", \"   if (adjustedFragCoord.x < _textBounds.x ||\", \"       adjustedFragCoord.x > _textBounds.x + _textBounds.z ||\", \"       adjustedFragCoord.y < _textBounds.y ||\", \"       adjustedFragCoord.y > _textBounds.y + _textBounds.w) {\", \"     return vec4(0.0);\", \"   }\", \"   return texture2D(_uSampler, uv);\", \"}\", \"void mainImage(out vec4 mainImage, in vec2 fragCoord);\", e, \"void main(void) {\", \"   vec4 textIndexData = texture2D(_uTextIndicesTexture, _vTexCoord);\", \"   float textIndex = textIndexData.r;\", \"   float textAlpha = textIndexData.a;\", \"   _textBounds = texture2D(_uTextBoundsTexture, vec2(textIndex, 0.5));\", g.publicUniformDefinitions, \"   uResolution = _textBounds.zw;\", \"   vec2 fragCoord = gl_FragCoord.xy - _textBounds.xy;\", \"   vec4 outColor;\", \"   mainImage(outColor, fragCoord);\", \"   outColor.a = outColor.a * textAlpha;\", \"   gl_FragColor = outColor;\", \"}\"], f.join(\"\\n\");\n    }\n\n    function f(b, c) {\n      a.TextTextureBuilder.build(b, function (a) {\n        c(a);\n      });\n    }\n\n    function g(c, d) {\n      var e,\n          f,\n          g,\n          h = [];\n      e = function e() {\n        return function (b) {\n          a.IndicesDataTextureBuilder.build(c, function (a) {\n            h.push({\n              uniformName: \"_uTextIndicesTexture\",\n              texture: a\n            }), b();\n          });\n        };\n      }, f = function f() {\n        return function (b) {\n          a.BoundsDataTextureBuilder.build(c, function (a) {\n            h.push({\n              uniformName: \"_uTextBoundsTexture\",\n              texture: a\n            }), b();\n          });\n        };\n      }, g = [e(), f()], b(g).reduceRight(b.wrap, function () {\n        d(h);\n      })();\n    }\n\n    function h(d, e, f) {\n      a.UniformUtils.ensureHasRequiredDefaultUniforms(d, \"Blotter.MappingMaterialBuilder\", \"_buildUserUniformDataTextureObjects\"), d = a.UniformUtils.extractValidUniforms(d);\n      var g = Object.keys(d).length * e,\n          h = new Float32Array(4 * g),\n          i = new c.DataTexture(h, g, 1, c.RGBAFormat, c.FloatType),\n          j = {\n        data: h,\n        texture: i,\n        userUniforms: {}\n      };\n      b.reduce(d, function (a, b, c) {\n        var f = Object.keys(d).indexOf(c) * e;\n        return a.userUniforms[c] = {\n          userUniform: b,\n          position: f\n        }, a;\n      }, j), f(j);\n    }\n\n    function i(a) {\n      return b.reduce(a, function (a, b) {\n        return a[b.uniformName] = {\n          type: \"t\",\n          value: b.texture\n        }, a;\n      }, {});\n    }\n\n    function j(a) {\n      return {\n        _userUniformsTexture: {\n          type: \"t\",\n          value: a.texture\n        }\n      };\n    }\n\n    function k(a, c, d, e, f) {\n      var g = {\n        _uSampler: {\n          type: \"t\",\n          value: d\n        },\n        _uCanvasResolution: {\n          type: \"2f\",\n          value: [a, c]\n        }\n      };\n      return b.extend(g, i(e)), b.extend(g, j(f)), g;\n    }\n\n    function l(a, b, d) {\n      var e = new c.ShaderMaterial({\n        vertexShader: a,\n        fragmentShader: b,\n        uniforms: d\n      });\n      return e.depthTest = !1, e.depthWrite = !1, e.premultipliedAlpha = !1, e;\n    }\n\n    return {\n      build: function build(c, i, j) {\n        var m, n, o, p, q;\n        m = function m() {\n          return function (a) {\n            f(c, function (b) {\n              o = b, a();\n            });\n          };\n        }, n = function n() {\n          return function (a) {\n            g(c, function (b) {\n              p = b, a();\n            });\n          };\n        }, buildUserUniformDataTextureObjects = function buildUserUniformDataTextureObjects() {\n          return function (a) {\n            h(i.uniforms, c.texts.length, function (b) {\n              userUniformDataTextureObjects = b, a();\n            });\n          };\n        }, q = [m(), n(), buildUserUniformDataTextureObjects()], b(q).reduceRight(b.wrap, function () {\n          var f = k(c.width, c.height, o, p, userUniformDataTextureObjects),\n              g = (b.omit(f, \"_uCanvasResolution\", \"_uSampler\", \"_uTextBoundsTexture\", \"_uTextIndicesTexture\"), l(d(), e(userUniformDataTextureObjects, c.texts.length, i.mainImage), f));\n          j(new a.MappingMaterial(c, i, g, userUniformDataTextureObjects));\n        })();\n      }\n    };\n  }();\n}(this.Blotter, this._, this.THREE);"},"sourceMaps":null,"error":null,"hash":"f92ad25d3cc7a4af6b4cd08293de691d","cacheData":{"env":{}}}